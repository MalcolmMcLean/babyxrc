<FileSystem>
	<directory name="Treasury">
		<file name="csv.h" type="text">

#ifndef csv_h
#define csv_h

#define CSV_NULL 0       /* null data */
#define CSV_REAL 1       /* floating-point data */
#define CSV_STRING 2     /* string data */
#define CSV_BOOL 3       /* boolean data */

typedef union
{
  double x;        /* real value   */
  char *str;       /* string value */
} CSV_VALUE;

typedef struct
{
  char **names;     /* column names (can be NULL) */
  int *types;       /* type of column CSV_REAL, CSV_STRING etc */
  int width;        /* number of columns */
  int height;       /* number of row (excl header) */
  CSV_VALUE *data;  /* data in row-major format */
} CSV;

CSV *loadcsv(const char *fname);
void killcsv(CSV *csv);
void csv_getsize(CSV *csv, int *width, int *height);
int csv_hasdata(CSV *csv, int col, int row);
double csv_get(CSV *csv, int col, int row);
const char *csv_getstr(CSV *csv, int col, int row);
int csv_hasheader(CSV *csv);
const char *csv_column(CSV *csv, int col, int *type);

#endif

		</file>
		<file name="pdbutils.h" type="text">

#ifndef pdbutils_h
#define pdbutils_h

char *pdbdate(void);
void writepdbremark(FILE *fp, const char *str);
void writepdbsequence(FILE *fp, char *seq, char chain);
void writepdbterminator(FILE *fp, int serial, char residue, char chain, int resid, char insertion);
void writepdbrecord(FILE *fp, int id, char *name, char res, int resid, float x, float y, float z);
void writepdbatom(FILE *fp, int atomid, char *name, char altloc, char *resname,char chainid, int resid, char insertioncode, float x, float y, float z, float occupancy, float temp, char *segid, char *element, char *charge );
void writepdbhetrecord(FILE *fp, int id, char *name, char res, int resid, float x, float y, float z);
void writepdbfakecrystaldata(FILE *fp);

#endif

		</file>
		<file name="aminogeom.h" type="text">
#ifndef aminogeom_h
#define aminogeom_h

int isamino(int ch);
int aminoidtoindex(int aa);
void one2three(char *ret, int aa);
char three2one(char *code3);
int getNsideatoms(int aa);
int getNheavysideatoms(int aa);
int getNchiangles(int aa);
int heavynametoindex(int aa, char *name);
char *indextoname(int aa, int idx);
int getconnected(int aa, int atom1, int atom2);

#endif

		</file>
		<file name="torsion.h" type="text">
#ifndef torsion_h
#define torsion_h

float calctorsion(float *A, float *B, float *C, float *D);
void puttor(float *D, float *A, float *B, float *C, float len, float theta, float phi);

#endif

		</file>
		<file name="jpeg.c" type="text">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

#include &quot;jpeg.h&quot;

#define clamp(x, low, high) ((x) &lt; (low) ? (low) : (x) &gt; (high) ? (high) : (x))

/* Huffman tree */
typedef struct huffnode
{
  struct huffnode *child0;   /* child for &apos;0&apos; */
  struct huffnode *child1;   /* child for &apos;1&apos; */
  int symbol;                /* symbol (leaves only) */
  int suppbits;              /* unused extra bits in Huffman code (leaves only) */
} HUFFNODE;

/* information about JPEG file */
typedef struct
{
  int width;                 /* width in pixels */
  int height;                /* height in pixels */
  int qttable[4][64];        /* four qunatisation tables */
  HUFFNODE *dctable[4];      /* four dc Huffman trees */
  HUFFNODE *actable[4];      /* four ac Huffman trees */
  int Ncomponents;           /* number of components in image (up to 4) */
  int component_type[4];     /* type of each 1 = Y, 2 = Cb, 3 = Cr, 4 = I, 5 = Q */
  int vsample[4];            /* sampling rate for vertical */
  int hsample[4];            /* sampling rate for horizontal */
  int usedc[4];              /* index of dc Huffman tree to use */
  int useac[4];              /* index of ac Huffman tree to use */
  int useq[4];               /* index of quantisation tbale to use */
  int dri;                   /* restart interval */

} JPEGHEADER;

/* read bits from files */
typedef struct
{
  FILE *fp;        /* file pointer */
  int rack;        /* character just read */
  int bit;         /* maks for bit to read */
} BITSTREAM;



/*
    SOF0  = $c0   Start Of Frame (baseline JPEG), for details see below
	SOF1  = $c1   dito
	SOF2  = $c2   usually unsupported
	SOF3  = $c3   usually unsupported

	SOF5  = $c5   usually unsupported
	SOF6  = $c6   usually unsupported
	SOF7  = $c7   usually unsupported

	SOF9  = $c9   for arithmetic coding, usually unsupported
	SOF10 = $ca   usually unsupported
	SOF11 = $cb   usually unsupported

	SOF13 = $cd   usually unsupported
	SOF14 = $ce   usually unsupported
	SOF14 = $ce   usually unsupported
	SOF15 = $cf   usually unsupported

	DHT   = $c4   Define Huffman Table, for details see below
	JPG   = $c8   undefined/reserved (causes decoding error)
	DAC   = $cc   Define Arithmetic Table, usually unsupported

   *RST0  = $d0   RSTn are used for resync, may be ignored
   *RST1  = $d1
   *RST2  = $d2
   *RST3  = $d3
   *RST4  = $d4
   *RST5  = $d5
   *RST6  = $d6
   *RST7  = $d7

	SOI   = $d8   Start Of Image
	EOI   = $d9   End Of Image
	SOS   = $da   Start Of Scan, for details see below
	DQT   = $db   Define Quantization Table, for details see below
	DNL   = $dc   usually unsupported, ignore

	SOI   = $d8   Start Of Image
	EOI   = $d9   End Of Image
	SOS   = $da   Start Of Scan, for details see below
	DQT   = $db   Define Quantization Table, for details see below
	DNL   = $dc   usually unsupported, ignore
	DRI   = $dd   Define Restart Interval, for details see below
	DHP   = $de   ignore (skip)
	EXP   = $df   ignore (skip)

	APP0  = $e0   JFIF APP0 segment marker, for details see below
	APP15 = $ef   ignore

	JPG0  = $f0   ignore (skip)
	JPG13 = $fd   ignore (skip)
	COM   = $fe   Comment, for details see below

*/

#define SOF0  0xC0 /*  Start Of Frame (baseline JPEG) */
#define SOF1  0xC1 /*   ditto */
#define DHT   0xC4 /*  Define Huffman Table */
#define DQT   0xDB /*  Define Quantization Table */
#define DRI   0xDD /*  Define Restart Interval */
#define APP0  0xE0 /*  JFIF APP0 segment marker */
#define SOI   0xD8 /*  Start Of Image */
#define EOI   0xD9 /*  End Of Image */
#define SOS   0xDA /*  Start Of Scan, for details see below */


static JPEGHEADER *loadheader(FILE *fp);
static void killheader(JPEGHEADER *hdr);
static int loadscan(JPEGHEADER *hdr, unsigned char *buff, FILE *fp);
static int loadscanmono(JPEGHEADER *hdr, unsigned char *buff, FILE *fp);
static int loadscanYuv(JPEGHEADER *hdr, unsigned char *buff, FILE *fp);
static int loadscanYuv111(JPEGHEADER *hdr, unsigned char *buff, FILE *fp);
static void pasteblock(unsigned char *buff, int width, int height, unsigned char *block, int x, int y);
static void reconstitute(unsigned char *block, short *lum1, short *lum2, short *lum3, short *lum4, short *cr, short *cb);
static int loadsoi(FILE *fp);
static int loadeoi(FILE *fp);
static int startofframe(JPEGHEADER *hdr, FILE *fp);
static int loadapp0(FILE *fp);
static int dri(JPEGHEADER *hdr, FILE *fp);
static int dqt(JPEGHEADER *hdr, FILE *fp,int length);
static int dht(JPEGHEADER *hdr, FILE *fp, int length);
static int startofscan(JPEGHEADER *hdr, FILE *fp, int length);
static int skipsegment(FILE *fp, int length);
static int segmentheader(FILE *fp, int *size);

static void idct8x8(short *block);
static void fastidct8(short *x);
static void unzigzag(short *block);
static int getblock(short *ret, HUFFNODE *dctree, HUFFNODE *tree, BITSTREAM *bs);

static HUFFNODE *buildhufftree(int *codelength, unsigned char *symbols);
static void buildtreerec(HUFFNODE *first, HUFFNODE *last, char **code, unsigned char *symbol, int N, int bit);
static char **buildcanonical(int *codelength);
static char *inttocode(int code, int length);
static int tree_getsymbol(HUFFNODE *node, BITSTREAM *bs);

static BITSTREAM *bitstream(FILE *fp);
static void killbitstream(BITSTREAM *bs);
static int readmarker(BITSTREAM *bs);
static int getsymbol(BITSTREAM *bs, int bits);
static int getbit(BITSTREAM *bs);

static int fget16(FILE *fp);


/*
  load a JPEG file.
  Params: path - nmae of file to load
          width - return pointer for file width
		  height - return pointer for file height
  Returns: image in rgb format, 0 on fail.
*/
unsigned char *loadjpeg(const char *path, int *width, int *height)
{
  FILE *fp;
  unsigned char *answer;
  JPEGHEADER *header;

  *width = -1;
  *height = -1;

  fp = fopen(path, &quot;rb&quot;);
  if(!fp)
    return 0;

  printf(&quot;Opened %s\n&quot;, path);

  header = loadheader(fp);
  if(!header)
  {
    fclose(fp);
	return 0;
  }

  answer = malloc(header-&gt;width * header-&gt;height * 3);
  if(!answer)
  {
    killheader(header);
	return 0;
  }
  printf(&quot;Loaded header\n&quot;);

  if( loadscan(header, answer, fp) == -1)
  {
    killheader(header);
	free(answer);
    return 0;
  }
  
  printf(&quot;Done scan\n&quot;);

  fclose(fp);

  *width = header-&gt;width;
  *height = header-&gt;height;

  killheader(header);

  return answer;
}

/*
  load information about the JPEG file.
  Params: fp - pointer to file
  Returns: the header, or NULL on fail.
*/
static JPEGHEADER *loadheader(FILE *fp)
{
  JPEGHEADER *answer;
  int length;
  int seg;
  int i;
  
  answer = malloc(sizeof(JPEGHEADER));
  if(!answer)
    return 0;

  for(i=0;i&lt;4;i++)
  {
	answer-&gt;dctable[i] = 0;
    answer-&gt;actable[i] =0;
  }
  answer-&gt;dri = 0;

  if( loadsoi(fp) == -1 )
    goto error_exit;
  printf(&quot;loadedsoi\n&quot;);

  seg = segmentheader(fp, &amp;length);
  if(seg != APP0)
	goto error_exit;

  if( loadapp0(fp) == -1)
    goto error_exit;
  printf(&quot;Loaded app0\n&quot;);

  do
  {
    seg = segmentheader(fp, &amp;length);
	switch(seg)
	{
	  case SOF0:
	  case SOF1:
		printf(&quot;sof\n&quot;);
	    if( startofframe(answer, fp) == -1 )
		  goto error_exit;
		break;
	  case DRI:
		printf(&quot;dri\n&quot;);
	    dri(answer, fp);
		//goto error_exit;
		break;
	  case DHT:
		printf(&quot;dht\n&quot;);
	    if( dht(answer, fp, length) == -1)
		  goto error_exit;
		break;
	  case DQT:
		printf(&quot;dqt\n&quot;);
	    if( dqt(answer, fp, length) == -1)
		  goto error_exit;
		break;
	  case SOS:
		printf(&quot;sos\n&quot;);
		if( startofscan(answer, fp, length) == -1)
		  goto error_exit;
		break;
	  default:
	    if( skipsegment(fp, length) == -1)
	      goto error_exit;
		break;
	}
  } while(seg != SOS); 

  return answer;

error_exit:
  killheader(answer);
  return 0;
}

/*
  destructor for JPEH header structure
  Params: hdr - structure to destroy.
*/
static void killheader(JPEGHEADER *hdr)
{
  int i;
  if(hdr)
  {
	for(i=0;i&lt;4;i++)
	{
	  if(hdr-&gt;dctable[i])
        free( hdr-&gt;dctable[i] );
	  if(hdr-&gt;actable[i])
	    free( hdr-&gt;actable[i] );
	}
    free(hdr);
  }
}

/*
  load the raster scan for a JPEG image.
  Params: hdr - the JPEG header
          buff - output buffer (3 * width * height)
		  fp - poiter to an open file.
  Returns: 0 on success, -1 on fail
  Notes: throws out unusual JPEGS with components in odd
    order, etc.
*/
static int loadscan(JPEGHEADER *hdr, unsigned char *buff, FILE *fp)
{
  /* monochrome jPEG */
  if(hdr-&gt;Ncomponents == 1)
  {
    if(hdr-&gt;component_type[0] != 1)
	  return -1;
	if(hdr-&gt;vsample[0] != 1)
	  return -1;
	if(hdr-&gt;hsample[0] != 1)
	  return -1;
	return loadscanmono(hdr, buff, fp);
  }
  /* colour JPEG */
  else if(hdr-&gt;Ncomponents == 3)
  {
    if(hdr-&gt;component_type[0] != 1)
	  return -1;
	if(hdr-&gt;component_type[1] != 2)
	  return -1;
	if(hdr-&gt;component_type[2] != 3)
	  return -1;
		   printf(&quot;%d %d %d %d %d %d\n&quot;, hdr-&gt;hsample[0], hdr-&gt;vsample[0], hdr-&gt;hsample[1], hdr-&gt;vsample[1], hdr-&gt;hsample[2], hdr-&gt;vsample[2]);

	if(
	   hdr-&gt;hsample[0] == 2 &amp;&amp; hdr-&gt;vsample[0] == 2 &amp;&amp;
	   hdr-&gt;hsample[1] == 1 &amp;&amp; hdr-&gt;vsample[1] == 1 &amp;&amp;
	   hdr-&gt;hsample[2] == 1 &amp;&amp; hdr-&gt;vsample[2] == 1)
	return loadscanYuv(hdr, buff, fp);
	if(hdr-&gt;hsample[0] == 1 &amp;&amp; hdr-&gt;vsample[0] == 1 &amp;&amp;
	   hdr-&gt;hsample[1] == 1 &amp;&amp; hdr-&gt;vsample[1] == 1 &amp;&amp;
	   hdr-&gt;hsample[2] == 1 &amp;&amp; hdr-&gt;vsample[2] == 1)
	return loadscanYuv111(hdr, buff, fp);
	else
	  return -1;
  }
  else
    return -1;
}

/*
  load raster data for monochrome JPEG.
  Params hdr - header information
         buff - output buffer (24-bit rgb)
		 fp - pointer to an open file
  Returns: 0 on success, -1 on fail.
*/
static int loadscanmono(JPEGHEADER *hdr, unsigned char *buff, FILE *fp)
{
  BITSTREAM *bs;
  short lum[64];
  int target;
  int i;
  int ii;
  int iii;
  int iv;
  int diffdc = 0;
  int ac;
  int dc;

  bs = bitstream(fp);
  if(!bs)
  {
	return -1;
  }

  dc = hdr-&gt;usedc[0];
  ac = hdr-&gt;useac[0];

  for(i=0;i&lt;hdr-&gt;height;i+=8)
    for(ii=0;ii&lt;hdr-&gt;width;ii+=8)
	{
      getblock(lum, hdr-&gt;dctable[dc], hdr-&gt;actable[ac], bs);
	  lum[0] += diffdc;
	  diffdc = lum[0];
	  for(iii=0;iii&lt;64;iii++)
		lum[iii] *= hdr-&gt;qttable[0][iii];
	  unzigzag(lum);
	  idct8x8(lum);
	  for(iii=0;iii&lt;8;iii++)
	  {
		if(i + iii &gt;= hdr-&gt;height)
		  break;
		for(iv=0;iv&lt;8;iv++)
		{
	      if(ii + iv &gt;= hdr-&gt;width)
			break;
		  target = (i + iii) * hdr-&gt;width * 3 + (ii + iv) * 3;
		  buff[ target ] = lum[iii*8+iv] / 64 + 128;
		  buff[ target+1] = lum[iii*8+iv] / 64 + 128;
		  buff[ target+2] = lum[iii*8+iv] / 64 + 128;
		}
	  }
	}
  killbitstream(bs);

  if(loadeoi(fp) == 0)
	return 0;
  else
	return -1;
}

/*
  load JPEG Yuv colur raster data
  Params: hdr - the JPEG header
          buff - output buffer
		  fp - pointer to an open file
  Returns: 0 on success, -1 on fail
*/
static int loadscanYuv(JPEGHEADER *hdr, unsigned char *buff, FILE *fp)
{
  BITSTREAM *bs;
  short lum[4][64];
  short cr[64];
  short cb[64];
  unsigned char *block;
  int i;
  int ii;
  int iii;
  int iv;
  int diffdc = 0;
  int dcr = 0;
  int dcb = 0;
  int actableY;
  int actableCb;
  int actableCr;
  int dctableY;
  int dctableCb;
  int dctableCr;
  int count = 0;


  block = malloc(16*16*3);
  bs = bitstream(fp);

  actableY = hdr-&gt;useac[0];
  actableCb = hdr-&gt;useac[1];
  actableCr = hdr-&gt;useac[2];
  dctableY = hdr-&gt;usedc[0];
  dctableCb = hdr-&gt;usedc[1];
  dctableCr = hdr-&gt;usedc[2];

  for(i=0;i&lt;hdr-&gt;height;i+=16)
  {
	for(ii=0;ii&lt;hdr-&gt;width;ii+=16)
    {
	  if(hdr-&gt;dri &amp;&amp; (count % hdr-&gt;dri) == 0 &amp;&amp; count &gt; 0 )
	  {
		readmarker(bs);
		diffdc = 0;
		dcb = 0;
		dcr = 0;
	  }

	  for(iii=0;iii&lt;4;iii++)
	  {
        getblock(lum[iii], hdr-&gt;dctable[dctableY], hdr-&gt;actable[actableY], bs);
		lum[iii][0] += diffdc;
		diffdc = lum[iii][0];
		
		for(iv=0;iv&lt;64;iv++)
		  lum[iii][iv] *= hdr-&gt;qttable[hdr-&gt;useq[0]][iv];
		unzigzag(lum[iii]);
		idct8x8(lum[iii]);
		
	  }
	  
	  getblock(cb, hdr-&gt;dctable[dctableCb], hdr-&gt;actable[actableCb], bs);
	  cb[0] += dcb;
	  dcb = cb[0];
	  for(iv=0;iv&lt;64;iv++)
		cb[iv] *= hdr-&gt;qttable[hdr-&gt;useq[1]][iv];
	  idct8x8(cb);
	  unzigzag(cb);
	 

	  getblock(cr, hdr-&gt;dctable[dctableCr], hdr-&gt;actable[actableCr], bs);
	  cr[0] += dcr;
	  dcr = cr[0];
	  for(iv=0;iv&lt;64;iv++)
		cr[iv] *= hdr-&gt;qttable[hdr-&gt;useq[2]][iv];
	  unzigzag(cr);
	  idct8x8(cr);

	  reconstitute(block, lum[0], lum[1], lum[2], lum[3], cr, cb);
	  pasteblock(buff, hdr-&gt;width, hdr-&gt;height, block, ii, i);

	  count++;
    }
  }

  killbitstream(bs);
  free(block);


  if(loadeoi(fp) == 0)
	return 0;

  return -1;
}

static int loadscanYuv111(JPEGHEADER *hdr, unsigned char *buff, FILE *fp)
{
  short lum[64];
  short Cb[64];
  short Cr[64];
  BITSTREAM *bs;
  int i;
  int ii;
  int iii;
  int iv;
  int diffdc = 0;
  int dcb = 0;
  int dcr = 0;
  int actableY;
  int actableCb;
  int actableCr;
  int dctableY;
  int dctableCb;
  int dctableCr;
  int count = 0;
  int target;
  int luminance;
  int red;
  int green;
  int blue;

  actableY = hdr-&gt;useac[0];
  actableCb = hdr-&gt;useac[1];
  actableCr = hdr-&gt;useac[2];
  dctableY = hdr-&gt;usedc[0];
  dctableCb = hdr-&gt;usedc[1];
  dctableCr = hdr-&gt;usedc[2];

  bs = bitstream(fp);

  for(i=0;i&lt;hdr-&gt;height;i+=8)
    for(ii=0;ii&lt;hdr-&gt;width;ii+=8)
	{
	  if(hdr-&gt;dri &amp;&amp; (count % hdr-&gt;dri) == 0 &amp;&amp; count &gt; 0 )
	  {
		readmarker(bs);
		diffdc = 0;
		dcb = 0;
		dcr = 0;
	  }

      getblock(lum, hdr-&gt;dctable[dctableY], hdr-&gt;actable[actableY], bs);
	  lum[0] += diffdc;
	  diffdc = lum[0];
		
	  for(iv=0;iv&lt;64;iv++)
		lum[iv] *= hdr-&gt;qttable[hdr-&gt;useq[0]][iv];
	  unzigzag(lum);
	  idct8x8(lum);
	  
	  getblock(Cb, hdr-&gt;dctable[dctableCb], hdr-&gt;actable[actableCb], bs);
	  Cb[0] += dcb;
	  dcb = Cb[0];
		
	  for(iv=0;iv&lt;64;iv++)
		Cb[iv] *= hdr-&gt;qttable[hdr-&gt;useq[1]][iv];
	  unzigzag(Cb);
	  idct8x8(Cb);
	  
	  getblock(Cr, hdr-&gt;dctable[dctableCr], hdr-&gt;actable[actableCr], bs);
	  Cr[0] += dcr;
	  dcr = Cr[0];
		
	  for(iv=0;iv&lt;64;iv++)
		Cr[iv] *= hdr-&gt;qttable[hdr-&gt;useq[2]][iv];
	  unzigzag(Cr);
	  idct8x8(Cr);

	  for(iii=0;iii&lt;8;iii++)
	  {
		if( i + iii &gt;= hdr-&gt;height)
		  break;
		for(iv=0;iv&lt;8;iv++)
		{
		  if(ii + iv &gt;= hdr-&gt;width)
			break;
          target = (i + iii) * hdr-&gt;width * 3 + (ii + iv) * 3;
		  luminance = lum[iii*8+iv]/64 + 128;
		  red = (int) (luminance + 1.402  * Cr[iii*8+iv]/64);
	      green = (int) (luminance - 0.34414 * Cb[iii*8+iv]/64 - 0.71414 * Cr[iii*8+iv]/64);
          blue = (int) (luminance + 1.772  * Cb[iii*8+iv]/64);
		  red = clamp(red, 0, 255);
		  green = clamp(green, 0, 255);
		  blue = clamp(blue, 0, 255);
		  buff[target] = red;
		  buff[target+1] = green;
		  buff[target+2] = blue;
		}
	  }

	  count++;
    }
  
  killbitstream(bs);
  if(loadeoi(fp) == 0)
	return 0;

  return -1;
}


/*
  paste a 16 * 16 block to the output buffer.
  Parmas: buff - output buffer
          width - output width
		  height - output height
		  block - 16 * 16 block
		  x - x corodinate to paste
		  y - y co-ordinate to paste
*/
static void pasteblock(unsigned char *buff, int width, int height, unsigned char *block, int x, int y)
{
  int i;
  int ii;
  int target;

  for(i=0;i&lt;16;i++)
	for(ii=0;ii&lt;16;ii++)
	{
	  if(i + y &gt;= height)
		continue;
	  if(ii + x &gt;= width)
		continue;
	  target = (y + i) * width * 3 + (x + ii) * 3;
	  buff[ target ] = block[i*16*3+ii*3];
	  buff[target + 1] = block[i*16*3+ii*3+1];
	  buff[target + 2] = block[i*16*3+ii*3+2];
	}
}

/*
  reconstitute blcok from Yuv parameters.
  Parmas: block - 16 8 16 rgb output block.
  lum1 - 64 luminance coefficients
  lum2 - 64 luminance coefficients
  lum3 - 64 luminance coefficients
  lum4 - 64 luminance coefficients
  cr - red chrominance
  cb - blue chrominance

*/
static void reconstitute(unsigned char *block, short *lum1, short *lum2, short *lum3, short *lum4, short *cr, short *cb)
{
  int i;
  int ii;
  int Cr;
  int Cb;
  int luminance;
  double red;
  double green;
  double blue;

  for(i=0;i&lt;16;i++)
	for(ii=0;ii&lt;16;ii++)
	{
	  if(i &lt; 8 &amp;&amp; ii &lt; 8)
		luminance = lum1[i*8+ii];
	  if(i &lt; 8 &amp;&amp; ii &gt;= 8)
		luminance = lum2[i*8+ii-8];
	  if(i&gt;=8 &amp;&amp; ii &lt; 8)
		luminance = lum3[(i-8)*8+ii];
	  if(i&gt;=8 &amp;&amp; ii &gt;=8)
		luminance = lum4[(i-8)*8+ii-8];
	  luminance = luminance/64 + 128;
	  Cr = cr[i/2 * 8 + ii/2]/64 + 128;
	  Cb = cb[i/2 * 8 + ii/2]/64 + 128;
	  red = luminance + 1.402  * (Cr-128);
	  green = luminance - 0.34414 * (Cb-128) - 0.71414*(Cr-128);
      blue = luminance + 1.772  *(Cb-128);

	  if(red &lt; 0)
		red = 0;
	  if(red &gt; 255)
		red = 255;
	  if(green &lt; 0)
		green = 0;
	  if(green &gt; 255)
		green = 255;
	  if(blue &lt; 0)
		blue = 0;
	  if(blue &gt; 255)
		blue = 255;

	  block[i*16*3+ii*3] = (unsigned char) red;
	  block[i*16*3+ii*3+1] = (unsigned char) green;
	  block[i*16*3+ii*3+2] = (unsigned char) blue;
	}
}


/*
  load the SOI (start of information) marker
  Params: fp - pointer to an open file
  Returns: 0 if marker read, -1 on fail 
*/
static int loadsoi(FILE *fp)
{
  if(fgetc(fp) != 0xFF)
    return -1;
  if(fgetc(fp) != 0xD8)
    return -1;
  return 0;
}

/*
  load the EOI (end of infromation) marker
  Parmas: fp - pointer to an open file
  Returns: 0 if marker read, -1 of fail
*/
static int loadeoi(FILE *fp)
{
  int ch;

  if(fgetc(fp) != 0xFF)
    return -1;
  while( (ch = fgetc(fp)) == 0xFF )
	continue;
  if(ch != 0xD9)
    return -1;
  return 0;
}
  
/*
 process start of frame segment
 Params: hdr - the JPEG header
         fp - open file
 Returns: 0 on success, -1 on fail
*/
static int startofframe(JPEGHEADER *hdr, FILE *fp)
{
  int precision;
  int sampling;
  int i;

  precision = fgetc(fp);
  if(precision != 8)
	return -1;
  hdr-&gt;height = fget16(fp);
  hdr-&gt;width = fget16(fp);
  hdr-&gt;Ncomponents = fgetc(fp);

  if(hdr-&gt;Ncomponents &lt; 1 || hdr-&gt;Ncomponents &gt; 4)
	return -1;

  for(i=0;i&lt;hdr-&gt;Ncomponents;i++)
  {
    hdr-&gt;component_type[i] = fgetc(fp);
	if(hdr-&gt;component_type[i] &lt; 1 || hdr-&gt;component_type[i] &gt; 5)
	  return -1;
    sampling = fgetc(fp);
	hdr-&gt;vsample[i] = sampling &amp; 0x0F;
	hdr-&gt;hsample[i] = sampling &gt;&gt; 4;
    hdr-&gt;useq[i] = fgetc(fp);
	if(hdr-&gt;useq[i] &lt; 0 || hdr-&gt;useq[i] &gt; 3)
	  return -1;
  }

  return 0;
}

/*
  load the app0 chunk of the JPEG file
  Params: fp - pointer to an open file
  Returns: 0 on success, -1 on fail
  Notes: chunk may contain a thumbnail, which we ignore
   basically we are just looking for the the version
   of the JPEG IFF file.

*/
static int loadapp0(FILE *fp)
{
  int major_revision;
  int minor_revision;
  int density_units;
  int xdensity;
  int ydensity;
  int thumbwidth;
  int thumbheight;
  int i;
  int ii;

  /* &apos;JFIF&apos;#0 ($4a, $46, $49, $46, $00), identifies JFIF */


 if(fgetc(fp) != 0x4a)
   return -1;
 if(fgetc(fp) != 0x46)
   return -1;
 if(fgetc(fp) != 0x49)
   return -1;
 if(fgetc(fp) != 0x46)
   return -1;
 if(fgetc(fp) != 0)
   return -1;

  major_revision = fgetc(fp);
  if(major_revision != 1)
	return -1;
  minor_revision = fgetc(fp);
  density_units = fgetc(fp);
  xdensity = fget16(fp);
  ydensity = fget16(fp);
  thumbwidth = fgetc(fp);
  thumbheight = fgetc(fp);

  for(i=0;i&lt;thumbheight;i++)
	for(ii=0;ii&lt;thumbwidth;ii++)
	{
	  fgetc(fp);
	  fgetc(fp);
	  fgetc(fp);
	}
  
  return 0;
}

/*
  read restart interval (ignored)
*/
static int dri(JPEGHEADER *hdr, FILE *fp)
{
  int answer;
  answer = fget16(fp);

  hdr-&gt;dri = answer;
  
  printf(&quot;dri %d\n&quot;, answer);
  return answer;
}

/*
  load quantisation tables
  Params: hdr - the header
          fp - pointer to an open file
		 length - length of segment
  Returns: 0 on success, -1 on fail
  Notes: files may contain up to four qunatisation tables
*/
static int dqt(JPEGHEADER *hdr, FILE *fp,int length)
{
  int qtinformation;
  int precision;
  int i;
  int tablenumber;


  length -= 2;

  while(length &gt; 0)
  {
    qtinformation = fgetc(fp);
	precision = (qtinformation &gt;&gt; 4) &amp; 0xFF;
    tablenumber = qtinformation &amp; 0x0F;
	length--; 

    if(precision)
	{
      for(i=0;i&lt;64;i++)
	    hdr-&gt;qttable[tablenumber][i] = fget16(fp);
	  length -= 128;
	}
    else
	{
      for(i=0;i&lt;64;i++)
	    hdr-&gt;qttable[tablenumber][i] = fgetc(fp);
	  length -= 64;
	}
	
  }

  if(length == 0)
	return 0;
  else
	return -1;

}

/*
  load the huffman table
  Params: hdr - the header
          fp - pointer to an open file
		  length - table length
  Returns: 0 on success, -1 on fail
*/
static int dht(JPEGHEADER *hdr, FILE *fp, int length)
{
  int tot;
  int information;
  int tablenumber;
  int tabletype;
  int codeswithlength[16];
  unsigned char symbol[256];
  int i;
  HUFFNODE *tree;

  length -= 2;

  while(length &gt; 0)
  {
    information = fgetc(fp);
	tablenumber = (information &amp; 0x0F);
	tabletype = (information &amp; 0x10) ? 1 : 0;
	tot = 0;
	for(i=0;i&lt;16;i++)
	{
	  codeswithlength[i] = fgetc(fp);
	  tot += codeswithlength[i];
	}
	for(i=0;i&lt;tot;i++)
	  symbol[i] = fgetc(fp);
	if(tot &gt; 256)
	  return -1;
	tree = buildhufftree(codeswithlength, symbol);
	if(tabletype == 0)
	  hdr-&gt;dctable[tablenumber] = tree;
	else if(tabletype == 1)
	  hdr-&gt;actable[tablenumber] = tree;
	length -= 1 + 16 + tot;
  }
  if(length == 0)
	return 0;
  else
	return -1;
}

/*
  parse start of scan
  Params: hdr - the header
          fp - pointer to an open file
  Returns: 0 on success, -1 on fail
*/
static int startofscan(JPEGHEADER *hdr, FILE *fp, int length)
{
  int i;
  int hufftable;
  //int x1, x2, x3;
  int ncomponents;

  length -= 2;

  ncomponents = fgetc(fp);
  if(ncomponents != hdr-&gt;Ncomponents)
	return -1;
  for(i=0;i&lt;hdr-&gt;Ncomponents;i++)
  {
    hdr-&gt;component_type[i] = fgetc(fp);
    hufftable = fgetc(fp);
	hdr-&gt;usedc[i] = (hufftable &gt;&gt; 4) &amp; 0x0F;
	hdr-&gt;useac[i] = hufftable &amp; 0x0F;
	if(hdr-&gt;usedc[i] &gt; 3 || hdr-&gt;useac[i] &gt; 3)
	  return -1;
	if(hdr-&gt;dctable[hdr-&gt;usedc[i]] == 0)
	  return -1;
	if(hdr-&gt;actable[hdr-&gt;useac[i]] == 0)
	  return -1;
  }
  length -= 1 + hdr-&gt;Ncomponents * 2;

  /* unused ? */
  //x1 = fgetc(fp);
  //x2 = fgetc(fp);
  //x3 = fgetc(fp);

  while(length--)
	fgetc(fp);

  return 0;
}

/*
  skip past an unknown segment
  Parmas: fp - pointer to an open file
          length - segment length (includes size field).
  Returns: 0 on success, -1 premature EOF
*/
static int skipsegment(FILE *fp, int length)
{
  if(length &lt; 2)
    return -1;
  length -= 2;
  while(length--)
  {
    if( fgetc(fp) == -1 )
	  return -1;
  }
  return 0;
}

/*
  Load segment header
  Parmas: fp - pointer to open file
	        size - return pointer for segment size
  Returns: segment id
  Notes: a segment consists one of more 0xFF bytes, followed
    by a segment size, which include the size field itself
*/
static int segmentheader(FILE *fp, int *size)
{
  int answer;
  int ch;

  ch = fgetc(fp);
  if(ch != 0xFF)
    return -1;
  while(ch == 0xFF)
	ch = fgetc(fp);
  if(ch == -1)
	return -1;
  answer = ch;

  /* RSTn are used for resync, may be ignored */
  if(ch == 1 || (ch &gt;= 0xD0 &amp;&amp; ch &lt;= 0xD7) )
	*size = 2;
  else 
    *size = fget16(fp);

  return answer;
}



/*
  perform 2d inverse cosine transform on 8*8 block.
  Parmas: block - 64 coefficients to transform
*/
static void idct8x8(short *block)
{
  short col[8];
  int i;
  int ii;

  
  for(i=0;i&lt;8;i++)
	fastidct8(block + i * 8);

  for(i=0;i&lt;64;i++)
    block[i] &gt;&gt;= 3;

  for(i=0;i&lt;8;i++)
  {
    for(ii=0;ii&lt;8;ii++)
	  col[ii] = block[ii*8+i];
	fastidct8(col);
	for(ii=0;ii&lt;8;ii++)
	  block[ii*8+i] = col[ii];
  }
  
}

/*
  fast 8 point idct.
*/
static void fastidct8(short *x)
{
  int x0, x1, x2, x3, x4, x5, x6, x7, x8;
  int W1 = 2841;
  int W2 = 2676;
  int W3 = 2408;
  int W5 = 1609;
  int W6 = 1108;
  int W7 = 565;

  if(!((x1 = x[4] &lt;&lt; 11) | (x2 = x[6]) | (x3 = x[2]) | 
	  (x4 = x[1]) | (x5 = x[7]) | (x6 = x[5]) | (x7 = x[3])))
  {
    x[0] = x[1] = x[2] = x[3] = x[4] = x[5] = x[6] = x[7] = x[0] &lt;&lt; 3;
	return;
  }
  x0 = (x[0] &lt;&lt; 11) + 128;

  /* first stage */
  x8 = W7 * (x4 + x5);
  x4 = x8 + (W1 - W7) * x4;
  x5 = x8 - (W1 + W7) * x5;
  x8 = W3 * (x6 + x7);
  x6 = x8 - (W3 - W5) * x6;
  x7 = x8 - (W3 + W5) * x7;

  /* second stage */
  x8 = x0 + x1;
  x0 -= x1;
  x1 = W6 * (x3 + x2);
  x2 = x1 - (W2 + W6) * x2;
  x3 = x1 + (W2 - W6) * x3;
  x1 = x4 + x6;
  x4 -= x6;
  x6 = x5 + x7;
  x5 -= x7;

  /* third stage */
  x7 = x8 + x3;
  x8 -= x3;
  x3 = x0 + x2;
  x0 -= x2;
  x2 = (181 * (x4 + x5) + 128) &gt;&gt; 8;
  x4 = (181 * (x4 - x5) + 128) &gt;&gt; 8;

  /* fourth stage */
  x[0] = (x7 + x1) &gt;&gt; 8;
  x[1] = (x3 + x2) &gt;&gt; 8;
  x[2] = (x0 + x4) &gt;&gt; 8;
  x[3] = (x8 + x6) &gt;&gt; 8;
  x[4] = (x8 - x6) &gt;&gt; 8;
  x[5] = (x0 - x4) &gt;&gt; 8;
  x[6] = (x3 - x2) &gt;&gt; 8;
  x[7] = (x7 - x1) &gt;&gt; 8;
}

/*
  undo zigzagging on coefficients.
  Params: block - 64 coefficients to dezigzag
*/
static void unzigzag(short *block)
{
  static int zigzag[64] =
  {0, 1, 5, 6,14,15,27,28,
   2, 4, 7,13,16,26,29,42,
   3, 8,12,17,25,30,41,43,
   9,11,18,24,31,40,44,53,
   10,19,23,32,39,45,52,54,
   20,22,33,38,46,51,55,60,
   21,34,37,47,50,56,59,61,
   35,36,48,49,57,58,62,63 };
 short temp[64];
 int i;

 for(i=0;i&lt;64;i++)
   temp[i] = block[ zigzag[i] ];
 for(i=0;i&lt;64;i++)
   block[i] = temp[i];
}

/*
  get a block of dct coefficients from file.
  Parmas: ret - return pointer for 64 coefficients
          dctree - Huffman tree for DC coefficient
		  actree - Huffman tree for 63 ac coefficients
		  bs - the bitstream.
  Returns: 0 on success, -1 on failure
*/
static int getblock(short *ret, HUFFNODE *dctree, HUFFNODE *actree, BITSTREAM *bs)
{
  int byte;
  int bits;
  int zeroes;
  int nread = 0;
  int i;

  bits = tree_getsymbol(dctree, bs);
  ret[nread++] = (short) getsymbol(bs, bits);

  do
  {
    byte = tree_getsymbol(actree, bs);

    if(byte == 0xF0)
	{
	  if(nread + 16 &gt; 64)
		return -1;

      for(i=0;i&lt;16;i++)
	    ret[nread++] = 0;
	}
    zeroes = byte &gt;&gt; 4;
    bits = byte &amp; 0x0F;
  
    if(bits != 0)
	{
	  if(nread + zeroes + 1 &gt; 64)
		return -1;
      for(i=0;i&lt;zeroes;i++)
	    ret[nread++] = 0;
      ret[nread++] = getsymbol(bs, bits);
	  if(nread == 64)
	    break;
	}
  } while(byte);

  while(nread&lt;64)
	  ret[nread++] = 0;

  return 0;
}

/*
  build the huffman tree
  Params: codelength - 16 integer giving number of codes each length
          symbols - the symbols for each code.
  Returns: pointer to constructed huffman tree
  Notes: builds canonical huffman codes.
*/
static HUFFNODE *buildhufftree(int *codelength, unsigned char *symbols)
{
  char **codes;
  HUFFNODE *answer;
  int i;
  int tot = 0;
  static int called = 0;

  called++;

  for(i=0;i&lt;16;i++)
	tot += codelength[i];

  answer = malloc( (tot + tot - 1) * sizeof(HUFFNODE));
  if(!answer)
	return 0;

  codes = buildcanonical(codelength);
  if(!codes)
  {
    free(answer);
	return 0;
  }

  buildtreerec(answer, answer + 2 * tot - 1, codes, symbols, tot, 0);

  if(called == 3)
  for(i=0;i&lt;tot;i++)
	  printf(&quot;{\&quot;%s\&quot;,%d},\n&quot;, codes[i], symbols[i]);
  printf(&quot;%d symbols\n&quot;, tot);

  for(i=0;i&lt;tot;i++)
	free(codes[i]);
  free(codes);

  return answer;
}

/*
  recursive tree-building function
  Params: first - local root of tree
          last - end of tree (for safety)
		  code - list of canonical codes
		  symbol - list of attached symbols
		  N - number of codes
		  bit - index of bit to split on
  Notes: fills the root with two children, and calls recursively.
*/
static void buildtreerec(HUFFNODE *first, HUFFNODE *last, char **code, unsigned char *symbol, int N, int bit)
{
  int i;

  if(N == 0)
	return;

  assert(last - first == 2 * N - 1);

  if(N == 1)
  {
    first-&gt;child0 = 0;
	first-&gt;child1 = 0;
	first-&gt;symbol = symbol[0];
	first-&gt;suppbits = 0;
	while(code[0][bit] != 0)
	{
	  first-&gt;suppbits++;
	  bit++;
	}
	return;
  }
  for(i=0;i&lt;N;i++)
	if(code[i][bit] == &apos;1&apos;)
	  break;
  first-&gt;child0 = first+1;
  first-&gt;child1 = first + 2 * i;
  first-&gt;symbol = -1;
  first-&gt;suppbits = 0;

  buildtreerec(first-&gt;child0, first-&gt;child1, code, symbol, i, bit + 1);
  buildtreerec(first-&gt;child1, last, code + i, symbol + i, N - i, bit + 1); 
}

/*
  constructs list of canonical huffman codes for list
  Params: codelength - 16 integers giving number of codes of length 1 - 16
  Returns: list of codes in ASCII (&apos;0&apos;,&apos;1&apos;) format.
  Notes: allocated array of allocated strings.
*/
static char **buildcanonical(int *codelength)
{
  int code = 0;
  int length = 1;
  char **answer;
  int i;
  int ii;
  int j = 0;
  int N = 0;

  for(i=0;i&lt;16;i++)
	N += codelength[i];

  answer = malloc(N * sizeof(char *));
  if(!answer)
	return 0;

  for(i=0;i&lt;16;i++)
  {
    for(ii=0;ii&lt;codelength[i];ii++)
	{
      answer[j] = inttocode(code, length);
	  if(!answer[j])
		goto error_exit;
	  j++;
	  code++;
	}
	code &lt;&lt;= 1;
	length++; 
  }
 
  return answer;
error_exit:
  for(i=0;i&lt;j;i++)
	free(answer[i]);
  free(answer);

  return 0;
}

/*
  convert code held as integer to ASCII string.
  Params: code - the huffman code
          length - number of bits
  Returns: ASCII representation of code.

*/
static char *inttocode(int code, int length)
{
  char *answer;
  int i;

  answer = malloc(length + 1);
  if(!answer)
	return 0;

  for(i=length-1;i&gt;=0;i--)
    answer[length - i - 1] = (code &amp; (1 &lt;&lt; i)) ? &apos;1&apos; : &apos;0&apos;;
  answer[length] = 0;

  return answer;
}

/*
  get a symbol from the Huffman tree
  Params: node - the node root
          bs - the bitstream to read bits from
  Returns: symbol read. 
*/
static int tree_getsymbol(HUFFNODE *node, BITSTREAM *bs)
{
  int i;

  while(node-&gt;child0)
  {
    if(getbit(bs))
	  node = node-&gt;child1;
	else
	  node = node-&gt;child0;
  }

  if(node-&gt;suppbits &gt; 0)
  {
	for(i=0;i&lt;node-&gt;suppbits;i++)
      getbit(bs);
  }

  return node-&gt;symbol;
}



/*
  bitstream constructor
  Parmas: fp - file to read bits from
  Returns: pointer to constructed object
*/
static BITSTREAM *bitstream(FILE *fp)
{
  BITSTREAM *answer;

  answer = malloc(sizeof(BITSTREAM));
  if(!answer)
	return 0;
  answer-&gt;fp = fp;
  answer-&gt;bit = 0;
  answer-&gt;rack = 0;

  return answer;
}

/*
  bitstream destructor
  Parmas: bs - pointer to object to destroy
*/
static void killbitstream(BITSTREAM *bs)
{
  free(bs);
}

static int readmarker(BITSTREAM *bs)
{
  int x;

  while(bs-&gt;bit != 0)
	getbit(bs);
  x = fgetc(bs-&gt;fp);
  x = fgetc(bs-&gt;fp);

  return 0;
}
/*
  get a symbolf from a bitstream:
  Parmas: bs - the bitstream
          bits - size of symbol
  Returns: symbol value
  Notes: negative symbols have leading zeroes
*/
static int getsymbol(BITSTREAM *bs, int bits)
{
  int answer = 0;
  int N = bits;

  if(bits == 0)
	return 0;

  while(N--)
  {
    answer &lt;&lt;= 1;
	answer |= getbit(bs);
  }
  if((answer &amp; (1 &lt;&lt; (bits-1))) == 0)
	answer -= (1 &lt;&lt; bits ) -1; 
 

  return answer;
}

/*
  get a bit from a bitstream:
  Parmas: bs - the bitstream
  Returns: the bit read.
  Notes: the stream uses 0xFF as an escape.
*/
static int getbit(BITSTREAM *bs)
{
  int answer;
  int ch;

  if(bs-&gt;bit == 0)
  {
    bs-&gt;rack = fgetc(bs-&gt;fp);
	while(bs-&gt;rack == 0xFF)
	{
	  while( (ch = fgetc(bs-&gt;fp)) == 0xFF )
		continue;
	  if(ch == 0)
		break;
	  bs-&gt;rack = fgetc(bs-&gt;fp);
    }
	bs-&gt;bit = 0x80;
  }
  
  answer = (bs-&gt;rack &amp; bs-&gt;bit) ? 1 : 0;
  bs-&gt;bit &gt;&gt;= 1;

  return answer;
}

/*
  load 16 bits from a file, big-endian
  Parmas: fp - pointer to open file
  Returns: value read
*/
static int fget16(FILE *fp)
{
  int ch;
  int answer;

  ch = fgetc(fp);
  answer = ch &lt;&lt; 8;
  ch = fgetc(fp);
  answer |= ch;

  return answer;
}




		</file>
		<file name="calctorsion.h" type="text">
#ifndef calctorsion_h
#define calctorsion_h

double calctorsion(float xi,
         float yi,
         float zi,
         float xj,
         float yj,
         float zj,
         float xk,
         float yk,
         float zk,
         float xl,
         float yl,
		   float zl);

#endif


		</file>
		<file name="replicafeedback2.c" type="text">
/*
  replicaexchange.c - mpi code for feedback-optimised replica exchange 
                 simulated annealing

  by Malcolm McLean
 
  based on an algorithm by Katzgraber HG, Trebst S, Huse DA and Troyer M

  Feedback-optimised parallel tempering Monte Carlo
  Journal of Statistical Mechanics, Theory and Experiment
  (March 2006) doi:10.1088/1742-5468/2006/03/P03018
 */

#include &lt;stdlib.h&gt;
#include &lt;float.h&gt;
#include &lt;math.h&gt;
#include &quot;mpi.h&quot;

#define UNLABELLED 0
#define UP 1
#define DOWN 2

#define MAXPROCS 1024

typedef struct
{
    double t; /* temperature */
    double score; /* score */
    int index; /* processor index */ 
} TEMPINDEX;

static int comptemperatures(const void *e1, const void *e2);
static void getnewtemperatures(double *t, int *Nup, int *Ndown, int Nprocs);
static void updatetemperatures(double *t, int *Nup, int *Ndown, int Nprocs);
static double gradient(double *y, double *x, int N, int i);
static double findres(double *etaT, double *t, int N, double p);
static void sumtounity(double *x, int N);

static int sendobject(
                 MPI_Comm comm,
                 int destid,
                 int tag, 
                 void *obj, 
                 int (*serialise)(void *obj, unsigned char *buff, int capacity, void *ptr),
                 unsigned char *buff,
                 int capacity,
                 void *(*serialisev)(void *obj, int *len, void *ptr),
                 void *ptr);

static int receiveobject(
		   MPI_Comm comm,
                   int srcid,
                   int tag,
                   void *obj, 
                   int (*deserialise)(void *obj, unsigned char *buff, int len, void *ptr), 
                   unsigned char *buff,
                   int capacity,
                   void *ptr);

static int metrop(double current, double candidate, double t);
static int replicametrop(double sclow, double schigh, double tlow, double thigh);

/*

  The main function called by user

  Params: obj - object to anneal
          clone - function to clone an object
          kill - function to destroy an object
          copy - function to copy an object
          deserialise - extract object from byte stream
          serialise - function to write object to byte stream
          serialisev -a lternative function to write object
          score - the score function to minimise
          mutate - function to execute a mutation step
          step - function called for each Metropolis step
          maxbuff - maximum size of object (can be 0 if serialsive not NULL)
          lowtemp - lowest temperature
          hightemp - highest temperature
          Nequil - number evaluations before synchronise
          Nswaps - initial number of temperature swaps before feedback 
                   optimisation
          Nsteps - number of equlibriation steps 
                   (make Nswaps + 2Nswaps + 4Nswaps ...)
          rootlowest - set if root must always have lowest temperature walk
          comm - MPI communicator
          ptr - arbitrary pointer to pass to parameterised functions
  Returns: 0 on success, -1 on fail.

  Notes:
       In order to make the function generic, it minimises an arbitrary
    score function on arbitrary data.
    On entry, the array obj should be set to initial object positions.
    On exit, obj[0] will point to the best solution found, the other
      members to the state of the run.


    There are two major functions
    
      double score(void *obj, void *ptr)
   
    This is the function to minimise. All parameterised functions have an
      arbitrary pointer passed back to them for convenience.
    
     void mutate(void *obj, void *ptr)

    This executes a jump of one step in solution space. The mutate function
      should be written so that there is a path from every state of the
      solution to every other, and so that the probability of a jump
      from a to b is the same as the probability of a jump from b to a.

    void step(void *obj, double score, int newconf, double temperature, void *ptr)
    This is called every Metropolis step. The current score and temperature 
    are passed in, along with a flag if the conformation is newly accepted. 
    Typically this will be used in the root processor to colect statistics.

    In addition there are some fucntions to perform housekeeping duties

    void *clone(void *obj, void *ptr)

    Creates a deep copy of the object, returning NULL of fail

    void kill(void *obj, void *ptr)

    Destroys an object created with clone()

    int copy(void *dest, void *src, void *ptr)

    Makes the object dest into a copy of the object src. It returns 0 on
    success or -1 on fail. Intended to be faster than clone().

    int deserialise(void *obj, unsigned char *buff, int len, void *ptr)

    Reconstructs an object from a byte stream. The stream is set up in
      buff, its length given by len. Return 0 on success, -1 on fail.

    int serialise(void *obj, unsigned char *buff, int capacity, void *ptr)

    Converts an object to a stream of bytes. It must be possible
      to place an upper bound on the object size, passed in capacity.
      On exit, buff contains a serial representation of the object. The
      fucntion returns the number of bytes actually written, -1 on fail.
      This function pointer  can be NULL.
  
    void *serialisev(void *obj, int *len, void *ptr)
  
    Converts an object to a stream of bytes, without any bound on the
      object size. Returns a pointer to memory allocated with malloc(), or
      NULL on fail. On exit, len is set to the length of the object, in bytes.
      Only one serialisation function need be provided. If serialisev() is
      provided then the algorithm will spend more time allocating and
      memory.

   If serialise() is not NULL, then maxbuff should be set to a positive number
   that gives the maximum size of an object. The algorithm needs to create
   buffers to store objects, so maxbuff should not be excessively large.
   If serialise() is NULL, maxbuff should be zero.  
   

 */
int replicafeedback(void **obj, 
           void * (*clone)(void *obj, void *ptr),
           void (*kill)(void *obj, void *ptr), 
           int  (*copy)(void *dest, void *src, void *ptr),
	   int (*deserialise)(void *obj, unsigned char *buff, int len, void *ptr),
	   int (*serialise)(void *obj, unsigned char *buff, int capacity, void *ptr),
	   void * (*serialisev)(void *obj, int *len, void *ptr),
           double (*score) (void *obj, void *ptr),
           void (*mutate) (void *obj, void *ptr),
	   void (*step)(void *obj, double score, int newconf, double temperature, void *ptr),
	 
           int maxbuff,
	   double lowtemp,
	   double hightemp,
	   int Nequil,
	   int Nswaps,
	   int Nsteps, 
	   int rootlowest,
           MPI_Comm comm, 
           void *ptr)
{
  int i, ii, iii;
  static double t[1024];
  static double scores[1024];
  static int Nup[1024];
  static int Ndown[1024];
  static int walker[1024];
  static double f[1024];
  static TEMPINDEX ti[1024];
  double temp;
  int tempi;
  double temperature;
  int Nprocs;
  int id;
  void *current;
  void *test;
  double curscore;
  double testscore;
  double bestscore;
  int accept;
  void *buff = 0;
  int Nround = 0;

  if(maxbuff &gt; 0)
    buff = malloc(maxbuff);
  
  MPI_Comm_size(comm,&amp;Nprocs); 
  MPI_Comm_rank(comm,&amp;id);

  /* start with linear distribution of temperatures */
  for(i=0;i&lt;Nprocs;i++)
    t[i] = lowtemp + (hightemp - lowtemp) * ((double) i)/(Nprocs-1);
    
  current = (*clone)(obj[id], ptr);
  test = (*clone)(obj[id], ptr);
  curscore = (*score)(current, ptr);
  bestscore = curscore;

  for(i=0;i&lt;Nsteps;i++)
  {
    Nround = 0;
   
    for(ii=0;ii&lt;Nprocs;ii++)
    {
        walker[ii] = UNLABELLED;
	Nup[ii] = 0;
        Ndown[ii] = 0;
    }
    for(ii=0;ii&lt;Nswaps;ii++)
    {
      temperature = t[id];
      for(iii=0;iii&lt;Nequil;iii++)
      {
        (*copy)(test, current, ptr);
        (*mutate)(test, ptr);
        testscore = (*score)(test, ptr);
        if(metrop(curscore, testscore, temperature))
        {
          (*copy)(current, test, ptr);
          curscore = testscore;
          if(id == 0 &amp;&amp; curscore &lt; bestscore)
	  {
            bestscore = curscore;
            (*copy)(obj[0], current, ptr); 
	  }
          accept = 1;
        }
        else
          accept = 0;
        (*step)(current, curscore, accept, temperature, ptr);
      }
    
      MPI_Gather(&amp;curscore,1,MPI_DOUBLE, scores, 1,MPI_DOUBLE,0, comm);
      if(id == 0)
      {
        for(iii=0;iii&lt;Nprocs;iii++)
        {
          ti[iii].index = iii;
          ti[iii].t = t[iii];
          ti[iii].score = scores[iii];
        }
        qsort(ti, Nprocs, sizeof(TEMPINDEX), comptemperatures);
        if( (ii % 2) == 0)
        {
	  for(iii=0;iii&lt;Nprocs-1;iii++)
            if( replicametrop(ti[iii].score, ti[iii+1].score, ti[iii].t, ti[iii+1].t) )
	    {            
              temp = ti[iii].t;
              ti[iii].t = ti[iii+1].t;
              ti[iii+1].t = temp;
	    }
       
	}
        else
        {
          for(iii=Nprocs-2;iii&gt;=0;iii--)
            if( replicametrop(ti[iii].score, ti[iii+1].score, ti[iii].t, ti[iii+1].t) )
	    {            
              temp = ti[iii].t;
              ti[iii].t = ti[iii+1].t;
              ti[iii+1].t = temp;
	    }
        } 
        qsort(ti, Nprocs, sizeof(TEMPINDEX), comptemperatures);
        if(walker[ti[0].index] == DOWN)
	    Nround++;
        walker[ti[0].index] = UP;
        walker[ti[Nprocs-1].index] = DOWN;
        for(iii=0;iii&lt;Nprocs;iii++)
        {
          if(walker[ti[iii].index] == UP)
            Nup[iii]++;
	  else if(walker[ti[iii].index] == DOWN)
            Ndown[iii]++;
          t[ ti[iii].index ] = ti[iii].t; 
        }
      }
      /* dole out new temperatures */
      MPI_Bcast(t, Nprocs, MPI_DOUBLE, 0, comm);

      /* make root processor lowest temperature */
      if(rootlowest)
      {
        if(id != 0 &amp;&amp; t[id] == lowtemp)
        {
          sendobject(comm, 0, 105, current, serialise, buff, maxbuff, serialisev, ptr);
          receiveobject(comm, 0, 106, current, deserialise, buff, maxbuff, ptr);
          curscore = (*score)(current, ptr);
          temp = t[0];
          t[0] = t[id];
          t[id] = temp;
        }
        if(id == 0 &amp;&amp; t[0] != lowtemp)
        {
	  receiveobject(comm, ti[0].index, 105, test, deserialise, buff, maxbuff, ptr);
          sendobject(comm, ti[0].index, 106, current, serialise, buff, maxbuff, serialisev, ptr);
          (*copy)(current, test, ptr);
          curscore = (*score)(current, ptr);

          temp = t[0];
          t[0] = t[ti[0].index];
          t[ti[0].index] = temp;

          tempi = walker[0];
          walker[0] = walker[ti[0].index];
          walker[ti[0].index] = tempi;
        }
      }
    }
    /* feedbackoptimised step */
    if(id == 0) 
      getnewtemperatures(t, Nup, Ndown, Nprocs );
    /* dole out new temperatures */
    MPI_Bcast(t, Nprocs, MPI_DOUBLE, 0, comm);
    Nswaps = Nswaps * 2;
  }
  /* synchronise objects */
  if(id == 0)
  {
    for(i=1;i&lt;Nprocs;i++)
      receiveobject(comm, i, 102, obj[i], deserialise, buff, maxbuff, ptr);
    for(i=1;i&lt;Nprocs;i++)
      for(ii=0;ii&lt;Nprocs;ii++)
        sendobject(comm, i, 103, obj[ii], serialise, buff, maxbuff, serialisev, ptr); 
  }
  else
  {
    sendobject(comm, 0, 102, current, serialise, buff, maxbuff, serialisev, ptr);
    for(i=0;i&lt;Nprocs;i++)
      receiveobject(comm, 0, 103, obj[i], deserialise, buff, maxbuff, ptr);
  } 
  (*kill)(current, ptr);
  (*kill)(test, ptr);
  free(buff);

  return 0;
}

/*
  sort temperatures into ascending order
  Comparison function to pass to qsort
 */
static int comptemperatures(const void *e1, const void *e2)
{
    const TEMPINDEX *ti1 = e1;
    const TEMPINDEX *ti2 = e2;

    if(ti1-&gt;t &lt; ti2-&gt;t)
	return -1;
    if(ti1-&gt;t == ti2-&gt;t)
	return 0;
    return 1; 
}

/*
  temperatures are scrambled to avoid having to exchange too many
  objects. This unscrambles them and updates.
 */
static void getnewtemperatures(double *t, int *Nup, int *Ndown, int Nprocs)
{
  static double ttemp[MAXPROCS];
  static double tsort[MAXPROCS];
  static int index[MAXPROCS];
  int i, ii;
  double mint;

  for(i=0;i&lt;Nprocs;i++)
    ttemp[i] = t[i];
  for(i=0;i&lt;Nprocs;i++)
  {
    mint = DBL_MAX;
    for(ii=0;ii&lt;Nprocs;ii++)
      if(ttemp[ii] &lt; mint)
      {
        mint = ttemp[ii];
        index[i] = ii;
      }
    ttemp[index[i]] = DBL_MAX;
  }
  for(i=0;i&lt;Nprocs;i++)
  {
    tsort[i] = t[index[i]];
  }
  updatetemperatures(tsort, Nup, Ndown, Nprocs);
  for(i=0;i&lt;Nprocs;i++)
    t[index[i]] = tsort[i];
  
}

/*
  update the temperature set given current temperatures and number of walkers
  Params: t - the temperature (in / out)
          Nup - count of up walkers
          Ndown - count of down walkers
          Nprocs - number of processors / temperature intervals
  Notes: uses local gradient and diffusivity to update temperatures
         two extremal temperatures are held constant.
         temperatures must be in ascending order.
 */
static void updatetemperatures(double *t, int *Nup, int *Ndown, int Nprocs)
{
  static double etaT[MAXPROCS];
  static double f[MAXPROCS];
  static double idx[MAXPROCS];
  static double tnew[MAXPROCS];
  int i;
  double deltaT;
  double dfdT;
 
  for(i=0;i&lt;Nprocs;i++)
    f[i] = ((double) Ndown[i])/(Nup[i] + Ndown[i]);
 
  for(i=0;i&lt;Nprocs;i++)
      idx[i] = i;

  for(i=0;i&lt;Nprocs-1;i++)
  {
    deltaT = t[i+1] - t[i];
    dfdT = gradient(f, idx, Nprocs, i);
    if(dfdT &lt;= 0)
      dfdT = 0.001;
    etaT[i] = sqrt(dfdT);
  }
  sumtounity(etaT, Nprocs-1);

  for(i=1;i&lt;Nprocs-1;i++)
    tnew[i] = findres(etaT, t, Nprocs-1, i/(double) (Nprocs -1));
 
  for(i=1;i&lt;Nprocs-1;i++)
      t[i] = tnew[i];
  
}

/*
  get the local gradient at a point
  Params: y - the y values
          x - the x values
          N - total count of points
          i - point at which to take gradient
  Notes: estimate from 5 points or fewer if point is near an edge
 */
static double gradient(double *y, double *x, int N, int i)
{
  double sumxx = 0;
  double sumx = 0;
  double sumy = 0;
  double sumxy = 0;
  int Nactual = 0;
  int Npoint = 5;
  int istart, iend;
  int ip;

  istart = i - Npoint/2;
  if(istart &lt; 0)
    istart = 0;
  iend = i + Npoint/2;
  if(iend &gt;= N)
    iend = N-1; 

  for(ip=istart;ip&lt;=iend;ip++)
  {
    sumxy += x[ip] * y[ip];
    sumy += y[ip];
    sumxx += x[ip] * x[ip];
    sumx += x[ip];
    Nactual++; 
  }

  return (Nactual * sumxy - sumx * sumy)/(Nactual * sumxx - sumx * sumx);
  
}

/*
  find result - perform integration of step function
  Params: etaT - the step function giving ideal density
          t - the temperature set
          N - number of entries in eta (there is 1 more in t)
          p - total proportion of distribution trying to find
  Returns: temperature value which will give p
  Notes: etaT is normalised. Function simply counts over etaT
         as a step function and find the point at which proportion
         p of the distribution is covered, linearly interoplating for
         the last histogram entry.
 */
static double findres(double *etaT, double *t, int N, double p)
{
  double count = 0;
  double answer;
  int i =0;

  while(count + etaT[i] &lt; p &amp;&amp; i &lt; N)
    count += etaT[i++];
  answer = t[i] +  (t[i+1] - t[i]) * (p - count)/etaT[i];

  return answer;  
} 

/*
  Make an array sum to unity
  Params: x - the array (in / out)
          N - number of members
 */
static void sumtounity(double *x, int N)
{
  double total = 0;
  int i;

  for(i=0;i&lt;N;i++)
    total += x[i];
  for(i=0;i&lt;N;i++)
    x[i] /= total;
}


/*
  send an object over the MPI System (blocking)
  Params:
     comm - the MPI communicator group (eg MPI_COMM_WORLD)
     destid - identifier of destination processor
     tag - message tag
     obj - object to send
     serialise - function to serialise it
     buff - buffer to hold serial data
     capacity - maximum buffer capacity
     serialisev - function to serialise if max length not known
     ptr - arbitrary pointer to pass to sderialisation function
  Returns: 0 on success, -1 on fail 
 */
static int sendobject(
                 MPI_Comm comm,
                 int destid,
                 int tag, 
                 void *obj, 
                 int (*serialise)(void *obj, unsigned char *buff, int capacity, void *ptr),
                 unsigned char *buff,
                 int capacity,
                 void *(*serialisev)(void *obj, int *len, void *ptr),
                 void *ptr)
{
  int len;
  int err;

  if(buff)
  {
    len = (*serialise)(obj, buff, capacity, ptr);
    if(len &lt; 0)
      return -1;
    err = MPI_Send(buff, len, MPI_BYTE, destid, tag, comm);
    if(err &lt; 0)
      return -1; 
  }
  else
  {
    ptr = (*serialisev)(obj, &amp;len, ptr);
    if(!ptr)
      return -1;
    err =  MPI_Send(ptr, len, MPI_BYTE, destid, tag, comm);
    free(ptr);
    if(err &lt; 0)
      return -1;
  }

  return 0;
}

/*
  receive an object from the MPI system (blocking)
  Params:
     comm - the communicator (eg MPI_COMM_WORLD)
     srcid - id of sending processor
     tag - message tag
     obj - return for object to receive
     derserialise - function to sdeserialsie the object
     buff - buffer to use
     capacity - buffer capacity
     ptr - arbitrary pointer to pass to deserialisation function
  Returns: 0 on success, -1 on fail
  Notes:
    if the buffer is not sufficiently large the program will
    resort to allocating one dynamically.  
 */
static int receiveobject(
		   MPI_Comm comm,
                   int srcid,
                   int tag,
                   void *obj, 
                   int (*deserialise)(void *obj, unsigned char *buff, int len, void *ptr), 
                   unsigned char *buff,
                   int capacity,
                   void *ptr) 
{
  MPI_Status status;
  int err;
  void *dynbuff;
  int len;

  err = MPI_Probe(srcid, tag, comm, &amp;status);
  if(err &lt; 0)
    return -1;
  err = MPI_Get_count(&amp;status, MPI_BYTE, &amp;len);
  if(err &lt; 0)
    return -1;
  if(len &lt;= capacity)
  {
    err = MPI_Recv(buff, len, MPI_BYTE, srcid, tag, comm, &amp;status);
    if(err &lt; 0)
      return -1;
    err = (*deserialise)(obj, buff, len, ptr);
    if(err &lt; 0)
      return -1;
  }
  else
  {
    dynbuff = malloc(len);
    if(!dynbuff)
      return -1;
    err = MPI_Recv(dynbuff, len, MPI_BYTE, srcid, tag, comm, &amp;status);
    if(err &lt; 0)
      return -1;
    err = (*deserialise)(obj, buff, len, ptr);
    if(err &lt; 0)
      return -1;
    free(dynbuff);
  }

  return 0;
}


/*
  metropolis criteria for sa acceptance
 */
static int metrop(double current, double candidate, double t)
{
  double p;

  if(candidate &lt; current)
    return 1;
  else 
  {
    p = rand() / (RAND_MAX + 1.0);
    if( p &lt; exp( (current - candidate)/t ) )
      return 1;
    else
      return 0;
  } 
}

/*
  Metropolis criteria for replica exchange
  Params: sclow - the low score
          schigh - the high score
          tlow - low teperature
          thigh - high temperature
 */
static int replicametrop(double sclow, double schigh, double tlow, double thigh) 
{
  double p;

  if(schigh &lt;= sclow)
    return 1;
  else
  {
    p = rand() / (RAND_MAX + 1.0);
    if( p &lt; exp(-(1.0/tlow - 1.0/thigh)*(schigh-sclow)))
      return 1;
    else
      return 0;
  }
}


		</file>
		<file name="vector.c" type="text">
/*
  Basic vector functions
  All single--precision floating point
 */

#include &lt;math.h&gt;

#include &quot;vector.h&quot;

/*
  obtain the angle abc
 */
float vang(float *a, float *b, float *c)
{
  float ba[3];
  float bc[3];
  float len;

  vsub(ba, a, b);
  vsub(bc, c, b);
  len = vlen(ba) * vlen(bc);
  return acos(dot(ba,bc)/ len);
  
}
/*
  get the crossproduct of two vectors.
  Params: ans - return pointer for answer.
          pt1 - first vector
		  pt2 - second vector.
  Notes: crossproduct is at right angles to the two vectors.
*/
void crossproduct(float *ans, float *pt1, float *pt2)
{
  ans[0] = pt1[1] * pt2[2] - pt1[2] * pt2[1];
  ans[1] = pt1[2] * pt2[0] - pt1[0] * pt2[2];
  ans[2] = pt1[0] * pt2[1] - pt1[1] * pt2[0];
}

/*
  get the dotproduct of two vectors
  Params: a - vector 1
          b - vector 2
  Returns: dot product
  Notes = cosine of angle between if both vectors are normal 
 */

float dot(float *a, float *b)
{
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/*
  normalize a vector
  Params: v - vector to normalize
  Returns: 0 on success, -1 on zero vector
 */
int normalize(float *v)
{
  double len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
  if(len == 0)
    return -1;
  v[0] /= len;
  v[1] /= len;
  v[2] /= len;
  return 0;
}

/*
  subtract two vectors
  Params: res - result
          a - vector 1
          b - vector to subtract
 */
void vsub(float *res, float *a, float *b)
{
  res[0] = a[0] - b[0];
  res[1] = a[1] - b[1];
  res[2] = a[2] - b[2];
}

/*
  length of a vector
 */
float vlen(float *v)
{
  return sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
}

/*
  squared length of a vector
 */
float vlen2(float *v)
{
  return v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
}

/*
  distance between two points
 */
float vdist(float *a, float *b)
{
  return sqrt( (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]) + (a[2]-b[2])*(a[2]-b[2]));
}

/*
  squared distnace between two points.
 */
float vdist2(float *a, float *b)
{
  return (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]) + (a[2]-b[2])*(a[2]-b[2]);
}

		</file>
		<file name="distancetransform.c" type="binary">
<![CDATA[MOH"(*`B*@T3/]T3/]T3/]T3/]T3/]T3/]T3/]T3/*`B*@`2+MT2+MT2+MT2+
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
8EA2;A!7*[H`(@`B<E17=RY&(PLC"]I@"
]]>
		</file>
		<file name="mem.c" type="text">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


typedef struct blockheader
{
  union block *prev;
  int size;
  union block *nextfree;
  union block *prevfree;
} BLOCKHEADER;

typedef union block
{
  double aligner;
  BLOCKHEADER hdr;
} BLOCK;

typedef struct list_header
{
  struct list_header *next;
} LISTHEADER;

typedef struct
{
  int capacity;
  int size;
  LISTHEADER *mem;
  LISTHEADER *top;
} FIXEDALLOCATOR;

static double stack[1000];
static double *top = stack;

static BLOCK arena[1000];
static BLOCK *firstfree;

/*
  stack allocator.
  Params: size - size of memory to allocate
  Returns: pointer to allocataed space, or NULL on fail.
  Notes: deallocate by calls to sfree(), in reverse order. 
 */
void *salloc(int size)
{
  double *answer;

  size = (size + sizeof(double) -1)/sizeof(double);
  if(&amp;stack[1000] - top &lt; size)
    return 0;

  answer = top;
  top += size;

  return answer;
}

/*
  sfree - free a pointer allocated with salloc().
  Parasm: ptr - pointer to free
  Notes: calls to salloc() must be matched by acalls to sfree() in reverse
    order.
 */
void sfree(void *ptr)
{
  top = ptr;
}


/*
  initialisie our memory arena
 */
void initialise_malloc()
{
  arena[0].hdr.prev = 0;
  arena[0].hdr.nextfree = 0;
  arena[0].hdr.prevfree = 0;
  arena[0].hdr.size = sizeof(arena)/sizeof(BLOCK) - 1;

  firstfree = &amp;arena[0];
}

/*
  malloc implementation
 */
void *mymalloc(int size)
{
  BLOCK *ptr;
  
  size = (size + sizeof(BLOCK) - 1)/sizeof(BLOCK);
  ptr  = firstfree;

  while(ptr &amp;&amp; ptr-&gt;hdr.size &lt; size)
    ptr = ptr-&gt;hdr.nextfree;
  if(!ptr)
    return 0;

  if(ptr-&gt;hdr.size == size || ptr-&gt;hdr.size == size + 1)
  {
    if(ptr-&gt;hdr.prevfree)
      ptr-&gt;hdr.prevfree-&gt;hdr.nextfree = ptr-&gt;hdr.nextfree;
    if(ptr-&gt;hdr.nextfree)
      ptr-&gt;hdr.nextfree-&gt;hdr.prevfree = ptr-&gt;hdr.prevfree;
  }
  else
  {
      ptr[size+1].hdr.nextfree = ptr-&gt;hdr.nextfree;
      ptr[size+1].hdr.prevfree = ptr-&gt;hdr.prevfree;
      ptr[size+1].hdr.prev = ptr;
      ptr[size+1].hdr.size = ptr-&gt;hdr.size - 1 - size;
      ptr-&gt;hdr.nextfree = &amp;ptr[size+1];
      ptr-&gt;hdr.size = size;
      if(ptr-&gt;hdr.prevfree)
        ptr-&gt;hdr.prevfree-&gt;hdr.nextfree = &amp;ptr[size+1];
  }

  if(firstfree == ptr)
    firstfree = ptr-&gt;hdr.nextfree;

  ptr-&gt;hdr.nextfree = ptr;
  ptr-&gt;hdr.prevfree = ptr;
  return ptr + 1;
}

/*
  free implementation
 */
void myfree(void *ptr)
{
  BLOCK *blk;
 
  blk = ((BLOCK *)ptr) - 1;

  if(blk-&gt;hdr.prev &amp;&amp; blk-&gt;hdr.prev-&gt;hdr.nextfree == blk-&gt;hdr.prev)
  {
    blk-&gt;hdr.prev-&gt;hdr.size += blk-&gt;hdr.size + 1;
    blk = blk-&gt;hdr.prev;
  }
  if(&amp;blk[blk-&gt;hdr.size+1] != &amp;arena[1000] &amp;&amp; blk[blk-&gt;hdr.size+1].hdr.prevfree != &amp;blk[blk-&gt;hdr.size+1])
  {
    if(blk[blk-&gt;hdr.size+1].hdr.prevfree)
      blk[blk-&gt;hdr.size+1].hdr.prevfree-&gt;hdr.nextfree = blk;
    blk-&gt;hdr.nextfree = blk[blk-&gt;hdr.size+1].hdr.nextfree;
    blk-&gt;hdr.prevfree = blk[blk-&gt;hdr.size+1].hdr.prevfree;
    blk-&gt;hdr.size += blk[blk-&gt;hdr.size+1].hdr.size + 1;
  }  
  if(blk-&gt;hdr.nextfree == blk)
  { 
    blk-&gt;hdr.prevfree = 0;
    blk-&gt;hdr.nextfree = firstfree;
    if(firstfree)
      firstfree-&gt;hdr.prevfree = blk;
    firstfree = blk;
  }
}

/*
  create a fixed allocation scheme
  Params: capacity - number of blocks to allocate
          size - the size of each block
  Returns: an allocation scheme to be used for allocating blocks
           of fixed size.
 */
FIXEDALLOCATOR *fixedallocator(int capacity, int size)
{
  FIXEDALLOCATOR *fa;
  int i;

  fa = malloc(sizeof(FIXEDALLOCATOR));
  if(!fa)
    return 0;

  fa-&gt;capacity = capacity;
  fa-&gt;size = size;

  size = (size + sizeof(LISTHEADER) - 1)/sizeof(LISTHEADER);

  fa-&gt;mem = malloc(capacity * size * sizeof(LISTHEADER));
  if(!fa-&gt;mem)
  {
    free(fa);
    return 0;
  }


  for(i=0;i&lt; (capacity - 1) * size; i += size)
     fa-&gt;mem[i].next = &amp;fa-&gt;mem[i+size];
  fa-&gt;mem[i].next = 0;
  
  fa-&gt;top = fa-&gt;mem;
  
  return fa;  
}

/*
  destroy the fixed memory allocation scheme
  Params: fa - scheme to destroy
  Notes: invalidates all memory allocated with that scheme.
 */
void killfixedallocator(FIXEDALLOCATOR *fa)
{
  free(fa-&gt;mem);
  free(fa);
}

/*
  allocate a fixed-size memory block
  Params: fa - the fixed allocation scheme
  Notes: free the block with fixedfree.
 */
void *fixedallocate(FIXEDALLOCATOR *fa)
{
  LISTHEADER *answer = fa-&gt;top;
  if(answer)
    fa-&gt;top = answer-&gt;next;
  return answer;
}

/*
  free a fixed-size block of memory
  Params: fa - the fixed allocation scheme
          ptr - pointer to free
  Notes: ptr must be allocated with fixedallocate()
 */
void fixedfree(FIXEDALLOCATOR *fa, void *ptr)
{
  LISTHEADER *lh = ptr;
  lh-&gt;next = fa-&gt;top;
  fa-&gt;top = lh;
}

		</file>
		<file name="replicafeedback.h" type="text">
#ifndef replicafeedback_h
#define replicafeedback_h

int replicafeedback(void **obj, 
           void * (*clone)(void *obj, void *ptr),
           void (*kill)(void *obj, void *ptr), 
           int  (*copy)(void *dest, void *src, void *ptr),
	   int (*deserialise)(void *obj, unsigned char *buff, int len, void *ptr),
	   int (*serialise)(void *obj, unsigned char *buff, int capacity, void *ptr),
	   void * (*serialisev)(void *obj, int *len, void *ptr),
           double (*score) (void *obj, void *ptr),
           void (*mutate) (void *obj, void *ptr),
	   void (*step)(void *obj, double score, int newconf, double temperature, void *ptr),
	 
           int maxbuff,
	   double lowtemp,
	   double hightemp,
	   int Nequil,
	   int Nswaps,
	   int Nsteps,
	   int rootlowest, 
           MPI_Comm comm, 
	   void *ptr);

#endif

		</file>
		<file name="rmsd.h" type="text">
#ifndef rmsd_h
#define rmsd_h

double rmsd(float *v1, float *v2, int N, float *mtx);

#endif

		</file>
		<file name="options.h" type="text">
#ifndef options_h
#define options_h

typedef struct
{
  int argc;             /* number of arguments */
  char **argv;          /* argument list */
  char *flags;          /* set of allowed one char flags */
  int *used;            /* flag for each argument read */
  int firsttouched;     /* set if the first arguement interpreted as flags */
  int firstflag;        /* set if the first arguement can be flags */
  int *firstused;       /* set if each character of first arguement read */
  int error;            /* set if the parser encounters an error */
  char errstr[1024];    /* parser error text */
} OPTIONS;

OPTIONS *options(int argc, char **argv, char *flags);
void killoptions(OPTIONS *opt);
int opt_get(OPTIONS *opt, char *name, char *fmt, ...);
int opt_error(OPTIONS *opt, FILE *fp);
int opt_Nargs(OPTIONS *opt);
char *opt_arg(OPTIONS *opt, int index);

#endif

		</file>
		<file name="medialaxistransform.c" type="binary">
<![CDATA[MOHB"@`"(M5&9I%&;@$&>I-'(T)78N-G9O)7;@$F;D!"=HEF;@86=N-&=I]F;
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
M@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+*D`,L`",
ML`",L`2,L`",L`",L`2,L`2,L`",L`2,L`2,L`2,L`",L`",L`2,L`2,LH0"
MPP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(
MPPB")`#+@`#+@$#+@$#+@$#+@`#+@$#+@$#+@`#+@`#+@$#+@$#+@`#+@`#+
M@$#+@$#+*D`,L`",L`",L`",L`",L`",L`",L`",L`",L`",L`",L`",L`",
ML`",L`",L`",LH0"PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(QP"(QP"(QP"(
MQP"(PP"(PP"(QP"(QPB")`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+
M@`#+@`#+@`#+@`#+@`#+@`#+*D`,L`",L`",L`",L`",L`",L`",L`",L`",
ML`",L`2,L`2,L`",L`",L`2,L`2,LH0"PP"(PP"(PP"(PP"(PP"(PP"(PP"(
MPP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PPB")`#+@`#+@`#+@`#+@`#+@`#+
M@`#+@`#+@$#+@$#+@$#+@$#+@`#+@`#+@$#+@$#+*D`,L`",L`",L`",L`",
ML`",L`",L`",L`",L`",L`",L`",L`",L`",L`",L`",LH0"QP"(PP"(QP"(
MQP"(QP"(PP"(QP"(QP"(QP"(QP"(QP"(QP"(QP"(QP"(QP"(QPB")`#+@`#+
M@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+*D0,
ML`",L`",L`",L`",L`",L`",L`",L`2,L`2,L`2,L`2,L`",L`",L`2,L`2,
MLH0"PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(
MPP"(PPB")$#+@`#+@$#+@$#+@$#+@`#+@$#+@$#+@$#+@$#+@$#+@$#+@$#+
M@$#+@$#+@$#+*D`,L`",L`",L`",L`",L`",L`",L`",L`",L`",L`",L`",
ML`",L`",L`",L`",LH0"PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(PP"(
MPP"(PP"(PP"(PP"(PP"(PPB")`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+@`#+
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
5@@'(K`2,=!B.@(V;R169RMC"]I@"
]]>
		</file>
		<file name="pdb.c" type="text">
/*
  general-purpose PDB file loader
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;limits.h&gt;
#include &lt;assert.h&gt;

#define HYDROGEN 1
#define CARBON 6
#define NITROGEN 7
#define OXYGEN 8
#define PHOSPHORUS 15
#define SULPHUR 16

typedef struct
{
  char symbol;
  char hetname[32];
  int hetid;
  int minatom;
  int maxatom;
  char secondary;
} PDB_RESIDUE;

typedef struct
{
  int N;
  PDB_RESIDUE *seq;
  char id[8];
  int minatom;
  int maxatom;
  int base;
} PDB_CHAIN;

typedef struct
{
  float pos[3];
  char id[5];
  int element;
} PDB_ATOM;

typedef struct
{
    char *fullname;
    char name3[4];
    int Natoms;
    int Nbonds;
    char **atomnames;
    int *bonda;
    int *bondb;
    int minatom;
    int maxatom;
} PDB_HETEROGEN;

typedef struct
{
  char classification[64];
  char date[10];
  char id[8];
  char *title;
  int Nchains;
  PDB_CHAIN *chain;
  PDB_ATOM *atoms;
  PDB_HETEROGEN *hets;
  int Nhets;
  int Natoms;
  int atomspace;
  int termhack;
  int secondarybad;
} PDB;

PDB *loadpdb(const char *path, int *err);
PDB *floadpdb(FILE *fp, int *err);
void killpdb(PDB *pdb);
int pdb_chainindex(PDB *pdb, char *id);
int pdb_getatom(PDB *pdb, int chain, int residue, char *atom, float *x, float *y, float *z);
int pdb_getsequence(PDB *pdb, int chain, char *out);

static PDB *pdb(void);
static int parseline(PDB *pdb, char *line);
static int parseheader(PDB *pdb, char *line);
static int parsetitle(PDB *pdb, char *line);
static int parseseqres(PDB *pdb, char *line);
static int parseatom(PDB *pdb, char *line);
static int parsehet(PDB *pdb, char *line);
static int parsehetatm(PDB *pdb, char *line);
static int parsehetname(PDB *pdb, char *line);
static int parsehelix(PDB *pdb, char *line);
static int parsesheet(PDB *pdb, char *line);
static int parseter(PDB *pdb, char *line);
static int parseendmdl(PDB *pdb, char *line);
static int allocateatom(PDB *pdb);
static int addchain(PDB *pdb, char *id, int len);
static int addheterogen(PDB *pdb, char *chain, int index, char *name, int Natoms);
static void addatomtoresidue(PDB *pdb, char *residue, char *chain, int resno, int atomno);
static char three2one(char *code3);
static int symboltoelementno(char *symbol);
static void getfield(char *ret, char *line, int col, int len);
static void trim(char *str);

/*
  load a PDB file.
  Params: path - file path
          err - return pointer for error code
  Returns: pointer to PDB structure on success, 0 on fail 
*/
PDB *loadpdb(const char *path, int *err)
{
  FILE *fp;
  PDB *answer;

  fp = fopen(path, &quot;r&quot;);
  if(!fp)
  {
   if(err)
     *err = -1;
   return 0;
  }

  answer = floadpdb(fp, err);
  fclose(fp);

  return answer;
}

/*
  load a PDB from opened file
  Params: fp - pointer to file opened for reading
          err - return pointer for error
  Returns: pointer to PDB structure on success, 0 on fail
*/
PDB *floadpdb(FILE *fp, int *err)
{
  PDB *answer;
  char line[82];

  answer = pdb();
  if(!answer)
  {
    if(err)
      *err = -2;
    return 0;
  }

  while( fgets(line, 82, fp) )
  {
    if(!strchr(line, &apos;\n&apos;))
    {
      killpdb(answer);
      if(err)
        *err = -3;
      return 0;
    }
    if(parseline(answer, line) &lt; 0)
    {
      if(err)
        *err = -3;
      killpdb(answer);
      return 0;
    }
  }

  return answer;
}

/*
  destroy the PDB object
  Parmas: pdb - object to destroy
*/
void killpdb(PDB *pdb)
{
  int i;
  if(pdb)
  {
    for(i=0;i&lt;pdb-&gt;Nchains;i++)
      free(pdb-&gt;chain[i].seq);
    free(pdb-&gt;chain);
    free(pdb);
  }
}

int pdb_getNchains(PDB *pdb)
{
  return pdb-&gt;Nchains;
}

int pdb_getchainlen(PDB *pdb, int chain)
{
  assert(chain &gt;= 0 &amp;&amp; chain &lt; pdb-&gt;Nchains);
  return pdb-&gt;chain[chain].N;
}

/*
  get the index of a chain by identifer
  Params: pdb - pdb object
          id - ASCII id (eg &quot;B&quot;), NUL-termianted
  Returns: Index of chain, -1 if none. 
*/
int pdb_chainindex(PDB *pdb, char *id)
{
  int i;

  for(i=0;i&lt;pdb-&gt;Nchains;i++)
    if(!strcmp(pdb-&gt;chain[i].id, id))
      return i;
  return -1;
}

/*
  get the pdb index of a resiude
  Params: pdb - pointer to pdb object
          chain - chain index (0-based)
          resiude - residue internal index (0-based)
  Returns: the idex used by pdb for that resiude. May be negative.
 */
int pdb_resid(PDB *pdb, int chain, int residue)
{
  assert(chain &gt;= 0 &amp;&amp; chain &lt; pdb-&gt;Nchains);
  assert(residue &gt;= 0 &amp;&amp; residue &lt; pdb-&gt;chain[chain].N);
  return residue + pdb-&gt;chain[chain].base +1;
} 

/*
  get atom Catesian coordinates by name
  Parmas: pdb - pointer to pdb object
          chain - chain index (0 based)
          residue - residue index (0 based)
          atom - name of atom, eg &quot;CA&quot;
          x - return pointer for x co-ord
          y - return pointer for y co-ord
          z - return pointer for z co-ord
*/
int pdb_getatom(PDB *pdb, int chain, int residue, char *atom, float *x, float *y, float *z)
{
  int i;

  assert(chain &gt;= 0 &amp;&amp; chain &lt; pdb-&gt;Nchains);
  assert(residue &gt;= 0 &amp;&amp; residue &lt; pdb-&gt;chain[chain].N);
 
  for(i=pdb-&gt;chain[chain].seq[residue].minatom; i &lt;= pdb-&gt;chain[chain].seq[residue].maxatom;i++)
  {
    if(!strcmp(pdb-&gt;atoms[i].id, atom))
    {
      *x = pdb-&gt;atoms[i].pos[0];
      *y = pdb-&gt;atoms[i].pos[1];
      *z = pdb-&gt;atoms[i].pos[2];
      return pdb-&gt;atoms[i].element;
    }
  }

  return 0;
}

/*
  get sequence of PDB file
  Params: pdb - pdb object
          chain - chain index (0 based)
          out - return pointer for chain
  Returns: 0
  Notes: chain NUL-terminated
         ? means residue not included in PDB file
         X means residue of unknown/unconventional type
*/
int pdb_getsequence(PDB *pdb, int chain, char *out)
{
  int i;

  assert(chain &gt;= 0 &amp;&amp; chain &lt; pdb-&gt;Nchains);
  for(i=0;i&lt;pdb-&gt;chain[chain].N;i++)
    out[i] = pdb-&gt;chain[chain].seq[i].symbol;
  out[i] =0;

  return 0;
}

/*
  get secondary sequence of a PDB file
  Params: pdb - pdb object
          chain - chain index (0 based)
          out - return pointer for secondary structure
  Returns: 0 on success, -1 on fail
  Notes: sequence NUL-terminated
         &apos;A&apos; - alpha helix, &apos;B&apos; - beta strand &apos;-&apos; other
         Some PDB files have bad secondary structure records
         which are impossible to parse. Return -1 in that case
 */
int pdb_getsecondary(PDB *pdb, int chain, char *out)
{
    int i;

    assert(chain &gt;= 0 &amp;&amp; chain &lt; pdb-&gt;Nchains);
    if(pdb-&gt;secondarybad)
    {
	for(i=0;i&lt;pdb-&gt;chain[chain].N;i++)
	    out[i] = &apos;?&apos;;
	return -1;
    }
    for(i=0;i&lt;pdb-&gt;chain[chain].N;i++)
	out[i] = pdb-&gt;chain[chain].seq[i].secondary;
    out[i] =0;

    return 0;
} 

/*
  create a default pdb object
*/
static PDB *pdb(void)
{
  PDB *answer;

  answer = malloc(sizeof(PDB));
  if(!answer)
    return 0;
  answer-&gt;title = 0;
  strcpy(answer-&gt;classification, &quot;&quot;);
  strcpy(answer-&gt;id, &quot;&quot;);
  strcpy(answer-&gt;date, &quot;&quot;);
  answer-&gt;Nchains = 0;
  answer-&gt;chain = 0;
  answer-&gt;Natoms = 0;
  answer-&gt;atoms = 0;
  answer-&gt;atomspace = 0;
  answer-&gt;termhack = 0;
  answer-&gt;secondarybad = 0;

  return answer;
}

/*
  parse a line of the PDB file
  Params: pdb - pointer to object
          line - pointer to line
  Returns: 0 on success, negative on error
*/
static int parseline(PDB *pdb, char *line)
{
  if(pdb-&gt;termhack)
    return 0;

  if(!strncmp(line, &quot;SEQRES&quot;, 6))
    return parseseqres(pdb, line);
  if(!strncmp(line, &quot;HELIX&quot;, 5))
    return parsehelix(pdb, line);
  if(!strncmp(line, &quot;SHEET&quot;, 5))
    return parsesheet(pdb, line);
  else if(!strncmp(line, &quot;ATOM&quot;, 4))
    return parseatom(pdb, line);
 /*
  else if(!strncmp(line, &quot;HETATM&quot;, 6))
    return parsehetatom(pdb, line);
  else if(!strncmp(line,&quot;ANISOU&quot;, 6))
    return parseanisou(pdb, line)
  else if(!strnmcp(line, &quot;CRYST1&quot;, 6))
    return parsecryst1(pdb, line);
  else if(!strnmcp(line, &quot;COMPND&quot;, 6))
    return parsecompnd(pdb, line);
  else if(!strncmp(line, &quot;MODEL&quot;, 5))
    return parsemodel(pdb, line);
  else if(!strncmp(line, &quot;ENDMDL&quot;, 6))
    return parseendmdl(pdb, line);
  */
  else if(!strncmp(line, &quot;TER&quot;, 3))
    return parseter(pdb, line);
  else if(!strncmp(line, &quot;ENDMDL&quot;, 6))
   return parseendmdl(pdb, line);
  else if(!strncmp(line, &quot;HEADER&quot;, 6))
    return parseheader(pdb, line);
  else if(!strncmp(line,  &quot;TITLE&quot;, 5))
    return parsetitle(pdb, line);
/*
  else if(!strncmp(line, &quot;REMARK&quot;, 6))
    return parseremark(pdb, line);
  */
  return 0;
}

/*
  parse the header information
  Params: pdb - pdb object
          line - pointer to line
  Returns: 0 on success, negative on error
 */
static int parseheader(PDB *pdb, char *line)
{
    if(strncmp(line, &quot;HEADER&quot;, 6))
	return -1;
    getfield(pdb-&gt;classification, line, 10, 40);
    getfield(pdb-&gt;date, line, 50, 9);
    getfield(pdb-&gt;id, line, 62, 4); 
 
    return 0;
}

/*
  parse the title information
  Params: pdb - pdb object
          line - line to parse
  Returns: 0 on success, negative on error  
 */
static int parsetitle(PDB *pdb, char *line)
{
    int len;
    char buff[80];
    char *temp;

    if(strncmp(line, &quot;TITLE&quot;, 5))
	return -1;

    getfield(buff, line, 10, 60);
    trim(buff);
    if(!pdb-&gt;title)
    {
	pdb-&gt;title = malloc(strlen(buff) + 1);
        if(!pdb-&gt;title)
	    return -2;
        strcpy(pdb-&gt;title, buff);
    }
    else
    {
	len = strlen(pdb-&gt;title) + strlen(buff) + 2;

        temp =realloc(pdb-&gt;title, len);
        if(!temp)
	  return -2;
        pdb-&gt;title = temp;
        strcat(pdb-&gt;title, &quot; &quot;);
	strcat(pdb-&gt;title, buff);
    }
 
    return 0;
}

/*
  parse the SEQRES line (residue sequence)
  Params: pdb - pointer to object
          line - pointer to line
  Returns: 0 on success, negative on error
*/
static int parseseqres(PDB *pdb, char *line)
{
  char aa;
  int i;
  int N;
  int recno;
  int chainid;
  int pos;
  char type[82];
  char chain[82];

  
  if( sscanf(line, &quot;%s %d %s %d &quot;, type, &amp;recno, chain, &amp;N) != 4)
  {
      strcpy(chain, &quot;&quot;);
      if( sscanf(line, &quot;%s %d %d &quot;, type, &amp;recno, &amp;N) != 3 )
        return -1;
  }

  if(strncmp(line, &quot;SEQRES&quot;, 6))
    return -1;
  if(recno == 1)
  {
    if( addchain(pdb, chain, N) &lt; 0 )
      return -2;
    i = 0;
  }
  else
   i = 13 * (recno -1);
  chainid = pdb_chainindex(pdb, chain);
  pos = 19;
  while(i &lt; N &amp;&amp; i &lt; (13 * recno - 1) + 13)
  {
    aa = three2one(&amp;line[pos]);
    if(aa)
      pdb-&gt;chain[chainid].seq[i].symbol = aa;
    else
    {
      pdb-&gt;chain[chainid].seq[i].symbol = &apos;X&apos;;
      strncpy(pdb-&gt;chain[chainid].seq[i].hetname, &amp;line[pos], 3);
      pdb-&gt;chain[chainid].seq[i].hetname[3] = 0;
    }
    pos += 4;
    i++;
  } 

  return 0;
  
}

/*
  parse an ATOM line
  Params: pdb - pointer to object
          line - pointer to line
 .Returns: 0 on success, negative on error
*/
static int parseatom(PDB *pdb, char *line)
{
  char id[6];
  char residue[82];
  char chain[82];
  char elsym[4];
  char icode; 
  int resno;
  float x, y, z;
  int i;
  char *end;


  if(strncmp(line, &quot;ATOM&quot;, 4))
    return -1;
 
  i = (int) strtol(&amp;line[4], &amp;end, 10);
  if(end == &amp;line[4])
    i = pdb-&gt;Natoms;

  getfield(id, line, 12, 4);
  trim(id);
  getfield(residue, line, 17, 3);
  trim(residue);

  chain[0] = line[21];
  chain[1] = 0;
  if(chain[0] == &apos; &apos;)
      chain[0] = 0;
 
  resno = (int) strtol(&amp;line[22], &amp;end, 10);
  icode = line[26];

  if(sscanf(&amp;line[30], &quot;%f %f %f &quot;, &amp;x, &amp;y, &amp;z) != 3)
      return -1;
  
  elsym[0] = line[13];
  elsym[1] = 0;

  if(i &lt; 1)
    i = 1;
  while(i &lt; pdb-&gt;atomspace &amp;&amp; pdb-&gt;atoms[i-1].element != 0)
    i++;
  
  while(i &gt;= pdb-&gt;atomspace)
  {
    if(allocateatom(pdb) == -1)
      return -2;
  }
 
  strcpy(pdb-&gt;atoms[ i-1 ].id, id);
  pdb-&gt;atoms[ i-1 ].pos[0] = x;
  pdb-&gt;atoms[ i-1 ].pos[1] = y;
  pdb-&gt;atoms[ i-1 ].pos[2] = z;
  pdb-&gt;atoms[ i-1 ].element = symboltoelementno(elsym);
  if(pdb-&gt;Natoms &lt; i)
    pdb-&gt;Natoms = i;
  addatomtoresidue(pdb, residue, chain, resno -1, i-1);

  return 0;
}

/*
  parse a HETATM line
  Params: pdb - pointer to object
          line - pointer to line
 .Returns: 0 on success, negative on error
*/
static int parsehetatm(PDB *pdb, char *line)
{
  char id[82];
  char residue[82];
  char chain[82];
  char elsym[4];
  char icode; 
  int resno;
  float x, y, z;
  int i;
  char *end;
  char idfield[6];
  int element;

  if(strncmp(line, &quot;HETATM&quot;, 6))
    return -1;
 
  i = (int) strtol(&amp;line[4], &amp;end, 10);
  idfield[0] = line[12];
  idfield[1] = line[13];
  idfield[2] = line[14];
  idfield[3] = line[15];
  idfield[4] = 0;
  sscanf(idfield, &quot;%s&quot;, id);

  residue[0] = line[17];
  residue[1] = line[18];
  residue[2] = line[19];
  residue[3] = 0;

  chain[0] = line[21];
  chain[1] = 0;
  if(chain[0] == &apos; &apos;)
      chain[0] = 0;

  
  resno = (int) strtol(&amp;line[22], &amp;end, 10);
  icode = line[26];

  if(sscanf(&amp;line[30], &quot;%f %f %f &quot;, &amp;x, &amp;y, &amp;z) != 3)
      return -1;
  
  /* ignore water for now */
  if(!strcmp(residue, &quot;HOH&quot;))
  {
      return 0;
  }
  getfield(elsym, line, 76, 2);
  trim(elsym);
  element = symboltoelementno(elsym);
  if(element == 0)
  {
      elsym[0] = line[13];
      elsym[1] = 0;
      element = symboltoelementno(elsym);
  } 

  while(i &gt;= pdb-&gt;atomspace)
  {
    if(allocateatom(pdb) == -1)
      return -2;
  }
  strcpy(pdb-&gt;atoms[ i-1 ].id, id);
  pdb-&gt;atoms[ i-1 ].pos[0] = x;
  pdb-&gt;atoms[ i-1 ].pos[1] = y;
  pdb-&gt;atoms[ i-1 ].pos[2] = z;
  pdb-&gt;atoms[ i-1 ].element = symboltoelementno(elsym);
  if(pdb-&gt;Natoms &lt; i)
    pdb-&gt;Natoms = i;
  addatomtoresidue(pdb, residue, chain, resno -1, i-1);

  return 0;
}

static int parsehet(PDB *pdb, char *line)
{
    char name3[4];
    char chain[2];
    char insertioncode;
    int index;
    int Natoms;
    char *dummy;
    char buff[32];
    char text[42];

    getfield(name3, line, 7, 3);
    getfield(chain, line, 12, 1);
    getfield(buff,line, 13, 4);
    index = strtol(buff, &amp;dummy, 10);
    insertioncode = line[17];
    getfield(buff, line, 20, 5);
    Natoms = strtol(buff, &amp;dummy, 10);
    getfield(text, line, 30, 40);

    addheterogen(pdb, chain, index, name3, Natoms);

    return 0; 
}

static int parsehetname(PDB *pdb, char *line)
{
    char fullname[60];
    char id[3];
    int i;
    int len;
    char *temp;

    getfield(id, line, 11, 3);
    getfield(fullname, line, 15, 55);
    trim(fullname);
 
    for(i=0;i&lt;pdb-&gt;Nhets;i++)
	if(!strcmp(pdb-&gt;hets[i].name3, id))
        {
	    if(pdb-&gt;hets[i].fullname)
            {
		len = strlen(pdb-&gt;hets[i].fullname) + strlen(fullname) + 2;
		temp = realloc(pdb-&gt;hets[i].fullname, len);
                if(!temp)
		    return -1;
                pdb-&gt;hets[i].fullname = temp;
                strcat(pdb-&gt;hets[i].fullname, &quot; &quot;);
                strcat(pdb-&gt;hets[i].fullname, fullname);
	    }
	    else
            {
		pdb-&gt;hets[i].fullname = malloc(strlen(fullname) + 1);
                if(!pdb-&gt;hets[i].fullname)
		    return -1;
                strcpy(pdb-&gt;hets[i].fullname, fullname);
            }
 
        }
}


/*
COLUMNS        DATA TYPE       FIELD           DEFINITION
---------------------------------------------------------------------------------
 1 -  6        Record name     &quot;HELIX &quot;

 8 - 10        Integer         serNum          Serial number of the helix.
                                               This starts at 1 and increases
                                               incrementally.

12 - 14        LString(3)      helixID         Helix identifier.  In addition
                                               to a serial number, each helix is
                                               given an alphanumeric character
                                               helix identifier.

16 - 18        Residue name    initResName     Name of the initial residue.

20             Character       initChainID     Chain identifier for the chain
                                               containing this helix.

22 - 25        Integer         initSeqNum      Sequence number of the initial
                                               residue.

26             AChar           initICode       Insertion code of the initial
                                               residue.

28 - 30        Residue name    endResName      Name of the terminal residue of
                                               the helix.

32             Character       endChainID      Chain identifier for the chain
                                               containing this helix.

34 - 37        Integer         endSeqNum       Sequence number of the terminal
                                               residue.

38             AChar           endICode        Insertion code of the terminal
                                               residue.

39 - 40        Integer         helixClass           Helix class (see below).

41 - 70        String          comment         Comment about this helix.

72 - 76        Integer         length          Length of this helix.

*/

static int parsehelix(PDB *pdb, char *line)
{
    int sernum;
    char id[4];
    char initresname[4];
    char endresname[4];
    char chainid[2];
    int initres;
    int endres;
    char endchainid[2];
    char initicode;
    char endicode;
    int helixclass;
    char *end;
    char startaa;
    char endaa;
    int chain;
    int i;
    
    sernum = (int) strtol(line+7, &amp;end, 10);
    getfield(id, line, 11, 3);
    getfield(initresname, line, 15, 3);
    chainid[0] = line[19];
    chainid[1] = 0;
    initres = (int) strtol(line + 21, &amp;end, 10);
    initicode = line[25];
    getfield(endresname, line, 27, 3);
    endchainid[0] = line[31];
    endchainid[1] = 0;
    endres = (int) strtol(line + 33, &amp;end, 10);
    endicode = line[37];
    helixclass = (int) strtol(line + 38, &amp;end, 10);

    if(chainid[0] == &apos; &apos;)
	chainid[0] = 0;
    if(endchainid[0] == &apos; &apos;)
	endchainid[0] = 0;
    /* throw out any helices with 2 chains */
    if(chainid[0] != endchainid[0])
    {
	pdb-&gt;secondarybad = 1;
	return 0;
    }
    chain = pdb_chainindex(pdb, chainid);
    if(chain == -1)
	return -1;
    /* chuck out out of range helices */
    if(initres &gt; pdb-&gt;chain[chain].N)
	initres %= 1000;
    if(initres &lt; 1 || initres &gt; pdb-&gt;chain[chain].N)
    {
	pdb-&gt;secondarybad = 1;
	return 0;
    }
    if(endres &gt; pdb-&gt;chain[chain].N)
        endres %= 1000;
    if(endres &lt; 1 || endres &gt; pdb-&gt;chain[chain].N)
    {
	pdb-&gt;secondarybad = 1;
	return 0;
    }
    /* chuck out non-matching residues */

    startaa = three2one(initresname);
    if(startaa != 0 &amp;&amp; pdb-&gt;chain[chain].seq[initres-1].symbol != startaa)
    {
        pdb-&gt;secondarybad = 1;
	return 0;
    }
    endaa = three2one(endresname);
    if(endaa != 0 &amp;&amp; pdb-&gt;chain[chain].seq[endres-1].symbol != endaa)
    {
	pdb-&gt;secondarybad = 1;
	return 0;
    }

    for(i=initres-1;i&lt;=endres-1;i++)
	pdb-&gt;chain[chain].seq[i].secondary = &apos;A&apos;;

    return 0;
}

/*
COLUMNS        DATA TYPE       FIELD           DEFINITION
----------------------------------------------------------------------------------
 1 -  6        Record name     &quot;SHEET &quot;

 8 - 10        Integer         strand          Strand number which starts at 1 for
                                               each strand within a sheet and
                                               increases by one.

12 - 14        LString(3)      sheetID         Sheet identifier.

15 - 16        Integer         numStrands      Number of strands in sheet.

18 - 20        Residue name    initResName     Residue name of initial residue.

22             Character       initChainID     Chain identifier of initial residue
                                               in strand.

23 - 26        Integer         initSeqNum      Sequence number of initial residue
                                               in strand.

27             AChar           initICode       Insertion code of initial residue
                                               in strand.

29 - 31        Residue name    endResName      Residue name of terminal residue.

33             Character       endChainID      Chain identifier of terminal
                                               residue.

34 - 37        Integer         endSeqNum       Sequence number of terminal residue.

38             AChar           endICode        Insertion code of terminal residue.

39 - 40        Integer         sense           Sense of strand with respect to
                                               previous strand in the sheet. 0
                                               if first strand, 1 if parallel,
                                               -1 if anti-parallel.

42 - 45        Atom            curAtom         Registration. Atom name in current
                                               strand.

46 - 48        Residue name    curResName      Registration. Residue name in
                                               current strand.

50             Character       curChainId      Registration. Chain identifier in
                                               current strand.

51 - 54        Integer         curResSeq       Registration. Residue sequence
                                               number in current strand.

55             AChar           curICode        Registration. Insertion code in
                                               current strand.

57 - 60        Atom            prevAtom        Registration. Atom name in
                                               previous strand.

61 - 63        Residue name    prevResName     Registration. Residue name in
                                               previous strand.

65             Character       prevChainId     Registration. Chain identifier in
                                               previous strand.

66 - 69        Integer         prevResSeq      Registration. Residue sequence
                                               number in previous strand.

70             AChar           prevICode       Registration. Insertion code in
                                               previous strand.
*/

static int parsesheet(PDB *pdb, char *line)
{
    char sheetid[4];
    int numstrands;
    char initresname[4];
    char initchainid[2];
    int initres;
    char initicode;
    char endresname[4];
    char endchainid[2];
    char endicode;
    int endres;
    char *end;
    char startaa;
    char endaa;
    int chain;
    int i;

    getfield(sheetid, line, 7, 3);
    numstrands = (int) strtol(line+11,&amp;end, 10); 
    getfield(initresname, line, 17, 3);
    initchainid[0] = line[21];
    initchainid[1] = 0; 
    initres = (int) strtol(line+22, &amp;end, 10);
    initicode = line[26];
    getfield(endresname, line, 28, 3);
    endchainid[0] = line[32];
    endchainid[1] = 0;
    endres = strtol(line +33, &amp;end, 10);
    endicode = line[37];

    if(initchainid[0] == &apos; &apos;)
	initchainid[0] = 0;
    if(endchainid[0] == &apos; &apos;)
	endchainid[0] = 0;
    /* throw out any strands that cross two chains */
    if(initchainid[0] != endchainid[0])
    {
        pdb-&gt;secondarybad = 1;
	return 0; 
    }
    chain = pdb_chainindex(pdb, initchainid);
    if(chain == -1)
	return -1;
    /* chuck out out of range helices */
    if(initres &gt; pdb-&gt;chain[chain].N)
	initres %= 1000;
    if(initres &lt; 1 || initres &gt; pdb-&gt;chain[chain].N)
    {
        pdb-&gt;secondarybad = 1;
	return 0;
    }
    if(endres &gt; pdb-&gt;chain[chain].N)
	endres %= 1000;
    if(endres &lt; 1 || endres &gt; pdb-&gt;chain[chain].N)
    {
        pdb-&gt;secondarybad = 1;
	return 0;
    }
    /* chuck out non-matching residues */
    startaa = three2one(initresname);
    if(startaa != 0 &amp;&amp; pdb-&gt;chain[chain].seq[initres-1].symbol != startaa)
    {
        pdb-&gt;secondarybad = 1;
	return 0;
    }
    endaa = three2one(endresname);
    if(endaa != 0 &amp;&amp; pdb-&gt;chain[chain].seq[endres-1].symbol != endaa)
    {
        pdb-&gt;secondarybad = 1;
	return 0;
    }

    for(i=initres-1;i&lt;=endres-1;i++)
	pdb-&gt;chain[chain].seq[i].secondary = &apos;B&apos;;
    
    return 0;     
}

static int parseter(PDB *pdb, char *line)
{
  return 0;
}

static int parseendmdl(PDB *pdb, char *line)
{
  pdb-&gt;termhack = 1;
  return 0;
}

int neatenup(PDB *pdb)
{
    return 0;
}

/*
  allocate more memory for atoms
  Params: pdb - pointer to pdb object 
*/
static int allocateatom(PDB *pdb)
{
  PDB_ATOM *temp;
  int Nresidues = 0;
  int i;

  if(pdb-&gt;atomspace == 0)
  {
    for(i=0;i&lt;pdb-&gt;Nchains;i++)
      Nresidues += pdb-&gt;chain[i].N;
    if(Nresidues == 0)
      Nresidues = 1;

    pdb-&gt;atoms = malloc(Nresidues * 10 * sizeof(PDB_ATOM));
    if(!pdb-&gt;atoms)
      return -1;
    for(i=pdb-&gt;atomspace;i&lt;Nresidues*10;i++)
      pdb-&gt;atoms[i].element = 0;
    pdb-&gt;atomspace = Nresidues * 10;
  }
  else
  {
    temp = realloc(pdb-&gt;atoms, (pdb-&gt;atomspace + pdb-&gt;atomspace/2) * sizeof(PDB_ATOM));
    if(!temp)
      return -1;
    pdb-&gt;atoms = temp;
    for(i=pdb-&gt;atomspace;i&lt;pdb-&gt;atomspace + pdb-&gt;atomspace/2;i++)
      pdb-&gt;atoms[i].element = 0; 
    pdb-&gt;atomspace = pdb-&gt;atomspace + pdb-&gt;atomspace/2;
  }

  return 0;
}

/*
  add a new chain to the PDB object
  Params: pdb - pointer to object
         id - chain identifier
         len - number of residues
  Returns: 0 on success, -1 on fail
*/
static int addchain(PDB *pdb, char *id, int len)
{
  PDB_CHAIN *temp;
  int i;

  temp = realloc(pdb-&gt;chain, (pdb-&gt;Nchains + 1)* sizeof(PDB_CHAIN) );
  if(!temp)
    return -1;
  pdb-&gt;chain = temp;
  pdb-&gt;chain[pdb-&gt;Nchains].seq = malloc(len * sizeof(PDB_RESIDUE) );
  if(!pdb-&gt;chain[pdb-&gt;Nchains].seq)
    return -1;
  pdb-&gt;chain[pdb-&gt;Nchains].N = len;
  pdb-&gt;chain[pdb-&gt;Nchains].minatom = 100000;
  pdb-&gt;chain[pdb-&gt;Nchains].maxatom = 0;
  pdb-&gt;chain[pdb-&gt;Nchains].base = INT_MAX;
  strcpy(pdb-&gt;chain[pdb-&gt;Nchains].id, id);
  for(i=0;i&lt;len;i++)
  {
    pdb-&gt;chain[pdb-&gt;Nchains].seq[i].symbol = &apos;?&apos;;
    pdb-&gt;chain[pdb-&gt;Nchains].seq[i].minatom = 1000000;
    pdb-&gt;chain[pdb-&gt;Nchains].seq[i].maxatom = 0;
    pdb-&gt;chain[pdb-&gt;Nchains].seq[i].secondary = &apos;-&apos;;
    pdb-&gt;chain[pdb-&gt;Nchains].seq[i].hetid = -1;
  }
 
  pdb-&gt;Nchains++;
  
  return 0;
}

static int addheterogen(PDB *pdb, char *chain, int index, char *name, int Natoms)
{
    PDB_HETEROGEN *temp;
    int chainid;
    int i;

    chainid = pdb_chainindex(pdb, chain);
     
    temp = realloc(pdb-&gt;hets, (pdb-&gt;Nhets + 1) * sizeof(PDB_HETEROGEN));
    if(!temp)
	return -1;
    pdb-&gt;hets = temp;
    pdb-&gt;hets[pdb-&gt;Nhets].Natoms = Natoms;
    strcpy(pdb-&gt;hets[pdb-&gt;Nhets].name3, name);
    pdb-&gt;hets[pdb-&gt;Nhets].fullname = 0;
    pdb-&gt;hets[pdb-&gt;Nhets].Nbonds = 0;
    pdb-&gt;hets[pdb-&gt;Nhets].atomnames = 0;
    pdb-&gt;hets[pdb-&gt;Nhets].bonda = 0;
    pdb-&gt;hets[pdb-&gt;Nhets].bondb = 0;
    pdb-&gt;hets[pdb-&gt;Nhets].maxatom = 0;
    pdb-&gt;hets[pdb-&gt;Nhets].minatom = 1000000;     
    pdb-&gt;hets[pdb-&gt;Nhets].atomnames = malloc(Natoms * sizeof(char *));
    if(!pdb-&gt;hets[pdb-&gt;Nhets].atomnames)
	return -1;
    pdb-&gt;hets[pdb-&gt;Nhets].atomnames[0] = malloc(16 * Natoms);
    if(!pdb-&gt;hets[pdb-&gt;Nhets].atomnames[0])
	return -1;
    for(i=1;i&lt;Natoms;i++)
    {
	pdb-&gt;hets[pdb-&gt;Nhets].atomnames[i] = pdb-&gt;hets[pdb-&gt;Nhets].atomnames[0] + i * 16;
	pdb-&gt;hets[pdb-&gt;Nhets].atomnames[i][0] = 0;
    }

    if(chainid &gt;= 0 &amp;&amp; chainid &lt; pdb-&gt;Nchains)
	if(index &gt;= 0 &amp;&amp; index &lt; pdb-&gt;chain[chainid].N)
	   pdb-&gt;chain[chainid].seq[index].hetid = pdb-&gt;Nhets;

    pdb-&gt;Nhets++;
    return 0;
    
} 

static void addatomtoresidue(PDB *pdb, char *residue, char *chain, int resno, int atomno)
{
  char restype;
  int chainid;
  int diff;
  PDB_RESIDUE *tempseq;
  int i;

  restype = three2one(residue);
  chainid = pdb_chainindex(pdb, chain);
  if(chainid &lt; 0)
  {
    addchain(pdb, chain, 0);
    chainid = pdb_chainindex(pdb, chain);
    if(chainid &lt; 0)
       return;
  }
  /* PDB residue numbering starts from different numbers (0,1, 1000). 
     Update base to fix this up */
  if(resno &lt;= pdb-&gt;chain[chainid].base )
  {
    diff = pdb-&gt;chain[chainid].base - resno;
    if(diff &lt; pdb-&gt;chain[chainid].N)
    {
      memmove(&amp;pdb-&gt;chain[chainid].seq[diff], &amp;pdb-&gt;chain[chainid].seq[0],
        (pdb-&gt;chain[chainid].N - diff) * sizeof(PDB_RESIDUE));
      for(i=0;i&lt;diff;i++)
      {
        pdb-&gt;chain[chainid].seq[i].symbol = &apos;?&apos;;
        pdb-&gt;chain[chainid].seq[i].minatom = 1000000;
        pdb-&gt;chain[chainid].seq[i].maxatom = 0;
        pdb-&gt;chain[chainid].seq[i].secondary = &apos;-&apos;;
        pdb-&gt;chain[chainid].seq[i].hetid = -1;
      }
    }
    pdb-&gt;chain[chainid].base = resno;
  }
  resno -= pdb-&gt;chain[chainid].base;
  if(resno &gt;= pdb-&gt;chain[chainid].N)
  {
    tempseq = realloc(pdb-&gt;chain[chainid].seq, (resno + 1) * sizeof(PDB_RESIDUE));
    if(!tempseq)
      return;
    pdb-&gt;chain[chainid].seq = tempseq;
    for(i=pdb-&gt;chain[chainid].N;i&lt;resno+1;i++)
    {
      pdb-&gt;chain[chainid].seq[i].symbol = &apos;?&apos;;
      pdb-&gt;chain[chainid].seq[i].minatom = 1000000;
      pdb-&gt;chain[chainid].seq[i].maxatom = 0;
      pdb-&gt;chain[chainid].seq[i].secondary = &apos;-&apos;;
      pdb-&gt;chain[chainid].seq[i].hetid = -1;
    }
    pdb-&gt;chain[chainid].N = resno+1;
    pdb-&gt;chain[chainid].seq[resno].symbol = restype;
  }
  if(pdb-&gt;chain[chainid].minatom &gt; atomno)
    pdb-&gt;chain[chainid].minatom = atomno;
  if(pdb-&gt;chain[chainid].maxatom &lt; atomno)
    pdb-&gt;chain[chainid].maxatom = atomno;
  if(pdb-&gt;chain[chainid].seq[resno].minatom &gt; atomno)
    pdb-&gt;chain[chainid].seq[resno].minatom = atomno;
  if(pdb-&gt;chain[chainid].seq[resno].maxatom &lt; atomno)
    pdb-&gt;chain[chainid].seq[resno].maxatom = atomno;
}

static char three2one(char *code3)
{
  if(!strncmp(code3, &quot;ARG&quot;, 3))
    return &apos;R&apos;;
  if(!strncmp(code3, &quot;ASP&quot;, 3))
    return &apos;D&apos;;
  if(!strncmp(code3, &quot;ALA&quot;, 3))
    return &apos;A&apos;;
  if(!strncmp(code3, &quot;ASN&quot;, 3))
    return &apos;N&apos;;
  if(!strncmp(code3, &quot;CYS&quot;, 3))
    return &apos;C&apos;;
  if(!strncmp(code3, &quot;GLY&quot;, 3))
    return &apos;G&apos;;
  if(!strncmp(code3, &quot;GLU&quot;, 3))
    return &apos;E&apos;;
  if(!strncmp(code3, &quot;GLN&quot;, 3))
    return &apos;Q&apos;;
  if(!strncmp(code3, &quot;HIS&quot;, 3))
    return &apos;H&apos;;
  if(!strncmp(code3, &quot;ILE&quot;, 3))
    return &apos;I&apos;;
  if(!strncmp(code3, &quot;LEU&quot;, 3))
    return &apos;L&apos;;
  if(!strncmp(code3, &quot;LYS&quot;, 3))
    return &apos;K&apos;;
  if(!strncmp(code3, &quot;MET&quot;, 3))
    return &apos;M&apos;;
  if(!strncmp(code3, &quot;PHE&quot;, 3))
    return &apos;F&apos;;
  if(!strncmp(code3, &quot;PRO&quot;, 3))
    return &apos;P&apos;;
  if(!strncmp(code3, &quot;SER&quot;, 3))
    return &apos;S&apos;;
  if(!strncmp(code3, &quot;THR&quot;, 3))
    return &apos;T&apos;;
  if(!strncmp(code3, &quot;TRP&quot;, 3))
    return &apos;W&apos;;
  if(!strncmp(code3, &quot;TYR&quot;, 3))
    return &apos;Y&apos;;
  if(!strncmp(code3, &quot;VAL&quot;, 3))
    return &apos;V&apos;; 
  return 0;
}

static int symboltoelementno(char *symbol)
{
  static char *table[112] = 
  {
	  &quot;&quot;, &quot;H&quot;, &quot;He&quot;, &quot;Li&quot;, &quot;Be&quot;, &quot;B&quot;, &quot;C&quot;, &quot;N&quot;, &quot;O&quot;, &quot;F&quot;, &quot;Ne&quot;,
	      &quot;Na&quot;, &quot;Mg&quot;, &quot;Al&quot;, &quot;Si&quot;, &quot;P&quot;, &quot;S&quot;, &quot;Cl&quot;, &quot;Ar&quot;, 
              &quot;K&quot;, &quot;Ca&quot;, 
               &quot;Sc&quot;, &quot;Ti&quot;, &quot;V&quot;, &quot;Cr&quot;, &quot;Mn&quot;, &quot;Fe&quot;, &quot;Co&quot;, &quot;Ni&quot;, &quot;Cu&quot;, &quot;Zn&quot;,
              &quot;Ga&quot;, &quot;Ge&quot;, &quot;As&quot;, &quot;Se&quot;, &quot;Br&quot;, &quot;Kr&quot;,
              &quot;Rb&quot;, &quot;Sr&quot;, 
              &quot;Y&quot;, &quot;Zr&quot;, &quot;Nb&quot;, &quot;Mo&quot;, &quot;Tc&quot;, &quot;Ru&quot;, &quot;Rh&quot;, &quot;Pd&quot;, &quot;Ag&quot;, &quot;Cd&quot;,
              &quot;In&quot;, &quot;Sn&quot;, &quot;Sb&quot;, &quot;Te&quot;, &quot;I&quot;, &quot;Xe&quot;,
              &quot;Cs&quot;, &quot;Ba&quot;,
              &quot;La&quot;, &quot;Ce&quot;, &quot;Pr&quot;, &quot;Nd&quot;, &quot;Pm&quot;, &quot;Sm&quot;, &quot;Eu&quot;, &quot;Gd&quot;, &quot;Tb&quot;, &quot;Dy&quot;, &quot;Ho&quot;, &quot;Er&quot;, &quot;Tm&quot;, &quot;Yb&quot;,
              &quot;Lu&quot;, &quot;Hf&quot;, &quot;Ta&quot;, &quot;W&quot;, &quot;Re&quot;, &quot;Os&quot;, &quot;Ir&quot;, &quot;Pt&quot;, &quot;Au&quot;, &quot;Hg&quot;,
              &quot;Tl&quot;, &quot;Pb&quot;, &quot;Bi&quot;, &quot;Po&quot;, &quot;At&quot;, &quot;Rn&quot;, 
              &quot;Fr&quot;, &quot;Ra&quot;,
              &quot;Ac&quot;, &quot;Th&quot;, &quot;Pa&quot;, &quot;U&quot;, &quot;Np&quot;, &quot;Pu&quot;, &quot;Am&quot;, &quot;Cm&quot;, &quot;Bk&quot;, &quot;Cf&quot;, &quot;Es&quot;, &quot;Fm&quot;, &quot;Md&quot;, &quot;No&quot;,
              &quot;Lr&quot;, &quot;Rf&quot;, &quot;Db&quot;, &quot;Sg&quot;, &quot;Bh&quot;, &quot;Hs&quot;, &quot;Mt&quot;, &quot;Ds&quot;, &quot;Rg&quot;
      };
  static char sym[3];
  int i;
  

  if(!strcmp(symbol, &quot;H&quot;))
      return HYDROGEN;
  if(!strcmp(symbol, &quot;C&quot;))
    return CARBON;
  if(!strcmp(symbol, &quot;N&quot;))
    return NITROGEN;
  if(!strcmp(symbol, &quot;O&quot;))
    return OXYGEN;
  if(!strcmp(symbol, &quot;P&quot;))
      return PHOSPHORUS;
  if(!strcmp(symbol, &quot;S&quot;))
    return SULPHUR;

  sym[0] = symbol[0];
  sym[1] = tolower(symbol[1]);
  sym[0] = 0;

  for(i=1;i&lt;111;i++)
      if(!strcmp(symbol, table[i]))
	  return i;

  return 0;

}

static int getintfield(char *line, int col, int len, int *missing)
{
    char buff[32];
    char *end;
    int answer;

    assert(len &lt; 32);
    getfield(buff, line, col, len);
    answer = (int) strtol(buff, &amp;end, 10);
    if(end == buff &amp;&amp; missing)
	*missing = 1;
    else if(missing)
        *missing = 0;

    return answer; 
}

static void getfield(char *ret, char *line, int col, int len)
{
    int i;

    for(i=col;i&lt;col+len;i++)
	*ret++ = line[i];
    *ret = 0;
} 
/*
  trim leading and trailing whitespace from a string
  Params: str - the string to trim
 */
static void trim(char *str)
{
    char *ptr;
    char *ptr2;

    ptr = str;
    while(isspace(*ptr))
	ptr++;
    ptr2 = str;
    while(*ptr)
	*ptr2++ = *ptr++;
    *ptr2 = 0;
    
    while(ptr2-- &gt; str)
    {
	if(isspace(*ptr2))
	    *ptr2 = 0;
        else
	    break;
    }
}

int pdbmain(int argc, char **argv)
{
  PDB *pdb;
  int i;
  int err;
  char buff[1024];
  float x, y, z;

  pdb = loadpdb(argv[1], &amp;err);

  if(pdb)
  {
    printf(&quot;OK\n&quot;);
    printf(&quot;%d chains\n&quot;, pdb-&gt;Nchains);
    for(i=0;i&lt;pdb-&gt;Nchains;i++)
    {
      pdb_getsequence(pdb, i, buff);
      printf(&quot;Chain %d *%s*: %s\n&quot;, i, pdb-&gt;chain[i].id, buff);
    }
    for(i=0;i&lt;pdb-&gt;chain[1].N;i++)
    {
      if( pdb_getatom(pdb, 1, i, &quot;CB&quot;, &amp;x, &amp;y, &amp;z) == -1)
        printf(&quot;None\n&quot;);
      else 
        printf(&quot;%c: %8.3f %8.3f %8.3f\n&quot;, buff[i], x, y, z);
    }
  }
  
  killpdb(pdb);

  return 0;
}

		</file>
		<file name="torsion.c" type="text">
/*
  torsion.c 
  C-language functions for applying and calculating  torsoin 
  angles
 */
#include &lt;math.h&gt;


float calctorsion(float *A, float *B, float *C, float *D);
void puttor(float *D, float *A, float *B, float *C, float len, float theta, float phi);

#define PI 3.14159265

static void crossproduct(float *ans, float *pt1, float *pt2);
static float dot(float *a, float *b);
static int normalize(float *v);
static void vsub(float *res, float *a, float *b);


/*
  calculate the torsion angle formed by four sets of co-ordinates
  Params: A , B, C, D - points in Cartesian space
  Returns: torsion angle between AB and CD
 */
float calctorsion(float *A, float *B, float *C, float *D)
{
  
  float BA[3];
  float BC[3];
  float DC[3];

  float di[3], gi[3]; 
  float bi, bk, ct;
  float z1, z2, s;
  float answer;

   /* Calculate the vectors BA,BC,DC */     
   vsub(BA, A, B);
   vsub(BC, C, B);
   vsub(DC, C, D);

   /* Calculate the normals to the two planes n1 and n2
      this is given as the cross products:
       AB x BC
      --------- = n1
      |AB x BC|

       BC x CD
      --------- = n2
      |BC x CD|
   */
   

   crossproduct(di, BA, BC);
   crossproduct(gi, BC, DC);  
   
   bi = dot(di, di);
   bk = dot(gi, gi);
   ct = dot(di, gi);

   bi   = (float)sqrt((double)bi);
   bk   = (float)sqrt((double)bk);

   z1   = 1.0f/bi;
   z2   = 1.0f/bk;
   ct   = ct * z1 * z2;
   if (ct &gt;  1.0f)   ct = 1.0f;
   if (ct &lt; (-1.0f)) ct = -1.0f;
   answer   = acos(ct);

   /* calculate side of plane we are on */
   s = BC[0] * (di[2] * gi[1] - di[1] * gi[2])
     + BC[1] * (di[0] * gi[2] - di[2] * gi[0])
     + BC[2] * (di[1] * gi[0] - di[0] * gi[1]);

   if (s &gt; 0.0f) answer = -answer;


   return answer;
}

/*
  natural extension reference put torsion

  Reference Parsons et al (2005) 
   Practical conversion from torsion space to Cartesian space for In Silico
   protein synthesis.

 Journal of Computational Chemistry 26: 1063 - 1068
 
  Places a point in position given length, angle and torsion 
  Params: D - output
          A, B, C - three points in space
          len - length of vector CD
          theta - angle BCD
          phi - torsion angle between AB and DC
  Notes: points in cis are considered to have 0 torsion, points in trans
     have a torsion of PI
   
 */
void puttor(float *D, float *A, float *B, float *C, float len, float theta, float phi)
{
  float n[3];      /* normal to plane ABC */
  float D1[3];     /* point as defined by torsion, length and angle */
  float D2[3];     /* point rotated into correct plane */
  float mtx[3][3]; /* rotation matrix */
  float nxBC[3];   /* normal crossed with BC */
  float AB[3];     /* vector A -&gt; B */
  float BC[3];     /* vector B -&gt; C */

  /* set up planes */
  vsub(AB, B, A);
  vsub(BC, C, B);

  crossproduct(n, AB, BC);
  normalize(n);
  normalize(BC);
  crossproduct(nxBC, n, BC);
 

  /* construct point along Y axis */ 
  theta = PI - theta;
  
  D1[0] = len * cos(theta);
  D1[1] = len * cos(phi) * sin(theta);
  D1[2] = len * sin(phi) * sin(theta);


  /* redundant - copy values to our matrix */
  mtx[0][0] = BC[0]; 
  mtx[1][0] = BC[1]; 
  mtx[2][0] = BC[2];

  mtx[0][1] = nxBC[0], 
  mtx[1][1] = nxBC[1]; 
  mtx[2][1] = nxBC[2];

  mtx[0][2] = n[0], 
  mtx[1][2] = n[1]; 
  mtx[2][2] = n[2];


  /* matrix multiply to put point in correct orientation */

  D2[0] = D1[0] * mtx[0][0] + D1[1] * mtx[0][1] + D1[2] * mtx[0][2];
  D2[1] = D1[0] * mtx[1][0] + D1[1] * mtx[1][1] + D1[2] * mtx[1][2];
  D2[2] = D1[0] * mtx[2][0] + D1[1] * mtx[2][1] + D1[2] * mtx[2][2];


  /* translate by point C */
  D[0] = D2[0] + C[0];
  D[1] = D2[1] + C[1];
  D[2] = D2[2] + C[2];
  
} 


/*
  get the crossproduct of two vectors.
  Params: ans - return pointer for answer.
          pt1 - first vector
		  pt2 - second vector.
  Notes: crossproduct is at right angles to the two vectors.
*/
static void crossproduct(float *ans, float *pt1, float *pt2)
{
  ans[0] = pt1[1] * pt2[2] - pt1[2] * pt2[1];
  ans[1] = pt1[2] * pt2[0] - pt1[0] * pt2[2];
  ans[2] = pt1[0] * pt2[1] - pt1[1] * pt2[0];
}

/*
  get the dotproduct of two vectors
  Params: a - vector 1
          b - vector 2
  Returns: dot product
  Notes = cosine of angle between if both vectors are normal 
 */

static float dot(float *a, float *b)
{
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/*
  normalize a vector
  Params: v - vector to normalize
  Returns: 0 on success, -1 on zero vector
 */
static int normalize(float *v)
{
  double len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
  if(len == 0)
    return -1;
  v[0] /= len;
  v[1] /= len;
  v[2] /= len;
  return 0;
}

/*
  subtrract two vectors
  Params: res - result
          a - vector 1
          b - vector to subtract
 */
static void vsub(float *res, float *a, float *b)
{
  res[0] = a[0] - b[0];
  res[1] = a[1] - b[1];
  res[2] = a[2] - b[2];
}

		</file>
		<file name="jpeg.h" type="text">
#ifndef jpeg_h
#define jpeg_h

unsigned char *loadjpeg(const char *path, int *width, int *height);
int savejpeg(char *path, unsigned char *rgb, int width, int height);

#endif

		</file>
		<file name="aminogeom.c" type="text">
/*
  aminogeom.c - amino acid geometry
 */
#include &lt;string.h&gt;
#include &lt;assert.h&gt;

int isamino(int ch);
void one2three(char *ret, int aa);
char three2one(char *code3);
int getNsideatoms(int aa);
int getNheavysideatoms(int aa);
int getNchiangles(int aa);

int isamino(int ch)
{
  return strchr(&quot;ACDEFGHIKLMNPQRSTVWY&quot;, ch) ? 1 : 0;
}

int aminoidtoindex(int aa)
{
   switch(aa)
    {
	case &apos;A&apos;: return 0;
        case &apos;C&apos;: return 1;
        case &apos;D&apos;: return 2;
        case &apos;E&apos;: return 3;
        case &apos;F&apos;: return 4;
        case &apos;G&apos;: return 5;
        case &apos;H&apos;: return 6;
        case &apos;I&apos;: return 7;
        case &apos;K&apos;: return 8;
        case &apos;L&apos;: return 9;
        case &apos;M&apos;: return 10;
        case &apos;N&apos;: return 11;
        case &apos;P&apos;: return 12; 
        case &apos;Q&apos;: return 13;
        case &apos;R&apos;: return 14;
        case &apos;S&apos;: return 15;
        case &apos;T&apos;: return 16;
        case &apos;V&apos;: return 17;
	case &apos;W&apos;: return 18;
        case &apos;Y&apos;: return 19;
        default:
	  assert(0);
	  return -1;
    }
  
}


void one2three(char *ret, int aa)
{
   switch(aa)
    {
	case &apos;A&apos;: strcpy(ret, &quot;ALA&quot;); return;
        case &apos;C&apos;: strcpy(ret, &quot;CYS&quot;); return;
        case &apos;D&apos;: strcpy(ret, &quot;ASP&quot;); return;
        case &apos;E&apos;: strcpy(ret, &quot;GLU&quot;); return;
        case &apos;F&apos;: strcpy(ret, &quot;PHE&quot;); return;
        case &apos;G&apos;: strcpy(ret, &quot;GLY&quot;); return;
        case &apos;H&apos;: strcpy(ret, &quot;HIS&quot;); return;
        case &apos;I&apos;: strcpy(ret, &quot;ILE&quot;); return;
        case &apos;K&apos;: strcpy(ret, &quot;LYS&quot;); return;
        case &apos;L&apos;: strcpy(ret, &quot;LEU&quot;); return;
        case &apos;M&apos;: strcpy(ret, &quot;MET&quot;); return;
        case &apos;N&apos;: strcpy(ret, &quot;ASN&quot;); return;
        case &apos;P&apos;: strcpy(ret, &quot;PRO&quot;); return;
        case &apos;Q&apos;: strcpy(ret, &quot;GLN&quot;); return;
        case &apos;R&apos;: strcpy(ret, &quot;ARG&quot;); return;
        case &apos;S&apos;: strcpy(ret, &quot;SER&quot;); return;
        case &apos;T&apos;: strcpy(ret, &quot;THR&quot;); return;
        case &apos;V&apos;: strcpy(ret, &quot;VAL&quot;); return;
	case &apos;W&apos;: strcpy(ret, &quot;TRP&quot;); return;
        case &apos;Y&apos;: strcpy(ret, &quot;TYR&quot;); return;
        default:
	  assert(0);
	  return;
    }

}

char three2one(char *code3)
{
  if(!strncmp(code3, &quot;ARG&quot;, 3))
    return &apos;R&apos;;
  if(!strncmp(code3, &quot;ASP&quot;, 3))
    return &apos;D&apos;;
  if(!strncmp(code3, &quot;ALA&quot;, 3))
    return &apos;A&apos;;
  if(!strncmp(code3, &quot;ASN&quot;, 3))
    return &apos;N&apos;;
  if(!strncmp(code3, &quot;CYS&quot;, 3))
    return &apos;C&apos;;
  if(!strncmp(code3, &quot;GLY&quot;, 3))
    return &apos;G&apos;;
  if(!strncmp(code3, &quot;GLU&quot;, 3))
    return &apos;E&apos;;
  if(!strncmp(code3, &quot;GLN&quot;, 3))
    return &apos;Q&apos;;
  if(!strncmp(code3, &quot;HIS&quot;, 3))
    return &apos;H&apos;;
  if(!strncmp(code3, &quot;ILE&quot;, 3))
    return &apos;I&apos;;
  if(!strncmp(code3, &quot;LEU&quot;, 3))
    return &apos;L&apos;;
  if(!strncmp(code3, &quot;LYS&quot;, 3))
    return &apos;K&apos;;
  if(!strncmp(code3, &quot;MET&quot;, 3))
    return &apos;M&apos;;
  if(!strncmp(code3, &quot;PHE&quot;, 3))
    return &apos;F&apos;;
  if(!strncmp(code3, &quot;PRO&quot;, 3))
    return &apos;P&apos;;
  if(!strncmp(code3, &quot;SER&quot;, 3))
    return &apos;S&apos;;
  if(!strncmp(code3, &quot;THR&quot;, 3))
    return &apos;T&apos;;
  if(!strncmp(code3, &quot;TRP&quot;, 3))
    return &apos;W&apos;;
  if(!strncmp(code3, &quot;TYR&quot;, 3))
    return &apos;Y&apos;;
  if(!strncmp(code3, &quot;VAL&quot;, 3))
    return &apos;V&apos;; 
  return 0;
}

int getNsideatoms(int aa)
{
    switch(aa)
    {
	case &apos;A&apos;: return 4;
        case &apos;C&apos;: return 5; /* unbonded */
        case &apos;D&apos;: return 7;
        case &apos;E&apos;: return 10;
        case &apos;F&apos;: return 3 + 6 + 5;
        case &apos;G&apos;: return 1;
        case &apos;H&apos;: return 3 + 3 + 2 + 3;
        case &apos;I&apos;: return 13;
        case &apos;K&apos;: return 15;
        case &apos;L&apos;: return 13;
        case &apos;M&apos;: return 11;
        case &apos;N&apos;: return 8;
        case &apos;P&apos;: return 9; /* exclude CA + N */
        case &apos;Q&apos;: return 11;
        case &apos;R&apos;: return 18;
        case &apos;S&apos;: return 5;
        case &apos;T&apos;: return 8;
        case &apos;V&apos;: return 10;
	case &apos;W&apos;: return 3 + 8 + 1 + 6;
        case &apos;Y&apos;: return 5 + 6 + 4;
        default:
	    assert(0);
	    return -1;
    }

}

int getNheavysideatoms(int aa)
{
    switch(aa)
    {
	case &apos;A&apos;: return 1;
	case &apos;C&apos;: return 2;
	case &apos;D&apos;: return 4;
	case &apos;E&apos;: return 5;
	case &apos;F&apos;: return 7;
	case &apos;G&apos;: return 0;
	case &apos;H&apos;: return 6;
	case &apos;I&apos;: return 4;
	case &apos;K&apos;: return 5;
	case &apos;L&apos;: return 4;
	case &apos;M&apos;: return 4;
	case &apos;N&apos;: return 4;
	case &apos;P&apos;: return 3;
	case &apos;Q&apos;: return 5;
	case &apos;R&apos;: return 7;
	case &apos;S&apos;: return 2;
	case &apos;T&apos;: return 3;
	case &apos;V&apos;: return 3;
	case &apos;W&apos;: return 10;
	case &apos;Y&apos;: return 8;
    }
    assert(0);
}

int getNchiangles(int aa)
{
    switch(aa)
    {
	case &apos;A&apos;: return 0;
	case &apos;C&apos;: return 1;
        case &apos;D&apos;: return 2;
        case &apos;E&apos;: return 3;
        case &apos;F&apos;: return 2;
        case &apos;G&apos;: return 0;
	case &apos;H&apos;: return 2;
        case &apos;I&apos;: return 2;
	case &apos;K&apos;: return 4;
	case &apos;L&apos;: return 2;
	case &apos;M&apos;: return 3;
	case &apos;N&apos;: return 2;
        case &apos;P&apos;: return 1;
	case &apos;Q&apos;: return 3;
	case &apos;R&apos;: return 4;
	case &apos;S&apos;: return 1;
	case &apos;T&apos;: return 1;
	case &apos;V&apos;: return 1;
	case &apos;W&apos;: return 2;
        case &apos;Y&apos;: return 2;
    }
    assert(0);
}

int getNbonds(int aa)
{
    return 0;
}

int getNheavybonds(int aa)
{
    return 0;
}

/*
  convert a heavy atom-name to a residue-specific index
  Params: aa - the one-letter amino acid id
          name - the anme of the atom
  Returns: index of that atom, -1 on fail      
 */
int heavynametoindex(int aa, char *name)
{
  static char *matrix[20][10] =
    {
      /*A*/ {&quot;CB&quot;, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
      /*C*/ {&quot;CB&quot;, &quot;SG&quot;, 0, 0, 0, 0, 0, 0, 0, 0,},
      /*D*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;OD1&quot;, &quot;OD2&quot;, 0, 0, 0, 0, 0, 0,}, 
      /*E*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD&quot;, &quot;OE1&quot;, &quot;OE2&quot;, 0, 0, 0, 0, 0,},
      /*F*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD1&quot;, &quot;CD2&quot;, &quot;CE1&quot;, &quot;CE2&quot;, &quot;CZ&quot;, 0, 0, 0,},
      /*G*/ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
      /*H*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;ND1&quot;, &quot;CD2&quot;, &quot;CE1&quot;, &quot;NE2&quot;, 0, 0, 0, 0,},
      /*I*/ {&quot;CB&quot;, &quot;CG1&quot;, &quot;CG2&quot;, &quot;CD&quot;, 0, 0, 0, 0, 0, 0,},
      /*K*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD&quot;, &quot;CE&quot;, &quot;NZ&quot;, 0, 0, 0, 0, 0,},
      /*L*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD1&quot;, &quot;CD2&quot;, 0, 0, 0, 0, 0, 0,},
      /*M*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;SD&quot;, &quot;CE&quot;, 0, 0, 0, 0, 0, 0,},
      /*N*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;OD1&quot;, &quot;ND2&quot;, 0, 0, 0, 0, 0, 0,},
      /*P*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD&quot;, 0, 0, 0, 0, 0, 0, 0,},
      /*Q*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD&quot;, &quot;OE1&quot;, &quot;NE2&quot;, 0, 0, 0, 0, 0,},
      /*R*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD&quot;, &quot;NE&quot;, &quot;CZ&quot;, &quot;NH1&quot;, &quot;NH2&quot;, 0, 0, 0,},
      /*S*/ {&quot;CB&quot;, &quot;OG&quot;, 0, 0, 0, 0, 0, 0, 0, 0,},
      /*T*/ {&quot;CB&quot;, &quot;OG1&quot;, &quot;CG2&quot;, 0, 0, 0, 0, 0, 0, 0,},
      /*V*/ {&quot;CB&quot;, &quot;CG1&quot;, &quot;CG2&quot;, 0, 0, 0, 0, 0, 0, 0,},
      /*W*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD1&quot;, &quot;CD2&quot;, &quot;NE1&quot;, &quot;CE2&quot;,&quot;CE3&quot;, &quot;CZ2&quot;, &quot;CZ3&quot;,&quot;CH2&quot;,},
      /*Y*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD1&quot;, &quot;CD2&quot;, &quot;CE1&quot;, &quot;CE2&quot;, &quot;CZ&quot;, &quot;OH&quot;, 0, 0,},
    };
  int i;
  int N;
  int aai;

  if(aa == &apos;I&apos; &amp;&amp; !strcmp(name, &quot;CD2&quot;))
    return -1;
  if(!strcmp(name, &quot;N&quot;))
    return 0;
  if(!strcmp(name, &quot;CA&quot;))
    return 1;
  if(!strcmp(name, &quot;C&quot;))
    return 2;
  if(!strcmp(name, &quot;O&quot;))
    return 3;
  N = getNheavysideatoms(aa);

  aai = aminoidtoindex(aa); 
  for(i=0;i&lt;N;i++)
    if(!strcmp(matrix[aai][i], name))
      return i + 4;

  return -1;
}


/*
  converts aa index and atom index to name
  Params: aa - amino acid index (0-20)
          idx - atom idex (pdb ordering, 0 based)
  Returns: atom name.
        
 */
char *indextoname(int aa, int idx)
{
  static char *matrix[20][10] =
    {
      /*A*/ {&quot;CB&quot;, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
      /*C*/ {&quot;CB&quot;, &quot;SG&quot;, 0, 0, 0, 0, 0, 0, 0, 0,},
      /*D*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;OD1&quot;, &quot;OD2&quot;, 0, 0, 0, 0, 0, 0,}, 
      /*E*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD&quot;, &quot;OE1&quot;, &quot;OE2&quot;, 0, 0, 0, 0, 0,},
      /*F*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD1&quot;, &quot;CD2&quot;, &quot;CE1&quot;, &quot;CE2&quot;, &quot;CZ&quot;, 0, 0, 0,},
      /*G*/ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0,},
      /*H*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;ND1&quot;, &quot;CD2&quot;, &quot;CE1&quot;, &quot;NE2&quot;, 0, 0, 0, 0,},
      /*I*/ {&quot;CB&quot;, &quot;CG1&quot;, &quot;CG2&quot;, &quot;CD&quot;, 0, 0, 0, 0, 0, 0,},
      /*K*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD&quot;, &quot;CE&quot;, &quot;NZ&quot;, 0, 0, 0, 0, 0,},
      /*L*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD1&quot;, &quot;CD2&quot;, 0, 0, 0, 0, 0, 0,},
      /*M*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;SD&quot;, &quot;CE&quot;, 0, 0, 0, 0, 0, 0,},
      /*N*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;OD1&quot;, &quot;ND2&quot;, 0, 0, 0, 0, 0, 0,},
      /*P*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD&quot;, 0, 0, 0, 0, 0, 0, 0,},
      /*Q*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD&quot;, &quot;OE1&quot;, &quot;NE2&quot;, 0, 0, 0, 0, 0,},
      /*R*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD&quot;, &quot;NE&quot;, &quot;CZ&quot;, &quot;NH1&quot;, &quot;NH2&quot;, 0, 0, 0,},
      /*S*/ {&quot;CB&quot;, &quot;OG&quot;, 0, 0, 0, 0, 0, 0, 0, 0,},
      /*T*/ {&quot;CB&quot;, &quot;OG1&quot;, &quot;CG2&quot;, 0, 0, 0, 0, 0, 0, 0,},
      /*V*/ {&quot;CB&quot;, &quot;CG1&quot;, &quot;CG2&quot;, 0, 0, 0, 0, 0, 0, 0,},
      /*W*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD1&quot;, &quot;CD2&quot;, &quot;NE1&quot;, &quot;CE2&quot;,&quot;CE3&quot;, &quot;CZ2&quot;, &quot;CZ3&quot;,&quot;CH2&quot;,},
      /*Y*/ {&quot;CB&quot;, &quot;CG&quot;, &quot;CD1&quot;, &quot;CD2&quot;, &quot;CE1&quot;, &quot;CE2&quot;, &quot;CZ&quot;, &quot;OH&quot;, 0, 0,},
    };
  assert(aa &gt;= 0 &amp;&amp; aa &lt; 20);
  assert(idx &gt;= 0 &amp;&amp; idx &lt; 14);
  if(idx == 0)
    return &quot;N&quot;;
  if(idx == 1)
    return &quot;CA&quot;;
  if(idx == 2)
    return &quot;C&quot;;
  if(idx == 3)
    return &quot;O&quot;;
  
  return matrix[aa][idx-4];
}

int getconnected(int aa, int atom1, int atom2)
{
  char *name1;
  char *name2;
  int temp;

  assert(aa &gt;= 0 &amp;&amp; aa &lt; 20);
  assert(atom1 != atom2);
  if(atom1 &gt; atom2)
  {
    temp = atom1;
    atom1 = atom2;
    atom2 = temp;
  }
  name1 = indextoname(aa, atom1);
  name2 = indextoname(aa, atom2);
  assert(name1);
  assert(name2);
  if(atom1 &lt; 4)
  {
    switch(atom1)
    {
    case 0: /* N */
      if(atom2 == 1)
        return 1;
      else
        return 0;
    case 1: /* CA */
      if(atom2 == 2 || atom2 == 4)
        return 1;
      else return 0;
    case 2: /* C */
      if(atom2 == 3)
        return 1;
      else return 0;
    case 3:
      return 0;
    }
  }
  switch(name1[1])
  {
    case &apos;A&apos;: return (name2[1] == &apos;B&apos;) ? 1 : 0;
    case &apos;B&apos;: return (name2[1] == &apos;G&apos;) ? 1 : 0;
    case &apos;G&apos;: return (name2[1] == &apos;D&apos;) ? 1 : 0;
    case &apos;D&apos;: return (name2[1] == &apos;E&apos;) ? 1 : 0;
    case &apos;E&apos;: return (name2[1] == &apos;Z&apos;) ? 1 : 0;
    case &apos;Z&apos;: return (name2[1] == &apos;H&apos;) ? 1 : 0;
    case &apos;H&apos;: return 0;
    default: assert(0); return 0;
  }
}

/*
A - CA CB
C - CA CB SG
D - CA CB CG OD1 OD2
E - CA CB CG CD OE1 OE2
F - CA CB CG CD1 CD2 CE1 CE2 CZ
G - CA
H - CA CB CG ND1 CD2 CE1 NE2
I - CA CB CG1 CG2 CD  
K - CA CB CG CD CE NZ
L - CA CB CG CD1 CD2
M - CA CB CG SD CE
N - CA CB CG OD1 ND2
P - CA CB CG CD
Q - CA CB CG CD OE1 NE2
R - CA CB CG CD NE CZ NH1 NH2
S - CA CB OG
T - CA CB OG1 CG2
V - CA CB CG1 CG2
W - CA CB CG CD1 CD2 NE1 CE2 CE3 CZ2 CZ3 CH2
Y - CA CB CG CD1 CD2 CE1 CE2 CZ OH  
 */

/*
  A - H HA 1HB 2HB 3HB
  C - H HA 1HB 2HB HG
  D - H HA 1HB 2HB
  E - H HA 1HB 2HB 1HG 2HG
  F - H HA 1HB 2HB HD1 HD2 HE1 HE2 HZ
  G - H 1HA 2HA
  H - H HA 1HB 2HB HD1 HD2 HE1
  I - H HA HB 1HG1 2HG1 1HG2 2HG2 3HG2 1HD1 2HD1 3HD1
  K - H HA 1HB 2HB 1HG 2HG 1HD 2HD 1HE 2HE 1HZ 2HZ 3HZ
  L - H HA 1HB 2HB HG 1HD1 2HD1 3HD1 1HD2 2HD2 3HD2
  M - H HA 1HB 2HB 1HG 2HG 1HE 2HE 3HE
  N - H HA 1HB 2HB 2HD2 1HD2 1HD2
  P - H2 H1 HA 1HB 2HB 1HG 2HG 1HD 2HD
  Q - H HA 1HB 2HB 1HG 2HG 2HE2 1HE2
  R - H HA 1HB 2HB 1HG 2HG 1HD1 2HD HE 1HH1 2HH1 1HH2 2HH2
  S - H HA 1HB 2HB HG
  T - H HA HB HG1 1HG2 2HG2 3HG2
  V - H HA HB 1HG1 2HG1 3HG1 1HG2 2HG2 3HG2
  W - H HA 1HB 2HB HD1 HE1 HE3 HZ2 HZ3 HH2 
  Y - H HA 1HB 2HB HD1 HD2 HE1 HE2 HH
 */


		</file>
		<file name="utils.c" type="text">


/*
  shuffle an array
  Parmas: array - data to shuffle
          N - number of data items
          size - size of data item
 */
void shuffle(void *array, int N, int size)
{
  int i;
  int ii;
  unsigned char *base;
  unsigned char *ptr;
  unsigned char temp;
  int target;

  base = array;
  for(i=0;i&lt;N-1;i++)
  {
    target = (rand() % (N - i));
    ptr = base + target * size;
    if(ptr != base)
    {
      for(ii=0;ii&lt;size;ii++)
      {
        temp = base[ii];
        base[ii] = ptr[ii];
        ptr[ii] = temp;
      }
    }
    base += size;
  }
}

		</file>
		<directory name="synteny">
			<file name="synteny.c" type="text">
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;
#include &lt;math.h&gt;

typedef struct match
{
  int pos;
  int score;
  int bad;
  struct match *next;
} MATCH;

int align_r(char *seq1, int len1, char *seq2, int len2, char **a1, char **a2, int patlen);

MATCH *getmatches(char *seq1, int len1, char *seq2, int len2, int patlen);
void killmatches(MATCH *m, int N);
int getgoodmatches(MATCH *m, int N, int **pos1, int **pos2, int patlen);
int *matchtolist(MATCH *m, int N, int *lenret);
int match1(char *seq1, int len1, char *seq2, int len2, char **a1, char **a2);
double probability(int Nfixed, int len1, int len2, int patlen);
char *repchar(char ch, int N);
char *catN(char *str1, const char *str2, int N);
char *cat(char *str1, char *str2);
char *strdupN(const char *str, int N);
double factorial(int N);
double plongestsequence(int seqlen, int N);
int *longestascendingsequences(int *x, int N, int *lenret, int *Nret);
int *longestascendingsequence(int *x, int N, int *lenret);



int align(char *seq1, char *seq2, char *a1, char *a2)
{
  char *align1, *align2;
  int answer;
  
  answer = align_r(seq1, strlen(seq1), seq2, strlen(seq2), &amp;align1, &amp;align2, 6);
  if(answer == 0)
  {
    strcpy(a1, align1);
    strcpy(a2, align2);
  }
  else
  {
	 *a1 = 0;
	 *a2 = 0;
  }
  free(align1);
  free(align2);
  
  return answer;
}

int align_r(char *seq1, int len1, char *seq2, int len2, char **a1, char **a2, int patlen)
{
  char *align1 = 0;
  char *align2 = 0; 
  char *swapptr = 0; 
  MATCH *m;
  int Nfixed;
  int i;
  char *spaces = 0;
  int *pos1, *pos2;

  if(patlen == 1)
    return match1(seq1, len1, seq2, len2, a1, a2); 
  
  if(len1 &gt; len2)
  {
	int temp;
	swapptr = seq1;
	seq1 = seq2;
	seq2 = swapptr;
	temp = len1;
	len1 = len2;
	len2 = temp;
  }
  if(len1 == 0)
  {
	if(!swapptr)
	{
      *a1 = repchar(&apos;-&apos;, len2);
      *a2 = strdupN(seq2, len2);
    }
    else
    {
	  *a2 = repchar(&apos;-&apos;, len2);
	  *a1 = strdupN(seq2, len2);
    }
    return 0;
  }
  
  m = getmatches(seq1, len1, seq2, len2, patlen);
  Nfixed = getgoodmatches(m, len1-patlen+1, &amp;pos1, &amp;pos2, patlen);

  if(probability(Nfixed, len1, len2, patlen) &gt; 0.05)
	  Nfixed = 0;
  
  if(Nfixed &gt; 0 &amp;&amp; pos1[0] != 0 &amp;&amp; pos2[0] == 0)
  {
    align1 = strdupN(seq1, pos1[0]);
    align2 = repchar(&apos;-&apos;, pos1[0]);
  }
  else if(Nfixed &gt; 0 &amp;&amp; pos1[0] == 0 &amp;&amp; pos2[0] != 0)
  {
    align1 = repchar(&apos;-&apos;, pos2[0]);
    align2 = strdupN(seq2, pos2[0]);
  }
  else if(Nfixed &gt; 0 &amp;&amp; pos1[0] &gt; 0 &amp;&amp; pos2[0] &gt; 0)
  {
    align_r(seq1, pos1[0], seq2, pos2[0], &amp;align1, &amp;align2, patlen-1); 
  }
  else if(Nfixed &gt; 0 &amp;&amp; pos1[0] == 0 &amp;&amp; pos2[0] == 0)
  {
	align1 = strdupN(&quot;&quot;, 0);
	align2 = strdupN(&quot;&quot;, 0);
  }
  
  if(Nfixed == 0)
  {
    align_r(seq1, len1, seq2, len2, &amp;align1, &amp;align2, patlen-1);
  }
  for(i=0;i&lt;Nfixed;i++)
  {
	int Nrun = 0;
	int j;
	char *sub1, *sub2;
	
	for(j=i+1;j&lt;Nfixed;j++)
	  if(pos1[j-1] == pos1[j] - 1 &amp;&amp; pos2[j-1] == pos2[j]-1)
	    Nrun++;
	  else
	    break;
	      
    align1 = catN(align1, seq1 + pos1[i], patlen + Nrun);
    align2 = catN(align2, seq2 + pos2[i], patlen + Nrun);

	if( j &lt; Nfixed)
	{
      align_r(seq1+pos1[j-1] + patlen,
		    pos1[j] - pos1[j-1] - patlen &gt; 0 ? pos1[j] - pos1[j-1] - patlen: 0, 
			seq2+pos2[j-1] + patlen, 
			pos2[j] - pos2[j-1] - patlen &gt; 0 ? pos2[j] - pos2[j-1] - patlen : 0, 
			&amp;sub1, 
			&amp;sub2, 
			patlen-1);
      align1 = cat(align1, sub1);
      align2 = cat(align2, sub2); 
	}
    i += Nrun;
  }
  
  
  if(Nfixed &gt; 0 &amp;&amp; pos1[Nfixed-1] == len1-patlen &amp;&amp; pos2[Nfixed-1] != len2 - patlen)
  {
	spaces = repchar(&apos;-&apos;, len2 - pos2[Nfixed-1] - patlen);
	align1 = cat(align1, spaces);
	align2 = catN(align2, seq2 + pos2[Nfixed-1]+patlen, len2 - pos2[Nfixed-1]-patlen);
  }
  else if(Nfixed &gt; 0 &amp;&amp; pos1[Nfixed-1] != len1-patlen &amp;&amp; pos2[Nfixed-1] == len2 - patlen)
  {
    align1 = catN(align1, seq1 + pos1[Nfixed-1]+patlen, len1 - pos1[Nfixed-1]-patlen);
    spaces = repchar(&apos;-&apos;, len1 - pos1[Nfixed-1] - patlen);
    align2 = cat(align2, spaces);	  
  }
  else if(Nfixed &gt; 0)
  {
	  char *sub1, *sub2;
 
	  align_r(seq1 + pos1[Nfixed-1] + patlen,
		      len1 - pos1[Nfixed-1] - patlen,
			  seq2 + pos2[Nfixed-1] + patlen,
			  len2 - pos2[Nfixed-1] - patlen,
			  &amp;sub1, 
			  &amp;sub2,
			  patlen-1);
	  align1 = cat(align1, sub1);
	  align2 = cat(align2, sub2);
  }
 
 
  if(swapptr)
  {
    *a2 = align1;
    *a1 = align2;
  }
  else
  {
    *a1 = align1;
    *a2 = align2;
  }
  
  killmatches(m, len1 - patlen + 1);
  free(pos1);
  free(pos2);
  return 0;
  error_exit:
    return -1;
  
}

MATCH *getmatches(char *seq1, int len1, char *seq2, int len2, int patlen)
{
  int i;
  char *ptr;
  char *sub;
  MATCH *answer;
  MATCH *prev;
  
  if(len1 &lt; patlen || len2 &lt; patlen)
  {
	  return 0;
  }
  answer = malloc((len1-patlen+1) * sizeof(MATCH));
  
  
  for(i=0;i&lt;len1-patlen+1;i++)
  {
	 sub = strdupN(seq1 + i, patlen);
     ptr = strstr(seq2, sub);
     if(!ptr || ptr - seq2 &gt;= len2 - patlen)
     {
       answer[i].pos = -1;
       answer[i].next = 0;
     }
     else
     {
       answer[i].pos = ptr - seq2;
       answer[i].next =0;
       ptr++;
       prev = &amp;answer[i];
       while( (ptr = strstr(ptr, sub)) &amp;&amp; ptr - seq2 &lt;= len2 - patlen )
       {
         prev-&gt;next = malloc(sizeof(MATCH));
         prev-&gt;next-&gt;pos = ptr - seq2;
         prev-&gt;next-&gt;next = 0;
         prev = prev-&gt;next;
         ptr++;
       }
     }
     free(sub);
  }
  return answer;
}

void killmatches(MATCH *m, int N)
{
  int i;
  MATCH *prev, *next;
  
  if(m)
  {
    for(i=0;i&lt;N;i++)
    {
      prev = m[i].next;
      while(prev)
      {
        next = prev-&gt;next;
        free(prev);
        prev = next;
      }
    }
  }
}

int getgoodmatches(MATCH *m, int N, int **pos1, int **pos2, int patlen)
{
  int *list;
  int Nlist;
  int Nascending;
  int i, j;
  MATCH *ptr;
  int *ascending;
  int *p1, *p2;
  int k = 0;
  int lastk;

  if(!m)
  {  
	 *pos1 = 0;
     *pos2 = 0;
	  return 0;
  }
  list = matchtolist(m, N, &amp;Nlist);
  ascending = longestascendingsequence(list, Nlist, &amp;Nascending);

  p1 = malloc(Nascending * sizeof(int));
  p2 = malloc(Nascending * sizeof(int));
  j = 0;
  for(i = 0; i &lt; N; i++)
  {
	for(ptr = &amp;m[i]; ptr;ptr=ptr-&gt;next)
	{
		if(ptr-&gt;pos == ascending[j])
		{
			if(k == 0 || 
				(p1[k-1] == i-1 &amp;&amp; p2[k-1] == ptr-&gt;pos-1) ||
				(p1[lastk] &lt;= i - patlen &amp;&amp; p2[lastk] &lt; ptr-&gt;pos - patlen))
			{
			  p1[k] = i;
			  p2[k] = ptr-&gt;pos;
			  
			  if(k == 0 || p1[k-1] != p1[k]-1 || p2[k-1] != p2[k]-1)
				  lastk = k;
			  k++;
			}
			j++;
			break;
		}
	}
  }
  *pos1 = p1;
  *pos2 = p2;

  free(list);
  free(ascending);

  return k;
}

int *matchtolist(MATCH *m, int N, int *lenret)
{
	int Nm =0;
	MATCH *ptr;
	int i, j, jj, k;
	int *answer;
	int temp;
	
	for(i=0;i&lt;N;i++)
	  for(ptr = &amp;m[i];ptr; ptr=ptr-&gt;next)
	    if(ptr-&gt;pos != -1)
	      Nm++;
    answer = malloc(Nm * sizeof(int));
    j = 0;
    for(i=0;i&lt;N;i++)
    {
	  k = j;
      for(ptr = &amp;m[i]; ptr; ptr=ptr-&gt;next)
        if(ptr-&gt;pos != -1)
          answer[j++] = ptr-&gt;pos;
	  
      for(jj=k;jj&lt;k+(j-k)/2;jj++)
      {
	    temp = answer[jj];
	    answer[jj] = answer[j-jj+k-1];
	    answer[j-jj+k-1] = temp;
      }
    }
  
    *lenret = j;
  
  return answer;
}


int match1(char *seq1, int len1, char *seq2, int len2, char **a1, char **a2)
{
  char *align1, *align2;
  
  if(len1 == len2 &amp;&amp; len1 &lt;= 6)
  {
    align1 = strdupN(seq1, len1);
    align2 = strdupN(seq2, len2);
  }
  else
  {
    align1 = malloc(len1 + len2 + 1);
    memcpy(align1, seq1, len1);
    memset(align1 + len1, &apos;?&apos;, len2);
    align1[len1+len2] = 0;
    align2 = malloc(len1 + len2 + 1);
    memset(align2, &apos;?&apos;, len1);
    memcpy(align2+len1, seq2, len2);
    align2[len1+len2] = 0;
  }
  *a1 = align1;
  *a2 = align2;
  
  return 0;
}

double probability(int Nfixed, int len1, int len2, int patlen)
{
  double Ntries;
  double pmatch;

  if(Nfixed &lt; 6)
	  return 1.0;
  Ntries = (len1-patlen+1) * (len2-patlen+1);
  pmatch = 1.0 /  pow(4, patlen);
  return plongestsequence(Nfixed, (int) (Ntries * pmatch) );
}

char *repchar(char ch, int N)
{
	char *answer;

  answer = malloc(N+1);
  if(answer)
  {
    memset(answer, ch, N);
    answer[N] = 0;
  }
  return answer;
}

char *catN(char *str1, const char *str2, int N)
{
  int len1;
  char *answer;
  
  len1 = strlen(str1);
  answer = malloc(len1 + N + 1);
  if(answer)
  {
	  strcpy(answer, str1);
	  memcpy(answer+len1, str2, N);
	  answer[len1+N] = 0;
  }
  free(str1);
  return answer;
}

char *cat(char *str1, char *str2)
{
  int len1 = strlen(str1);
  int len2 = strlen(str2);
  char *answer = malloc(len1 + len2 + 1);
  
  if(answer)
  {
	memcpy(answer, str1, len1);
	strcpy(answer+len1, str2);
  }
  free(str1);
  free(str2);
  return answer;
}

char *strdupN(const char *str, int N)
{
  char *answer;
  
  answer = malloc(N+1);
  if(!answer)
    return 0;
  memcpy(answer, str, N);
  answer[N] = 0;
  
  return answer;
}

double factorial(int N)
{
  double answer = 1.0;
  int i;
  
  for(i=1;i&lt;=N;i++)
    answer *= i;
    
  return answer;
}

static int oldsig[100] = {0, 0, 2, 3, 3, 3, 4, 4, 5, 6, 6, 6, 6, 6, 7, 7, 8, 9, 9,
9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 
13, 13, 13, 13, 14, 14, 14, 14, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
16, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 
20, 21, 21, 22, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24 };


static int sig[1000] = {0, 0, 2, 3, 3, 3, 4, 4, 5, 6, 6, 6, 6, 6, 7, 7, 8, 9, 9,
 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12,
13, 13, 13, 13, 13, 14, 14, 14, 14, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
16, 16, 16, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 20,
20, 20, 21, 21, 22, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26,
26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30,
30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 34, 35, 35,
35, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 37, 37, 37, 37, 38, 39, 39, 39, 39,
39, 39, 39, 39, 39, 39, 39, 39, 39, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
40, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41,
41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42,
42, 42, 43, 43, 43, 44, 44, 45, 45, 45, 45, 45, 45, 45, 45, 45, 45, 46, 46, 46,
46, 46, 47, 47, 47, 47, 48, 48, 48, 48, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50,
50, 50, 50, 51, 51, 51, 51, 51, 52, 53, 53, 53, 53, 53, 53, 53, 53, 53, 53, 54,
56, 56, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57, 57,
57, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58, 58,
58, 58, 58, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59,
59, 60, 60, 60, 60, 60, 60, 60, 60, 61, 61, 61, 62, 62, 62, 62, 62, 62, 62, 63,
63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 63, 64, 64, 64, 64, 64, 64, 64, 64,
64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64, 64,
64, 64, 64, 64, 64, 64, 64, 64, 64, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65,
65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 65, 67, 67, 67, 67,
67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67, 67,
67, 68, 68, 68, 68, 68, 68, 68, 68, 69, 69, 69, 69, 69, 69, 69, 69, 69, 69, 70,
70, 70, 70, 70, 70, 70, 70, 71, 71, 71, 71, 71, 71, 71, 71, 71, 71, 72, 72, 72,
72, 72, 72, 73, 73, 73, 73, 74, 74, 75, 75, 75, 75, 75, 75, 75, 75, 75, 75, 77,
77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77, 77,
77, 77, 77, 77, 77, 78, 78, 78, 78, 78, 78, 78, 78, 79, 79, 79, 79, 79, 79, 79,
80, 81, 85, 85, 85, 85, 85, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87,
87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 87, 88, 88, 88, 88, 88, 88, 88,
88, 88, 88, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 89, 90, 90, 90, 90, 90,
90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90,
90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 91,
91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 91, 92, 92, 92,
92, 92, 92, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 93, 94, 94, 94, 94, 94,
94, 94, 94, 94, 95, 95, 96, 97, 97, 97, 97, 98, 98, 100, 100, 100, 100, 100, 100, 
100, 100, 100, 100, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101, 101,
101, 104, 104, 104, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 107,
107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107, 107,
107, 109, 109, 109, 109, 110, 110, 110, 110, 110, 111, 111, 111, 111, 111, 111, 
111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 111, 
113, 113, 113, 113, 113, 115, 115, 115, 119, 119, 119, 119, 119, 119, 119, 119, 
119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 
119, 120, 120, 120, 120, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 
122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122,
122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 
122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 122, 
122, 124, 124, 124, 124, 124, 124, 124, 124, 124, 124, 125, 125, 125, 125, 125, 
125, 125, 125, 125, 125, 125, 125, 125, 125, 127, 127, 127, 127, 127, 127, 127, 
127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, };


double plongestsequence(int seqlen, int N)
{
  if(seqlen &gt; N)
	 return 0;
  if(seqlen &lt; 3)
	  return 1.0;
  if(N &lt; 1000)
	return seqlen &gt;= sig[N]/5 ? 0.01 : 1.0;
  else
	return seqlen &gt;= N ? 0.01 : 1.0;
}


int *longestascendingsequence(int *x, int N, int *lenret)
{
	int *p;
	int *m;
	int L = -1;
	int i, j;
	int bestj;
	int *answer = 0;
	
	p = malloc(N * sizeof(int));
	m = malloc(N * sizeof(int));
	
	if(!m || !p)
	  goto out_of_memory;

	for(i=0;i&lt;N;i++)
	{
	  bestj = -1;
	  for(j=0;j&lt;=L;j++)
	    if(x[m[j]] &lt; x[i])
	      bestj = j;
	 if(bestj != -1)
	    p[i] = m[bestj];
	 if(bestj == L || x[i] &lt; x[m[bestj+1]])
	   m[bestj+1] = i;
	 L = L &gt; bestj + 1 ? L : bestj+1;     
    }
	L++;
    answer = malloc(L * sizeof(int));
    if(lenret)
      *lenret = L;
    j = m[L-1];
    while(L--)
    {
      answer[L] = x[j];
      if(L)
        j = p[j];
    }
	free(m);
	free(p);
	return answer;
	
	out_of_memory:
	  free(m);
	  free(p);
	  free(answer);
	  if(lenret)
	    *lenret = 0;
	  return 0;
}

#define uniform() (rand()/(RAND_MAX+1.0))

void mem_swap(void *ptr1, void *ptr2, int N)
{
	unsigned char *p1 = ptr1;
	unsigned char *p2 = ptr2;
	unsigned char temp;
	int i;

	for(i=0;i&lt;N;i++)
	{
		temp = p1[i];
		p1[i] = p2[i];
		p2[i] = temp;
	}
}

void shuffle(void *ptr, int width, int N)
{
	int target;
	int i;

	for(i=0;i&lt;N-1;i++)
	{
      target = (int) (uniform() * (N-i)) + i;
	  mem_swap((unsigned char *)ptr + i*width, (unsigned char *)ptr + target*width, width); 
	}
}

char *randseq(int N, double gc)
{
	char *answer = malloc(N+1+100);
	int i;
	double p;

	if(!answer)
		return 0;
	memset(answer, &apos;X&apos;, N+1+100);
	for(i=0;i&lt;N;i++)
	{
		p = uniform();
		if(p &lt; gc)
		  answer[i] = p &lt; gc/2.0 ? &apos;C&apos; : &apos;G&apos;;
		else
		  answer[i] = (p &lt; 1.0 - (1.0-gc)/2.0) ? &apos;A&apos; : &apos;T&apos;;
	}
	answer[N] = 0;

	return answer;
}

int compints(const void *e1, const void *e2)
{
	const int *i1 = e1;
	const int *i2 = e2;

	return *i1 - *i2;
}

char *insert(char *seq, int N, int len)
{
  char *answer = malloc(strlen(seq) + N * len + 1);
  int t;
  int i, ii;

  strcpy(answer, seq);
  for(i=0;i&lt;N;i++)
  {
	t = (int) (uniform() * strlen(answer));
    memmove(&amp;answer[t+len], &amp;answer[t], strlen(answer) - t + 1);
	for(ii=t;ii&lt;t+len;ii++)
      answer[ii] = &quot;ACGT&quot;[rand() % 4];
  }
  
  return answer;
}

void pointmutate(char *seq, double p)
{
	int i;

	for(i=0;seq[i];i++)
	  if(uniform() &lt; p)
		  seq[i] = &quot;ACGT&quot;[rand() % 4];

}

#include &quot;fasta.h&quot;

int fasta_record(FILE *fp, char *header, char *seq)
{
  int i;
  int len;
  
  if(header[0] == &apos;&gt;&apos;)
    fprintf(fp, &quot;%s\n&quot;, header);
  else fprintf(fp, &quot;&gt;%s\n&quot;, header);
  len = strlen(seq);
  for(i=0;i&lt;len;i++)
  {
    fputc(seq[i], fp);
    if( (i % 79) == 78)
      fputc(&apos;\n&apos;, fp);
  }
  if( (len % 79) != 0)
    fputc(&apos;\n&apos;, fp);
  return ferror(fp);
}


char *generatetestfasta()
{
  char *fname = &quot;test.fasta&quot;;
  FILE *fp;
  char *seq1;
  char *seq2;
  char *mutseq;

  fp = fopen(&quot;test.fasta&quot;, &quot;w&quot;);
  seq1 = randseq( 100 + (rand() % 100), 0.5);    
  seq2 = strdupN(seq1, strlen(seq1));
  mutseq = insert(seq1, 2, 5);
  pointmutate(mutseq, 0.1);
  fasta_record(fp, &quot;seq1&quot;, seq1);
  fasta_record(fp, &quot;seq2&quot;, mutseq);
  fclose(fp); 
  
}
void usage(void)
{
	printf(&quot;synteny_align : align two sequences using synteny method\n&quot;);
	printf(&quot;usage synteny_align &lt;input.fasta&gt;\n&quot;);
	printf(&quot;Fasta file must contain two sequences\n&quot;);
	printf(&quot;output to stdout\n&quot;);
	exit(EXIT_FAILURE);
}

int main(int argc, char **argv)
{
	int i;
	MATCH *m;
	MATCH *ptr;
	int N;
	int Nmatches;
	int *pos1, *pos2;
	int len;
	
	char *seq1;
	char *seq2;
	char *mutseq;
	int len1, len2;
	char *a1, *a2;
	
	int *x;
	int array[1000];
	int *seq;

	FASTA *fa;
	int err;

        if(argc == 1)
	{
          generatetestfasta();
	  return 0;
        }


	if(argc == 2)
	{
		fa = loadfasta(argv[1], &amp;err);
		if(fasta_getNsequences(fa) != 2)
		{
			fprintf(stderr, &quot;Fasta file must contain 2 sequences\n&quot;);
			exit(EXIT_FAILURE);
		}
		len1 = fasta_getlength(fa, 0);
		len2 = fasta_getlength(fa, 1);
		seq1 = malloc(len1 + 1);
		seq2 = malloc(len2 + 1);
		fasta_getsequence(fa, 0, seq1);
		fasta_getsequence(fa, 1, seq2);
	}
	a1 = malloc(len1+len2+1);
	a2 = malloc(len1+len2+1);

	align(seq1, seq2, a1, a2);
	fasta_record(stdout, fa-&gt;fs[0].header, a1);
	fasta_record(stdout, fa-&gt;fs[1].header, a2);
	free(a1);
	free(a2);
	free(seq1);
	free(seq2);
	return 0;
	/*

	x = malloc(10000 * sizeof(int));
	for(i=0;i&lt;1000;i++)
	  array[i] = i+1;  

	printf(&quot;static int sig[1000] = {0, 0, &quot;); 



	for(i=2;i&lt;1000;i++)
	{
		int ii;
		for(ii=0;ii&lt;1000;ii++)
		{
		  shuffle(array, i, sizeof(int));
		  seq = longestascendingsequence(array, i, &amp;x[ii]);
		  free(seq);
		}
		qsort(x, 10000, sizeof(int), compints);
		printf(&quot;%d, &quot;, x[9900]);
	}
	printf(&quot;};\n&quot;);
	getchar();
	*/

	/*
	for(i=0;i&lt;100;i++)
	{
	seq1 = randseq( 100 + (rand() % 100), 0.5);
	//seq2 = randseq( 100 + (rand() % 100), 0.5);
	seq2 = strdupN(seq1, strlen(seq1));
	mutseq = insert(seq1, 2, 5);
	pointmutate(mutseq, 0.1);

	align(seq1, mutseq, a1, a2);
	printf(&quot;%s\n&quot;, a1);
	printf(&quot;%s\n&quot;, a2);

	free(seq1);
	free(seq2);
	free(mutseq);
	}
	getchar();
	return 0;
	*/
}

			</file>
			<file name="fasta.h" type="text">
#ifndef fasta_h
#define fasta_h

#define FASTA_UNKNOWN 0
#define FASTA_DNA 1
#define FASTA_RNA 2
#define FASTA_PROTEIN 3
#define FASTA_XDNA 4
#define FASTA_XRNA 5
#define FASTA_XPROTEIN 6

typedef struct
{
  char *header;       /* the FASTA header */
  char *comment;      /* comments (start with semicolon) */
  char *seq;          /* the sequence, includes gaps */
  int seqlen;         /* length of sequence (excluding gaps) */
  int gappedlen;      /* length of the sequence, including gaps */
  int type;           /* DNA/RNA/PROTEIN/UNKNOWN */
} FASTASEQ;

typedef struct
{
  int N;             /* number of sequences */
  FASTASEQ *fs;      /* the sequences */
} FASTA;

FASTA *loadfasta(char *fname, int *err);
FASTA *floadfasta(FILE *fp, int *err);
void killfasta(FASTA *fa);
int fasta_getNsequences(FASTA *fa);
void fasta_getsequence(FASTA *fa, int index, char *out);
void fasta_getgappedsequence(FASTA *fa, int index, char *out);
int fasta_getlength(FASTA *fa, int index);
int fasta_getgappedlength(FASTA *fa, int index);
int fasta_gettype(FASTA *fs, int index);

#endif

			</file>
			<file name="ukkonenR.c" type="text">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;


static char *As;
static char *Bs;
static char *Cs;
int alen;
int blen;
int clen;


static int ncode[7] = {7,1,2,4,3,5,6};
static int infinity = 32000;
int ***U;
int **Udone;
int MaxCost = 70;

int ukk(int ab, int ac, int cost);
int step(int PBest, int ab, int ac, int cost, int da, int db, int dc, int *prevcost);
void traceback(int ab, int ac, int cost);
int triple(int a, int b, int c);
void showtriple(int a, int b, int c);
int max7(int a, int b, int c, int d, int e, int f, int g);
int max2(int a, int b);

/*
char **ukkonenR(char *s1, char *s2, char *s3, int cost)
{
  Udone = malloc( (70+70+1) * sizeof(int *));
  for(i=0;i&lt;70+70+1;i++)
    Udone[i] = malloc( (70+70+1) * sizeof(int));

  U = malloc( (70+70+1) * sizeof(int **));
  for(i=0;i&lt;70+70+1;i++)
  {
    U[i] = malloc( (70+70+1) * sizeof(int *));
    for(ii=0;ii&lt; 70+70+1;ii++)
    {
      U[i][ii] = malloc(71 * sizeof(int));
      for(iii=0;iii&lt;71;iii++)
        U[i][ii][iii] = 0;
    }
  }

  
  for(ab=-MaxCost;ab&lt;=MaxCost;ab++)
    for(ac=-MaxCost;ac&lt;-MaxCost;ac++)
      Udone[ab+MaxCost][ac+MaxCost] = -3;

  As = s1;
  Bs = s2;
  Cs = s3;
  alen = strlen(As);
  blen = strlen(Bs);
  clen = strlen(Cs);

  i = 0;

  while(i &lt; alen &amp;&amp; triple(i,i,i) == 0)
    i++;

  U[0][0][0] = i -1;
  Udone[0][0] = 0;
    
  ab = alen - blen;
  ac = alen - clen;
  do
  {
      cost = max7(0, ab, ac, -ab, -ac, ab-ac, ac-ab) - 1;
      do
      {
        cost++;
        a = ukk(ab, ac, cost);
      }
    } while(a &lt; alen) 
  }  

  traceback(ab, ac, cost);
}

*/

int ukk(int ab, int ac, int cost)
{
  int radius, nn, neighbour;
  int a, a2, b, c, da, db, dc, pc;
  //int prevcost;

  radius = max7(0, ab, ac, -ab, -ac, ab-ac, ac-ab);
  
  if(radius &gt; cost)
    return -infinity;
  else if(cost &lt;= Udone[MaxCost+ab][MaxCost+ac])
    return U[MaxCost+ab][MaxCost+ac][cost];
  else
  {
    a = -infinity;
    //    prevcost = -infinity;
    
    for(nn=0;nn&lt;7;nn++)
    {
      neighbour = ncode[nn];
      da = neighbour / 4;
      db = (neighbour/2) % 2;
      dc = neighbour % 2;
      a2 = step(a, ab-da+db, ac-da+dc, cost-1, da, db, dc, &amp;pc);
      if(a2 &lt; a)
      {
        a = a2;
      }
    }
      
    b = a - ab;
    c = a - ac;
   
    while(a &gt;= 0 &amp;&amp; a &lt; alen &amp;&amp; triple(a+1, b+1, c+1) == 0)
    {
      a++;
      b++;
      c++;
    }

    U[MaxCost+ab][MaxCost+ac][cost] = a;
    Udone[MaxCost+ab][MaxCost+ac] = cost;
    
    return a;
  }
}


int step(int PBest, int ab, int ac, int cost, int da, int db, int dc, int *prevcost)
{
  int a, b, c, a2, b2,c2, a3;
  
  a3 =0;
  a = ukk(ab, ac, cost);
  b = a - ab;
  c = a - ac;
  *prevcost = cost;
  a2 = a+da; b2 = b+db; c2 = c+dc;
  switch(da+db+dc)
  {
  case 1: break;
  case 2: while(a2 &gt;= PBest &amp;&amp; a2 &gt; a3 &amp;&amp; a2 &gt;= 0 &amp;&amp; b2 &gt;= 0 &amp;&amp; c2 &gt;= 0 &amp;&amp;
		triple(a2*da, b2*db, c2*dc) == 2)
      {
        a2--;
        b2--;
        c2--;
      }
    if(a2 == a3)
      *prevcost = cost -1;
    break;

  case 3:
    if( triple(a2, b2, c2) == 2)
      {
        a2 = a;
        a3 = ukk(ab, ac, cost-1) + 1;
        if(a3 &gt; a2)
	{
          a2 = a3;
          *prevcost = cost-1;
	}
      }
    break;
  }
  return a2;
}

void traceback(int ab, int ac, int cost)
{
  int a, a2, b, c, da, db, dc, ab2, ac2;
  int prevcost, pc, choice, nn, neighbour, i;

  a = -infinity;
  choice = 0;

  for(nn=0;nn&lt;7;nn++)
  {
    neighbour = ncode[nn];
    da = neighbour / 4;
    db = (neighbour / 2) % 2;
    dc = neighbour % 2;
    a2 = step(a, ab-da+db, ac-da+dc, cost-1, da, db, dc, &amp;pc);
    if(a2 &gt; a || (a2 &gt;= a &amp;&amp; 
		  (choice == 1 || choice == 2 || choice == 4) &amp;&amp; 
		  (neighbour == 3 || neighbour == 5 || neighbour == 6)) )
    {
      a = a2;
      choice = neighbour;
      prevcost = pc;
    }
    a = max2(0, a);
    b = a - ab;
    c = a-ac;

    da = choice / 4;
    db = (choice / 2) % 2;
    dc = choice % 2;
    ab2 = ab-da+db;
    ac2 = ac-da+dc;
   
    if(a &gt; 1 || b &gt; 1 || c &gt; 1)
      traceback(ab2, ac2, prevcost);
    if(a+b+c &gt; 0)
    {
      showtriple(a*da, b*db, c*dc);
    }
    for(i=0;i&lt;ukk(ab, ac, cost);i++)
      showtriple(a+i, b+i, c+i);
  }
}

void showU(int ***array)
{
}

int triple(int a, int b, int c)
{
  char ach, bch,  cch;
  int ans;

  ach = As[a];
  bch = Bs[b];
  cch = Cs[c];

  if(ach == bch)
  {
    if(ach == cch)
      ans = 0;
    else
      ans = 1;
  }
  else
  {
    if(ach == cch || bch == cch)
      ans = 1;
    else
      ans = 2;
  }
  return ans;
}

void showtriple(int a, int b, int c)
{
  printf(&quot;%c %c %c\n&quot;, 
   a &gt;= 0 ? As[a] : &apos;-&apos;, 
   b &gt;= 0 ? Bs[b] : &apos;-&apos;, 
   c &gt;= 0 ? Cs[c] : &apos;-&apos;);
}

int max7(int a, int b, int c, int d, int e, int f, int g)
{
  return max2(max2(max2(a, b), max2(c, d)), max2(max2(e, f), g)); 
}
 
int max2(int a, int b)
{
  return a &gt; b ? a : b;
}

int main(void)
{
}

			</file>
			<file name="align3.c" type="text">
char **align3(char *s1, char *s2, char *s3)
{
  
}

typedef struct
{
  char *s1;
  char *s2;
  char *s3;
  char *a12;
  char *a21;
  char *a13;
  char *a31;
  char *a23;
  char *a32;
  int s1i;
  int s2i;
  int s3i;
  int a12i;
  int a21i;
  int a13i;
  int a31i;
  int a23i;
  int a32i;

  char *out1;
  char *out2;
  char *out3;
} STATUS;

STATUS *createstatus()
{
}

void killstatus(STATUS *s)
{
}

int status_step(STATUS *st)
{
  int gap;
  gap = st_gapstate(st);

  switch(gap)
  {
  case 0:
    st_advance(st, 7);
    break;
  case 1:
    st_advance(st, 6);
    break;
  case 2:
    st_advance(st, 5);
    break;
  case 3:
    st_advance(st, 4);
    break;
  case 4:
    st_advance(st, 3);
    break;
  case 5:
    st_advance(st, 2);
    break;
  case 6:
    st_advance(st, 1);
    break;
  case 7:
    st_advance(st, 7);
    break; 
  }
  return 0;
}

void st_advance(STATUS *st, int fields)
{
  int advance12 = 0;
  int advance13 = 0;
  int advance32 = 0;

  if(fields &amp; 0x01)
  {
    st-&gt;out1[st-&gt;outi] = st-&gt;s1[st-&gt;s1i]
  }
  else
  {
    if(st-&gt;a12[st-&gt;a12i] == &apos;?&apos; || st-&gt;s13[st-&gt;a13i] == &apos;?&apos;)
      st-&gt;out1[st-&gt;outi] = &apos;?&apos;;
    else
      st-&gt;out1[st-&gt;outi] = &apos;-&apos;; 
  }
  if(fields &amp; 0x02)
  {
    st-&gt;out2[st-&gt;outi] = st-&gt;s2[st-&gt;s2i];
  }
  else
  {
    if(st-&gt;a21[st-&gt;a21i] == &apos;?&apos; || st-&gt;s23[st-&gt;s23i] == &apos;?&apos;)
      st-&gt;out2[st-&gt;outi] = &apos;?&apos;;
    else
      st-&gt;out[st-&gt;outi] = &apos;-&apos;;
  }

  if(fields &amp; 0x04)
  {
    st-&gt;out3[st-&gt;outi] = st-&gt;s3(st-&gt;s3i];
  }
  else
  {
    if(st-&gt;a31[st-&gt;a31i] == &apos;?&apos; || st-&gt;st32[st-&gt;s32i] == &apos;?&apos;)
      st-&gt;out3[st-&gt;outi] = &apos;?&apos;;
    else
      st-&gt;out3[st-&gt;outi] = &apos;-&apos;;
  }

  if(fields &amp; 0x01 )
  {
    if(is_letter(st-&gt;a12[st-&gt;a12i]))
      advance12 = 1;
    if(is_letter(st-&gt;a13[st-&gt;a13i]))
      advance13 = 1;  
  }
  if(fields &amp; 0x02)
  {
    if(is_letter[st-&gt;a21[st-&gt;a21i]))
      advance12 = 1;
    if(is_letter[st-&gt;a23[st-&gt;a23i]))
      advance23 = 1;
  }
  if(fields &amp; 0x04)
  {
    if(is_letter[st-&gt;a31[st-&gt;a31i]))
      advance13 =1;
    if(is_letter[st-&gt;a32[st-&gt;a32i]))
      advance 23 = 1;
  }

  if(advance12)
  {
    st-&gt;a12i++;
    st-&gt;a21i++;
  }
  if(advance13)
  {
    st-&gt;a13i++;
    st-&gt;a31i++;
  }
  if(advance23)
  {
    st-&gt;a23i++;
    st-&gt;a32i++;
  }
  st-&gt;outi++;
}


int st_gapstate(STATUS *st)
{
  int gap1, gap2, gap3;

  gap1 = is_letter(st-&gt;a12[st-&gt;a12i]) &amp;&amp; is_letter(st-&gt;a21[st-&gt;a21i]);
  gap2 = is_letter(st-&gt;a13[st-&gt;a13i]) &amp;&amp; is_letter(st-&gt;s31[st-&gt;s31i]);
  gap3 = is_letter(st-&gt;a23[st-&gt;a32i]) &amp;&amp; is_letter(st-&gt;s32[st-&gt;a32i]);

  return (gap3 &lt;&lt; 2) | (gap2 &lt;&lt; 1) | gap1;
}

char *lastalignment(char *s1, char *s2, char *s3, char *a12, char *a21,
		    char *a13, char *a31, char *a23, char *a32)
{
  int p1, p2, p3;
  int pa12, pa13, pa23;
  
  gapstate = gapstate(a12[pa12], a21[pa12], a13[pa13], a31[pa31], a23[pa23], a32[pa23]);
  switch(gapstate)
  {
  case 0:  /* no gaps */
    a[0][p] = a12[pa12]; 
    a[1][p] = a21[pa12];
    a[2][p] = a13[pa13];
    pa12++;
    pa13++;
    pa23++;
    break;
  case 1: 
  case 2:
  case 3: /* gap in alignment 12 and 13, but not in 23 */
    do
    {
      a1[p] = &apos;-&apos;;
      a2[p] = a23[p]
    }
    while(gapstate == 3);  
  case 4:
  case 5:
  case 6: 
    break;
  case 7: /*all gaps */
    a[0][p] = a12[pa12]; 
    a[1][p] = a21[pa12];
    a[2][p] = a13[pa13];
    pa12++;
    pa13++;
    pa23++;
    break;
  }
  p++;
 
   
}  

int gapstate(char a12, char a21, char a13, char a31, char a23, char a32)
{
  int gap1;
  int gap2;
  int gap3;
  
  gap1 = is_letter(a12) &amp;&amp; is_letter(a21) ? 0 : 1;
  gap2 = is_letter(a13) &amp;&amp; is_letter(a31) ? 0 : 1;  
  gap3 = is_letter(a23) &amp;&amp; is_letter(a32) ? 0 : 1;

  return (gap3 &lt;&lt; 2) | (gap2 &lt;&lt; 1) | (gap1);
}

static int is_letter(int ch)
{
  return ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;z&apos;; 
}

			</file>
			<file name="fasta.c" type="text">
/*
  fasta.c

  code for loading a fasta format file
 */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;assert.h&gt;

#include &quot;fasta.h&quot;

static void assigntypes(FASTA *fa);
static void fixuplengths(FASTA *fa);
static int seqprotein(char *str);
static int seqnucleic(char *str);
static void filterspaceanddigits(char *str);
static int strcount(char *str, int ch);
static char *readline(FILE *fp);

/*
  load a fasta file by name
  Params: fname - name of file to load
          err - return for error code (can be 0)
  Returns: loaded object, 0 on fail 
  Notes: errors 0 OK
                -1 out of memory
                -2 can&apos;t open file
                -3 parse error
         
 */
FASTA *loadfasta(char *fname, int *err)
{
  FILE *fp;
  int error;
  FASTA *answer;

  fp = fopen(fname, &quot;r&quot;);
  if(!fp)
  {
    error = -2;
    printf(&quot;Not opened\n&quot;);
    goto error_exit; 
  }
  answer = floadfasta(fp, &amp;error);
  if(!answer)
    goto error_exit;

  fclose(fp);
  if(err)
    *err = 0;
  return answer;

 error_exit:
  if(fp)
    fclose(fp);
  if(err)
    *err = error;
  return 0;
}

/*
  load fasta file from a opened stream
  Params: fp - pointer to open file
          err - return pointer for error
  Returns: loaded object

*/
FASTA *floadfasta(FILE *fp, int *err)
{
  FASTA *answer;
  FASTASEQ *temp;
  int error;
  char *line;
  int len;
  char *ptr;

  answer = malloc(sizeof(FASTA));
  if(!answer)
  {
    error = -1;
    goto error_exit;
  }
  answer-&gt;N = 0;
  answer -&gt;fs = 0;

  while(line = readline(fp))
  {
    /* header */
    if(line[0] == &apos;&gt;&apos;)
    {
      temp = realloc(answer-&gt;fs, (answer-&gt;N + 1) * sizeof(FASTASEQ));
      if(!temp)
      {
        error = -1;
        goto error_exit;
      }
      answer-&gt;fs = temp;
      answer-&gt;fs[answer-&gt;N].header = line;
      answer-&gt;fs[answer-&gt;N].comment = 0;
      answer-&gt;fs[answer-&gt;N].seq = 0;
      answer-&gt;fs[answer-&gt;N].seqlen = 0;
      answer-&gt;fs[answer-&gt;N].gappedlen = 0;
      answer-&gt;N++;
    }
    else if(line[0] == &apos;;&apos;)
    {
      if(answer-&gt;N)
      {
        if(answer-&gt;fs[answer-&gt;N-1].comment == 0)
          answer-&gt;fs[answer-&gt;N-1].comment = line;
        else
	{
          len = strlen(answer-&gt;fs[answer-&gt;N-1].comment);
          len += strlen(line);
          ptr = malloc(len + 3);
          if(!ptr)
	  {
            error = -1;
            goto error_exit;
	  }
          strcpy(ptr, answer-&gt;fs[answer-&gt;N-1].comment);
          strcat(ptr, &quot;\n&quot;);
          strcat(ptr, line);
          strcat(ptr, &quot;\n&quot;);
          free(line);
          free(answer-&gt;fs[answer-&gt;N-1].comment);
          answer-&gt;fs[answer-&gt;N-1].comment = ptr;
	}
      }
    }
    else
    {
      if(answer-&gt;N)
      {
        filterspaceanddigits(line);
        if(answer-&gt;fs[answer-&gt;N-1].seq == 0)
	{
          answer-&gt;fs[answer-&gt;N-1].seq = line;
	  answer-&gt;fs[answer-&gt;N-1].seqlen = strlen(line);
        }
        else
	{
          len = answer-&gt;fs[answer-&gt;N-1].seqlen;
          len += strlen(line);
          ptr = malloc(len+1);
          if(!ptr)
	  {
            error = -1;
            goto error_exit;
	  }
          strcpy(ptr, answer-&gt;fs[answer-&gt;N-1].seq);
          strcat(ptr, line);
          free(line);
          free(answer-&gt;fs[answer-&gt;N-1].seq);
          answer-&gt;fs[answer-&gt;N-1].seq = ptr;
          answer-&gt;fs[answer-&gt;N-1].seqlen = len;
	}
      }
      else
      {
        free(line);
        error = -3;
        goto error_exit;
      }
    }   
  } 
  if(!feof(fp))
  {
    error = -1;
    goto error_exit;
  } 

  assigntypes(answer);
  fixuplengths(answer);

  if(err)
    *err = 0;
  return answer;
  
 error_exit:
  if(answer)
    killfasta(answer);
  if(err)
    *err = error;
  return 0;
}

/*
  destroy a fasta file object
  Params: fa - the object to destroy
 */
void killfasta(FASTA *fa)
{
  int i;

  if(fa)
  {
    if(fa-&gt;fs)
    {
      for(i=0;i&lt;fa-&gt;N;i++)
      {
        free(fa-&gt;fs[i].header);
	free(fa-&gt;fs[i].comment);
        free(fa-&gt;fs[i].seq);
      }
      free(fa-&gt;fs);
    }
    free(fa);
  }
}

/*
  get the number of sequences in the file
  Params: fa - the fasta object
  Returns: number of sequences

 */
int fasta_getNsequences(FASTA *fa)
{
  return fa-&gt;N;
}
/*
  retrieve an ungapped sequence from a fasta file
  Parmas: fa - the fasta object
          index - index of sequence to retrieve
          out - buffer to receive sequence
 */
void fasta_getsequence(FASTA *fa, int index, char *out)
{
  int i;

  assert(index &gt;= 0 &amp;&amp; index &lt; fa-&gt;N);

  for(i=0;fa-&gt;fs[index].seq[i];i++)
  {
    if(fa-&gt;fs[index].seq[i] != &apos;-&apos;)
      *out++ = fa-&gt;fs[index].seq[i];
  }
  /* knock off trailing * terminator */
  if(i &gt; 0 &amp;&amp; *(out-1) == &apos;*&apos;)
    out--;
  *out = 0;
}

/*
  retrieve sequence from afasta file, preserving gaps (-)
  Params: fa - the fasta object
          index - index of sequence to retrieve
          out - buffer to receive sequence
 */
void fasta_getgappedsequence(FASTA *fa, int index, char *out)
{
  assert(index &gt;= 0 &amp;&amp; index &lt; fa-&gt;N);
  strcpy(out, fa-&gt;fs[index].seq);
}

/*
  get the length of a sequence (excluding gaps)
  Params: fa - the fasta object
          index - index of sequence
  Returns: length of sequence
 */
int fasta_getlength(FASTA *fa, int index)
{
  assert(index &gt;= 0 &amp;&amp; index &lt; fa-&gt;N);
  
  return fa-&gt;fs[index].seqlen;
}

/*
  get the length of a sequence, including gaps
  Params: fa - the fata object
          index - index of object   
  Returns: length of the gapped sequence
 */
int fasta_getgappedlength(FASTA *fa, int index)
{
  assert(index &gt;= 0 &amp;&amp; index &lt; fa-&gt;N);

  return fa-&gt;fs[index].gappedlen;
}

/*
  get type of sequence
  Params: fa - the fasta object
          index - index of sequence
  Returns: type of sequence it is, DNA, RNA, Protein
  Notes: have to assign intelligently
 */
int fasta_gettype(FASTA *fa, int index)
{
  assert(index &gt;= 0 &amp;&amp; index &lt; fa-&gt;N);

  return fa-&gt;fs[index].type;
}




/*
  intelligently work out type 
 */
static void assigntypes(FASTA *fa)
{
  int i;
  int ii;
  int protein;
  int nucleic;
  int dna;
  int rna;
  int extended;

  for(i=0;i&lt;fa-&gt;N;i++)
  {
    protein = seqprotein(fa-&gt;fs[i].seq);
    nucleic = seqnucleic(fa-&gt;fs[i].seq);
    fa-&gt;fs[i].type = FASTA_UNKNOWN;
    if(!protein &amp;&amp; !nucleic)
      fa-&gt;fs[i].type = 0;
    if(protein)
    {
      for(ii=0;ii&lt;fa-&gt;fs[i].seqlen;ii++)
        if(strchr(&quot;BUZX*&quot;, fa-&gt;fs[i].seq[ii]))
	{
          fa-&gt;fs[i].type = FASTA_XPROTEIN; 
          break;
        }
      if(ii == fa-&gt;fs[i].seqlen)
        fa-&gt;fs[i].type = FASTA_PROTEIN;
     
      /* if are canonical with trailing *, it is normal protein */
      if(ii == fa-&gt;fs[i].seqlen -1 &amp;&amp; fa-&gt;fs[i].seq[ii] == &apos;*&apos;)
        fa-&gt;fs[i].type = FASTA_PROTEIN;
    }
    if(nucleic)
    {
      rna = 0;
      dna = 0;
      extended = 0;

      for(ii=0;ii&lt;fa-&gt;fs[i].seqlen;ii++)
      {
        if(fa-&gt;fs[i].seq[ii] == &apos;U&apos;)
          rna = 1;
        if(fa-&gt;fs[i].seq[ii] == &apos;T&apos;)
          dna = 1;
        if(!strchr(&quot;ACGTU-&quot;, fa-&gt;fs[i].seq[ii]))
          extended = 1;
      }
      if(protein == 1 &amp;&amp; dna == 1 &amp;&amp; rna == 1)
      {
        /* it&apos;s a protein that looks like DNA/RNA */
      }
      /* if we are both a protein and an extende, flag as unknown */
      else if(protein == 1 &amp;&amp; extended == 1)
        fa-&gt;fs[i].type = 0; 
      else if( dna == 1 &amp;&amp; rna == 0 &amp;&amp; extended == 0)
        fa-&gt;fs[i].type = FASTA_DNA;
      else if( rna == 1 &amp;&amp; dna == 0 &amp;&amp; extended == 0)
        fa-&gt;fs[i].type = FASTA_RNA;
      else if(dna == 1 &amp;&amp; extended == 1 &amp;&amp; rna == 0)
        fa-&gt;fs[i].type = FASTA_XDNA;
      else if(rna == 1 &amp;&amp; extended == 1 &amp;&amp; dna == 0)
        fa-&gt;fs[i].type = FASTA_XRNA;
      else
        fa-&gt;fs[i].type = 0; /* dna/rna mix */
    }
  }
}

/*
  adjust the legnths to account for gaps
  Params: fa - fasta object
 */
static void fixuplengths(FASTA *fa)
{
  int i;
  int gaps;

  for(i=0;i&lt;fa-&gt;N;i++)
  {
    gaps = strcount(fa-&gt;fs[i].seq, &apos;-&apos;);
    fa-&gt;fs[i].gappedlen = fa-&gt;fs[i].seqlen;
    fa-&gt;fs[i].seqlen -= gaps;
    /* knock off trailing &apos;*&apos; */
    if(fa-&gt;fs[i].seqlen &gt; 0 &amp;&amp; fa-&gt;fs[i].seq[fa-&gt;fs[i].seqlen-1] == &apos;*&apos;)
      fa-&gt;fs[i].seqlen--;
  }
}

/*
  is the sequence a valid protein ?
 */
static int seqprotein(char *str)
{
  while(*str)
    if(!strchr(&quot;ABCDEFGHIKLMNPQRSTUVWYZX*-&quot;, *str++))
      return 0;
  return 1;
}

/*
  is the sequence a valid nucleic acid ?
 */
static int seqnucleic(char *str)
{
  while(*str)
    if(!strchr(&quot;ACGTURYKMSWBHVN-&quot;, *str++))
      return 0;
 
  return 1;
}

/*
  filter out whitespace and digits, 
   also put characters into upper case#
  Params: str - string to filter
 */
static void filterspaceanddigits(char *str)
{
  char *wptr;
  char *rptr;

  wptr = str;
  rptr = str;
  do
  {
    if(!isspace(*rptr) &amp;&amp; !isdigit(*rptr))
    {
      *wptr++ = toupper(*rptr);
    }
  } while(*rptr++);

}

/*
  count the instances * character in string
  Params: str - the string
          ch - the character to test
  Returns: no times ch appears in str 
 */
static int strcount(char *str, int ch)
{
  int answer = 0;
  
  while(*str)
  {
    if(*str++ == ch)
      answer++;
  }

  return answer;
}

/*
  readline()  read  aline from an input file
Params:  pointer to an opened file
Returns: line read up to newline, 0 on out-of-memory or EOF.
Notes: trailing newline stripped. Return allocated with malloc().
*/
static char *readline(FILE *fp)
{
  char *buff;
  int nread = 0;
  int buffsize = 128;
  int ch;
  char *temp;

  buff = malloc(128);
  if(!buff)
    return 0;
  
  while((ch = fgetc(fp)) != &apos;\n&apos;)
  {
    if(ch == EOF)
    {
      if(nread == 0)
	{
          free(buff);
          return 0;
	}
      break;
    }

    buff[nread] = (char) ch;
    nread++;
    if(nread == buffsize - 1)
    {
      temp = realloc(buff, buffsize + 64);
      if(!temp)
      {
        free(buff);
        return 0;
      }   
      buff = temp;
      buffsize += 64;
    }
  }

  buff[nread] = 0;
  return buff;
}


int fastamain(int argc, char **argv)
{
  int i;
  int ii;
  FASTA *fasta;
  char seq[2048];
  int error;

  for(i=1;i&lt;argc;i++)
  {
    fasta = loadfasta(argv[i], &amp;error);
    if(!fasta)
    {
      printf(&quot;Error %d\n&quot;, error);
      exit(EXIT_FAILURE);
    }
    printf(&quot;%d sequences\n&quot;, fasta-&gt;N);
    for(ii=0;ii&lt;fasta-&gt;N;ii++)
    {
      switch(fasta-&gt;fs[ii].type)
      {
      case FASTA_UNKNOWN:
        printf(&quot;Unknown type &quot;);
        break;
      case FASTA_DNA:
        printf(&quot;DNA &quot;);
        break;
      case FASTA_RNA:
        printf(&quot;RNA &quot;);
        break;
      case FASTA_PROTEIN:
        printf(&quot;Protein &quot;);
        break;
      case FASTA_XDNA:
        printf(&quot;Extended DNA&quot;);
        break;
      case FASTA_XRNA:
        printf(&quot;Extended RNA&quot;);
        break;
      case FASTA_XPROTEIN:
        printf(&quot;Extended Protein&quot;);
        break;
      default:
        printf(&quot;Error in type &quot;);
        break;
      }
      printf(&quot;length %d\n&quot;, fasta-&gt;fs[ii].seqlen);   
      if(fasta-&gt;fs[ii].seqlen &lt; 2048)
      {
        fasta_getsequence(fasta, ii, seq);
        printf(&quot;%s\n&quot;, seq);
      }
    }
    killfasta(fasta);
  }

  return 0;
}

			</file>
			<file name="testsynteny.c" type="text">

			</file>
			<file name="test.fasta" type="text">
&gt;seq1
GTTTCGTGAGAGATTAACACCCTCGCCTCATAGAAGTGTATGTGGTTCTACCATGCCGCCTTTGAGTAAACGTTAGAAG
ACGTTGCTGATAATGTGTATGCTTCTAGAGTGGCCGAGCTCCGTTTAGAGGCACCACTCACTCACCTAATATCCACCCG
TATCCTCTCTCTCCTACCGTTGAAG
&gt;seq2
GTTTCGTGAGAGAATAACACCTTCGCCTCATAGAAGTTTATGTGGTTCTACCATGCCGCCTTTGAATAAACGTTAGAAG
CCGTTGCTGATAATGTGTATGCTTCTAGACTCGAGTGGCCGAGCTCCGTTTTGCGTAGAGGCACAACTCACTCACCTAA
TATCCACCCGCATCCTATCTCTCCTACCGTTGAAG

			</file>
		</directory>
		<file name="csv.c" type="text">
/*
  csv.c
  code to load a comma-separated value file
  by Malcolm McLean
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;math.h&gt;
#include &lt;float.h&gt; 
#include &lt;assert.h&gt;

#include &quot;csv.h&quot;

static int hasheader(char ***data, int width, int height);
static int getcoltype(char ***data, int col, int width, int height);
static int gettype(const char *str);
static char **loadline(FILE *fp, int *N);
static char *loadfield(FILE *fp);
static char *loadraw(FILE *fp);
static char *loadquote(FILE *fp);
static void striptrail(char *str);
static char *mystrdup(const char *str);
static double makenan(void);
static int myisnan(double x);

/*
  load a csv file.
  Params: fname - the name of the csv file to load.
  Returns: a CSV object, 0 on fail. 
 */
CSV *loadcsv(const char *fname)
{
  CSV *answer;
  int *len = 0;        /* number of records in each line */
  char ***rec = 0;     /* square matrix of records */
  FILE *fp;
  int i = 0;
  int ii;
  int N;              /* number of lines */
  int width = 0;
  int height = 0;
  void *temp;

  answer = malloc(sizeof(CSV));
  if(!answer)
    return 0;
  answer-&gt;data = 0;
  answer-&gt;names = 0;
  answer-&gt;types = 0;

  fp = fopen(fname, &quot;r&quot;);
  if(!fp)
    return 0;

  /* load each row of the csv data */
  do
  {
    temp = realloc(rec, (i+1) * sizeof(char **));
    rec = temp;
    temp = realloc(len, (i+1) * sizeof(int));
    len = temp;
    rec[i] = loadline(fp, &amp;len[i]);
    
    if(len[i] == -2)
      break;
    i++;
  } 
  while(!ferror(fp));
  
  fclose(fp);
  
  /* csv file may contain lines of the wrong length.
     Assume the first line contains the right number of columns.
  */
 
  N = i;
  
  for(i=0;i&lt;N;i++)
  {
    /* if the line is not the right length, take action against it */
    if(len[i] != len[0])
    {
      /* does the line contain records ? */
      for(ii=0;ii&lt;len[i];ii++)
        if(rec[i][ii])
          break;
      /* if it contains no records, just delete it */
      if(ii == len[i])
      {
        for(ii=0;ii&lt;len[i];ii++)
          free(rec[i][ii]);
        free(rec[i]);
        memmove(&amp;len[i], &amp;len[i+1], (N - i - 1) * sizeof(int));
        memmove(&amp;rec[i], &amp;rec[i+1], (N - i -1) * sizeof(char **));
        N--;
        i--;
      }
      /* if the bad lline contains records, just throw the file out */
      else
      { 
        goto error_exit;
      }
    }
  }

  width = len[0];
  free(len);
  
  /* if the CSV file contains a header, fill data */
  if(hasheader(rec, width, N))
  {
    height = N - 1;
    answer-&gt;types = malloc(width * sizeof(int));
    answer-&gt;names = malloc(width * sizeof(char *));
    answer-&gt;data = malloc(width * height * sizeof(CSV_VALUE));
    if(!answer-&gt;data || !answer-&gt;names || !answer-&gt;types)
      goto error_exit;
    for(i=0;i&lt;width;i++)
    {
      answer-&gt;names[i] = rec[0][i];
      answer-&gt;types[i] = getcoltype(rec + 1, i, width, height);
    }
    for(i=0;i&lt;height;i++)
    {
      for(ii=0;ii&lt;width;ii++)
      {
        switch(answer-&gt;types[ii])
        {
          case CSV_REAL:
            if(rec[i+1][ii])
              answer-&gt;data[i * width + ii].x = strtod(rec[i+1][ii], 0);
            else
              answer-&gt;data[i * width + ii].x = makenan();
            free(rec[i+1][ii]);
            break;
          case CSV_STRING:
            answer-&gt;data[i * width + ii].str = rec[i+1][ii];
            rec[i+1][ii] = 0;
            break;
        }
      }
    }
  }
  /* if no header, fill differently */
  else
  {
    height = N;
    answer-&gt;names = 0;
    answer-&gt;types = malloc(width * sizeof(int));
    answer-&gt;data = malloc(width * height * sizeof(CSV_VALUE));
    if(!answer-&gt;data || !answer-&gt;types)
      goto error_exit;

    for(i=0;i&lt;width;i++)
      answer-&gt;types[i] = getcoltype(rec, i, width, height);

    for(i=0;i&lt;height;i++)
      for(ii=0;ii&lt;width;ii++)
      {
        switch(answer-&gt;types[ii])
	{
          case CSV_REAL:
            if(rec[i][ii])
              answer-&gt;data[i * width + ii].x = strtod(rec[i][ii], 0);
            else
              answer-&gt;data[i * width + ii].x = makenan();
            free(rec[i][ii]);
            break;
          case CSV_STRING:
            answer-&gt;data[i * width + ii].str = rec[i][ii];
            rec[i][ii] = 0;
            break;
	}
      }
  }

  /* clean up temporary records */
  for(i=0;i&lt;N;i++)
    free(rec[i]);
  free(rec); 

  answer-&gt;width = width;
  answer-&gt;height = height;
  
  return answer;
  
  /* clean up and return NULL */
 error_exit:
  for(i=0;i&lt;N;i++)
  {
    if(len)
    {
      for(ii=0;ii&lt;len[i];ii++)
        free(rec[i][ii]);
    }
    else
    {
      for(ii=0;ii&lt;width;ii++)
        free(rec[i][ii]);
    }
    free(rec[i]);
  }
  free(rec);
  free(len);
  
  free(answer-&gt;data);
  free(answer-&gt;names);
  free(answer-&gt;types);
  free(answer);

  return 0;
}

/*
  destructor for csv object
  Params: csv - pointer to object to destroy
 */
void killcsv(CSV *csv)
{
  int i;
  int ii;

  if(!csv)
    return;

  for(i=0;i&lt;csv-&gt;width;i++)
  {
    if(csv-&gt;types[i] == CSV_STRING)
      for(ii=0;ii&lt;csv-&gt;height;ii++)
        free(csv-&gt;data[ii * csv-&gt;width + i].str);
  }
  free(csv-&gt;data);
  free(csv-&gt;types);
  if(csv-&gt;names)
  {
    for(i=0;i&lt;csv-&gt;width;i++)
      free(csv-&gt;names[i]);
  }
  free(csv-&gt;names);

  free(csv);
}

/*
  get the dimensions of a CSV object
  Params: CSV - the comma-separated data
          width - return pointer for no columns
          height - return pointer for no rows (excl header)
 */
void csv_getsize(CSV *csv, int *width, int *height)
{
  *width = csv-&gt;width;
  *height = csv-&gt;height;
}

/*
  is a data element present
  Params: csv - pointer tot he object
          col - coumn to test
          row - row to test
  Returns: 1 if data present for that object, else 0
 */
int csv_hasdata(CSV *csv, int col, int row)
{
  if(col &lt; 0 || col &gt;= csv-&gt;width)
    return 0;
  if(row &lt; 0 || row &gt;= csv-&gt;height)
    return 0;
  switch(csv-&gt;types[col])
  {
    case CSV_REAL:
      if(myisnan(csv-&gt;data[row * csv-&gt;width + col].x))
        return 0;
      return 1;
    case CSV_STRING:
      if(csv-&gt;data[row * csv-&gt;width + col].str == 0)
        return 0;
      return 1;
    default:
      return 0;
  }
  return 0;
}

/*
  get numerical data
  Params: csv - pointer to the object
          col - column of data item
          row - row of data item
  Returns: value of data item.          
 */
double csv_get(CSV *csv, int col, int row)
{
  assert(col &gt;= 0 &amp;&amp; col &lt; csv-&gt;width);
  assert(row &gt;= 0 &amp;&amp; row &lt; csv-&gt;height);
  assert(csv-&gt;types[col] == CSV_REAL);
 
  return csv-&gt;data[row * csv-&gt;width + col].x;
}

/*
  get string data
  Params: csv - pointer to the object
          col - column of data item
          row - row of data item
  Returns: pointer to string data item.
 */
const char *csv_getstr(CSV *csv, int col, int row)
{
  assert(col &gt;= 0 &amp;&amp; col &lt; csv-&gt;width);
  assert(row &gt;= 0 &amp;&amp; row &lt; csv-&gt;height);
  assert(csv-&gt;types[col] == CSV_STRING);

  return csv-&gt;data[row * csv-&gt;width + col].str;
}

/*
  test if comma-separted values contains header row
  Params: csv - pointer to the object
  Returns: 1 if header present, 0 if absent
 */
int csv_hasheader(CSV *csv)
{
  return csv-&gt;names ? 1 : 0;
}

/*
  get information about a csv column
  Parmas: csv - pointer to object
          col - colmn to get infromation about
          type - return pointer type of colum (CSV_REAL, CSV_STRING)
  Returns: pointer to column name, NULL if not present
 */
const char *csv_column(CSV *csv, int col, int *type)
{
  if(type)
    *type = csv-&gt;types[col];
  if(csv-&gt;names)
    return csv-&gt;names[col];
  else
    return 0;
}

/*
  tests if the csv file has a header.
  Params: data - the read in data
          width - number of columns
          height - number of rows
  Returns: 1 if the data has a header row, else 0
  Notes: applies a heuristic. If the first has a different type from
    the rest of the data, it is a header.
 */
static int hasheader(char ***data, int width, int height)
{
  int t1;
  int t2;
  int i;
  int ii;

  if(height &lt; 2)
    return 0;
  for(i=0;i&lt;width;i++)
  {
    t1 = gettype(data[0][i]);
    t2 = gettype(data[1][i]);
    
    for(ii=2;ii&lt;height;ii++)
    {
      if(data[ii][i] &amp;&amp; gettype(data[ii][i]) != t2)
        break;
    }
    if(ii == height &amp;&amp; t1 != t2)
      return 1;
  }

  return 0;
}

/*
  get the type of a column
  Params: data - the array of read-in strings
          col - column to test
          width - data width
          height - data height
  Returns: type of that column (CSV_STRING if mixed)
 */
static int getcoltype(char ***data, int col, int width, int height)
{
  int t = CSV_NULL;
  int t2;
  int i;

  assert(col &lt; width);

  for(i=0;i&lt;height;i++)
  {
    t2 = gettype(data[i][col]);
    if(t2 != t)
    {
      if(t == CSV_NULL)
        t = t2;
      if(t == CSV_REAL &amp;&amp; t2 == CSV_STRING)
        t = CSV_STRING;
    }
  }

  return t;
}

/*
  get the type of a field
  Params: str - string containg data
  Returns: the type
    CSV_NULL - no data
    CSV_REAL - numerical data
    CSV_STRING - string data
 */
static int gettype(const char *str)
{
  char *ptr;
  double x;

  if(!str)
    return CSV_NULL;

  x = strtod(str, &amp;ptr);
  if(*ptr == 0)
    return CSV_REAL;
  else
    return CSV_STRING;
}

/*
  load a line (record) from a csv file.
  Params: fp - pointer to an opne file
          N - return pointer for number of fields read
  Returns: malloced list of malloced strings
 */
static char **loadline(FILE *fp, int *N)
{
  char **answer = 0;
  int ch;
  int i = 0;
  char **temp;

  ch = fgetc(fp);
  if(ch == EOF)
  {
    *N = -2;
    return 0;
  }
  ungetc(ch, fp);

  do
  {
    temp = realloc(answer, (i + 1) * sizeof(char *));
    if(!temp)
    {
      while(i &gt;= 0)
        free(answer[i--]);
      free(answer);
      *N = 0;
      return 0;
    }
    answer = temp;
    answer[i] = loadfield(fp);
    i++;
  }
  while(fgetc(fp) == &apos;,&apos;);

  if(i==1 &amp;&amp; answer[0] == 0)
  {
    free(answer);
    *N = 0;
    return 0;
  }
  *N = i;

  return answer;
}
  
/*
  load a field from a csv file.
  Params: fp - pointer to an open file.
  Returns: a field read as a character string
    empty fields are returned as 0
 */
static char *loadfield(FILE *fp)
{
  int ch;
  char *answer = 0;

  while( (ch = fgetc(fp)) != EOF)
  {
    if(ch == &apos;,&apos; || ch == &apos;\n&apos;)
      break;
    if(isspace(ch))
      continue;
    if(ch == &apos;&quot;&apos;)
      answer = loadquote(fp);
    else
    {
      ungetc(ch, fp);
      answer = loadraw(fp);
    }
  }
  ungetc(ch, fp);
  
  return answer;
}

/*
  load a raw (comma-delimited) field from file.
  Params: fp - pointer to open file
  Returns: the field. fp points to delimiter
 */
static char *loadraw(FILE *fp)
{
  char *answer;
  char *temp;
  int len = 64;
  int N = 0;
  int ch;

  answer = malloc(64);
  if(!answer)
    return 0;

  while( (ch = fgetc(fp)) != EOF)
  {
    if(ch == &apos;,&apos; || ch == &apos;\n&apos;)
      break;
    answer[N++] = (char) ch;
    if(N == len -1)
    {
      temp = realloc(answer, len + 128);
      if(!temp)
      {
        free(answer);
        return 0;
      }
      answer = temp;
      len += 128;
    }
  }

  ungetc(ch, fp);
  answer[N] = 0;

  striptrail(answer);
  temp = mystrdup(answer);
  free(answer);

  return temp;
}

/*
  load a quote-delimited field
  Params: fp - pointer to an open file.
  Returns: string loaded, 0 on fail. fp points to character after quote.
  Notes: first quote assumed to be read. On entry fp points to first
    character after the quote.
 */
static char *loadquote(FILE *fp)
{
  char *answer;
  char *temp;
  int len = 64;
  int N = 0;
  int ch;
  int ch2;

  answer = malloc(64);
  if(!answer)
    return 0;

  while( (ch = fgetc(fp)) != EOF)
  {
    if(ch != &apos;&quot;&apos;)
      answer[N++] = (char) ch;
    else
    {
      ch2 = fgetc(fp);
      if(ch2 == &apos;&quot;&apos;)
        answer[N++] = &apos;&quot;&apos;;
      else
      {
        ungetc(ch2, fp);
        break;
      }
      if(N == len -2)
      {
        temp = realloc(answer, len + 128);
        if(!temp)
        {
          free(answer);
          return 0;
        }
        len += 128;
      }
    }
  }

  answer[N] = 0;

  temp = mystrdup(answer);
  free(answer);
  return temp;
}

/*
  strip trailing whitespace from a string.
  Params: str - the string.
  Notes: trailing whitespace set to 0
 */
static void striptrail(char *str)
{
  int len;
  len = strlen(str);
  while(len--)
  {
    if(isspace(str[len]))
      str[len] = 0;
    else
      break; 
  }
}

/*
  duplicate a string.
  Params; str - the string to duplicate
  Returns: malloced pointer to duplicated string, 0 on fail.
 */
static char *mystrdup(const char *str)
{
  char *answer = malloc(strlen(str) + 1);
  if(answer)
    strcpy(answer, str);
  return answer;
}

/*
  create a not-a-number (nan)
  Returns: nan
  Portability warning: no ANSI standard way of generating nan()
 */
static double makenan(void)
{
  return sqrt(-1.0);
}

/*
  check for not-a number
  Params: x - number to check
  returns: 1 if a NAN, else 0.
  Portability warning: not all compliers provide an isnan().
*/
static int myisnan(double x)
{
  return isnan(x);
}

/*
  test function
  Loads a csv file and prints out header.
 */
int csvmain(int argc, char **argv)
{
  CSV *csv = 0;
  int width;
  int height;
  int i;
  int type;
  const char *name;

  if(argc == 2)
    csv = loadcsv(argv[1]);
  if(!csv)
  {
    printf(&quot;Failed\n&quot;);
    exit(EXIT_FAILURE);
  }
  csv_getsize(csv, &amp;width, &amp;height);
  printf(&quot;width %d height %d\n&quot;, width, height);

  for(i=0;i&lt;width;i++)
  {
    name = csv_column(csv, i, &amp;type);
    printf(&quot;%s %s\n&quot;, name, type == CSV_STRING ? &quot;string&quot; : &quot;real&quot;);
  }

  killcsv(csv);

  return 0;
}

		</file>
		<file name="pdbutils.c" type="text">
/*
  tools for building pdb files
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;time.h&gt;
#include &lt;ctype.h&gt;

#include &quot;aminogeom.h&quot;

char *pdbdate(void);
void writepdbremark(FILE *fp, const char *str);
void writepdbsequence(FILE *fp, char *seq, char chain);
void writepdbterminator(FILE *fp, int serial, char residue, char chain, int resid, char insertion);
static void writepdbmodel(FILE *fp, int modelid);
void writepdbrecord(FILE *fp, int id, char *name, char res, int resid, float x, float y, float z);
void writepdbatom(FILE *fp, int atomid, char *name, char altloc, char *resname,char chainid, int resid, char insertioncode, float x, float y, float z, float occupancy, float temp, char *segid, char *element, char *charge );
static void writepdbhetrecord(FILE *fp, int id, char *name, char res, int resid, float x, float y, float z);
void writecrystaldata(FILE *fp);


static void pdbWriteHetAtom(char *buf, int atomid, char *name, char altloc, char *resname,char chainid, int resid, char insertioncode, float x, float y, float z, float occupancy, float temp, char *segid, char *element, char *charge );

static void alignname(char *out, char *name);
static void padout(char *str, char ch, int len);
static char *mystrdup(const char *str);


/*
  get the current date in PDB format
  Returns: pointer to date (as static string);
 */
char *pdbdate(void)
{
  static char answer[32];
  char buff[64];
  time_t timer;
  int day;
  int hour;
  int minute;
  int second;
  int year;
  char monthname[32];
  char dayofweek[32];
  int i;

  timer = time(NULL);
  strcpy(buff, asctime(localtime(&amp;timer)));
  sscanf(buff, &quot;%s %s %d %d:%d:%d %d&quot;,
	 dayofweek, monthname, &amp;day, &amp;hour, &amp;minute, &amp;second, &amp;year);

  for(i=0;monthname[i];i++)
    monthname[i] = toupper(monthname[i]);

  sprintf(answer, &quot;% 2d-%s-%02d&quot;, day, monthname, year % 100);

  return answer;
}

/*
  write a remark string, split across as many records as needed
  Params: fp - file to write to
          str - comments
 */
void writepdbremark(FILE *fp, const char *str)
{
    char buff[256];    /* buffer for line */
    const char *ptr;         /* travelling pointer */ 
    const char *lastptr;     /* points to start of line */
    int i;

    strcpy(buff, &quot;REMARK    &quot;);
   
    lastptr = str;
    while(*lastptr)
    {
	/* 60 spaces or a newline */
      for(i=0;i&lt;60;i++)
	    if(lastptr[i] == &apos;\n&apos; || lastptr[i] == 0)
		break;
      ptr = lastptr +  i;
      /* exclude start of word */
      while(ptr &gt; lastptr &amp;&amp; ! isspace(*ptr) &amp;&amp; *ptr != 0)
	ptr--;
      if(ptr == lastptr)
      {
          ptr = strchr(ptr, &apos;\n&apos;);
          if(ptr == 0 || (ptr - lastptr) &gt; 60)
          {
	    if(strlen(lastptr) &lt; 60)
	      ptr = lastptr + strlen(lastptr);
            else
	      ptr = lastptr + 60;
	  }
      }

      /* copy to buffer */
      memcpy(buff + 10, lastptr, ptr - lastptr);
      if(isspace(*(ptr-1)))
	  buff[ptr -lastptr + 10 -1] = &apos; &apos;; 
      buff[ptr-lastptr + 10] = 0;
      padout(buff, &apos; &apos;, 79);
      fprintf(fp, &quot;%s\n&quot;, buff);
      if(ptr == lastptr || isspace(*ptr))
	  ptr++;
      lastptr = ptr;
    }
}

/*
  write a sequence in pdb format
  Params: fp - pointer to file to write
          seq - the sequence, in one letter format, NUL-terminated
          chain - chain id 
 */
void writepdbsequence(FILE *fp, char *seq, char chain)
{
    int N;
    char buff[128];
    int i;
    int ii;
    int Nlines;
    int Nres;
    char name[4];

    N = strlen(seq);
    Nlines = N / 13;
    if(N % 13)
	Nlines++;
    for(i=0;i&lt;Nlines;i++)
    {
	sprintf(buff, &quot;SEQRES %3d %c %4d &quot;, i+1, chain, N);
        if(i &lt; Nlines -1 || (N % 13) == 0 )
	    Nres = 13;
	else
	    Nres = N % 13;
        for(ii=0;ii&lt;Nres;ii++)
        {
	    one2three(name, seq[i*13+ii]);
            strcat(buff, &quot; &quot;);
            strcat(buff, name);
        }
        padout(buff, &apos; &apos;, 79);
        fprintf(fp, &quot;%s\n&quot;, buff);
    }   
}

/*
  write the termination code
  Parmas: fp - pointer to file
          serial - atomid (increment after call)
          residue - residue type (1 letter)
          chain - chain id
          resid - serial number of terminal residue
          insertion - insertion code (?)

 */
void writepdbterminator(FILE *fp, int serial, char residue, char chain, int resid, char insertion)
{
    char buff[256];
    char name[4];

    one2three(name, residue);
    sprintf(buff, &quot;TER   %5d      %s %c%4d%c&quot;, serial, name, chain, resid, insertion);
    padout(buff, &apos; &apos;, 79);
    fprintf(fp, &quot;%s\n&quot;, buff);
}

/*
  write the &quot;model&quot; record
  Params: fp - pointer to file
          modelid - id number of model (1-based)
 */
static void writepdbmodel(FILE *fp, int modelid)
{
    char buff[256];

    sprintf(buff, &quot;MODEL    %4d&quot;, modelid);
    padout(buff, &apos; &apos;, 79);
    fprintf(fp, &quot;%s\n&quot;, buff);
}

/*
  write the &quot;end model&quot; record
  Params: fp - pointer to open file
 */
void writepdbendmodel(FILE *fp)
{
    char buff[256];
    
    strcpy(buff, &quot;ENDMDL&quot;);
    padout(buff, &apos; &apos;, 79);
    fprintf(fp, &quot;%s\n&quot;, buff);
}

/*
  write a pdb atom record
  Params: fp - file to write to
          id - serial number (increment on each call)
          name - atom name
          resname - residue 1 letter id
          resid - residue number
          x - x coordinate, angstroms
          y - y coordinate, angstroms
          z - z coordinate, angstroms
 */
void writepdbrecord(FILE *fp, int id, char *name, char res, int resid, float x, float y, float z)
{
  char fixname[6];
  char resname[4];

  one2three(resname, res);
  alignname(fixname, name);
  writepdbatom(fp, id, fixname, &apos; &apos;, resname, &apos; &apos;, resid, &apos; &apos;, x, y, z, 1.0f, 0.0f, &quot;&quot;, &quot;&quot;, &quot;&quot;);
}

/*
  write a pdb atom record
  Params: fp - output file
          atomid - serial number
          name - atom name, 4 characters justified
          altloc - alternate location ?
          resname - three letter residue name
          chainid - chain id
          resid - residue number
          insertioncode - insertion code ?
          x - x coordinate
          y - y - coordinate
          z - z coordinate
          occupancy - occupancy level (usually 1)
          temp - temperature (usually 0)
          segid - segment id ?
          element - 2 letter element 
          charge - charg ?
  Notes: low-level atom writing function 
 */
void writepdbatom(FILE *fp, int atomid, char *name, char altloc, char *resname,char chainid, int resid, char insertioncode, float x, float y, float z,
float occupancy, float temp, char *segid, char *element, char *charge ) 
{
    char buff[256];
  sprintf(buff, &quot;ATOM  %5d %.4s%c%.3s %c%4d%c   %8.3f%8.3f%8.3f%6.2f%6.2f      %.4s%.2s%.2s&quot;, 
  atomid, name, altloc, resname, chainid,
  resid, insertioncode, x, y, z,
  occupancy,temp, segid, element, charge);
  fprintf(fp, &quot;%s\n&quot;, buff); 
}


/*
  write a het atom record to file
  Params: Params: fp - file to write to
          id - serial number (increment on each call)
          name - atom name
          resname - residue 1 letter id
          resid - residue number
          x - x coordinate, angstroms
          y - y coordinate, angstroms
          z - z coordinate, angstroms
  
 */
static void writepdbhetrecord(FILE *fp, int id, char *name, char res, int resid, float x, float y, float z)
{
	 char buff[256];
         char fixname[6];
         char resname[4];

         alignname(fixname, name);
         one2three(resname, res);
         pdbWriteHetAtom(buff, id, fixname, &apos; &apos;, resname, &apos; &apos;, resid, &apos; &apos;, x, y, z, 1.0f, 0.0f, &quot;&quot;, name, &quot;&quot;);
         fprintf(fp, &quot;%s\n&quot;, buff);
}

/*
  Het atom formatter
 */
static void pdbWriteHetAtom(char *buf, int atomid, char *name, char altloc, char *resname,char chainid, int resid, char insertioncode, float x, float y, float z,
float occupancy, float temp, char *segid, char *element, char *charge ) 
{
  sprintf(buf, &quot;HETATM%5d %.4s%c%.3s %c%4d%c   %8.3f%8.3f%8.3f%6.2f%6.2f      %.4s%.2s%.2s&quot;, 
  atomid, name, altloc, resname, chainid,
  resid, insertioncode, x, y, z,
  occupancy,temp, segid, element, charge); 
}


void writepdbfakecrystaldata(FILE *fp)
{
  fprintf(fp, &quot;%s&quot;,
&quot;CRYST1    1.000    1.000    1.000  90.00  90.00  90.00 P 1           1  1AML 197\n&quot;
&quot;ORIGX1      1.000000  0.000000  0.000000        0.00000                 1AML 198\n&quot;
&quot;ORIGX2      0.000000  1.000000  0.000000        0.00000                 1AML 199\n&quot;
&quot;ORIGX3      0.000000  0.000000  1.000000        0.00000                 1AML 200\n&quot;
&quot;SCALE1      1.000000  0.000000  0.000000        0.00000                 1AML 201\n&quot;
&quot;SCALE2      0.000000  1.000000  0.000000        0.00000                 1AML 202\n&quot;
&quot;SCALE3      0.000000  0.000000  1.000000        0.00000                 1AML 203\n&quot;);
}

/*
  align the atom name properly
  Params: out - return for aligned name (4chars + NUL)
          name - the trimmed name
  Notes: the atom element must be the second character.
 */
static void alignname(char *out, char *name)
{
   if(isdigit(*name))
	strcpy(out,name);
    else
    {
	strcpy(out, &quot; &quot;);
        strcat(out, name);
    }
    while(strlen(out) &lt; 4)
	strcat(out, &quot; &quot;);
}

/*
  left-pad out a string to correct length
  Params: str - the string
          ch - character to pad with
          len - final length of string
 */
static void padout(char *str, char ch, int len)
{
    int pos;
    pos = strlen(str);
    while(pos &lt; len)
	str[pos++] = ch;
    str[pos] = 0;
}

/*
  duplicate a string
  Params: str - the string to duplicate
  Returns: copy in dynamic memory (call free() to destroy)
           0 on out of memory
 */
static char *mystrdup(const char *str)
{
    char *answer;
    answer = malloc(strlen(str) + 1);
    if(answer)
	strcpy(answer, str);
    return answer;
}

int pdbutilsmain(void)
{
    int atomid = 1;

    writepdbremark(stdout, &quot;\n\n\nIn the beginning God created the heavens and the earht, and the earth was without form, and void, and darkness was on the face of the deep. \nAnd God said &apos;Le there be lighht&apos;, and there was light.\nAnf God saw the light, and it was good.\n123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890\n\n\n&quot;);
    writepdbsequence(stdout, &quot;FREDISDEADFREDISDEADFREDISDEADFREDISDEADFREDISDEAD&quot;, &apos;A&apos;);
    writepdbsequence(stdout, &quot;SQISIIMSQISIIM&quot;, &apos;B&apos;);

    writepdbmodel(stdout, 1);
    writepdbrecord(stdout, atomid++, &quot;CA&quot;, &apos;F&apos;, 1, 3.14, 3.14, 1.42); 
    writepdbterminator(stdout, atomid++, &apos;D&apos;, &apos;A&apos;, 50, &apos; &apos;);
    writepdbendmodel(stdout);
    return 0;
}

		</file>
		<directory name="RAFT">
			<file name="anneal.h" type="text">

#ifndef anneal_h
#define anneal_h

/*
  Fairly standard simulate annealing schedule
  Params: obj - the object to minimise
          clone - clone function
          kill - destructor function
          copy - function to copy
          score - the score function
          mutate - move a step
          Nevaluations - number of times to evaluate score function
          ptr - pointer to pass to parameterised functions
 */
int anneal(void *obj, 
           void * (*clone)(void *obj, void *ptr),
           void (*kill)(void *obj, void *ptr), 
           int  (*copy)(void *dest, void *src, void *ptr),
           double (*score) (void *obj, void *ptr),
           void (*mutate) (void *obj, void *ptr),
           int Nevaluations, void *ptr);

#endif

			</file>
			<file name="raft.c" type="text">
/*
  raft.c - 
  version 1.3
  - fixed a bug whereby the non-existent N-terminal backbone ball
     was included. Now excluded from interactions
   - has full steric collision outside of window.
  deliberate bug - window for internal balls one residue too long

  windowing bug taken out
  this version electrostatics fixed but coded out (function returns 0)
 */
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;assert.h&gt;

#include &quot;readinput.h&quot;
#include &quot;raftgeometry.h&quot;

float raftcnf(RAFTGEOMETRY *rg, INPUTPARAMS *ip, int cnf1, int cnf2);

static float rafthbonds(RAFTGEOMETRY *rg, INPUTPARAMS *ip, int cnf1, int cnf2);
static float donortoacceptor(RAFTGEOMETRY *rg, INPUTPARAMS *ip, int donor, int acceptor);
static int getnearestacceptor(RAFTGEOMETRY *rg, int donorcnf, int dres, int acceptorcnf, INPUTPARAMS *ip, float *distij);
float balltoballinternal(RAFTGEOMETRY *rg, INPUTPARAMS *ip, int cnf);
static float balltoballexternal(RAFTGEOMETRY *rg, INPUTPARAMS *ip, int cnf1, int cnf2);
static float internalball(RAFTGEOMETRY *rg, INPUTPARAMS *ip, int iball, int jball, float d);
static float externalball(RAFTGEOMETRY *rg, INPUTPARAMS *ip, int iball, int jball, float d);
static float electrostatic(RAFTGEOMETRY *rg, int iball, int jball, float d);
static float clashenergy(RAFTGEOMETRY *rg, int ida, int idb);
static float vlen(float *a, float *b);
static float vlen2(float *a, float *b);

/*
  run the raft forcefield
  Params: rg - geometry module correctly initialised
          ip - input parameters (read from .inp file)
 */
float raft(RAFTGEOMETRY *rg, INPUTPARAMS *ip)
{
    float answer = 0;
    int Ncnf;
    int i;
    int ii;

    rg_clearhbonds(rg); 
    Ncnf = rg_getNconformers(rg);
;
    for(i=0;i&lt;Ncnf;i++)
    {
	answer += raftcnf(rg, ip, i, i);
        for(ii=0;ii&lt;i;ii++)
	    answer += raftcnf(rg, ip, i, ii);
    }
       
    return answer;
}

/*
  RAFT forcefield, conformers to conformer
  Params: rg - initliased geometry module
          ip -input parameters
          cnf1 - id of first conformer (0-based)
          cnf2 - id of second conformer (0-based)
 */
float raftcnf(RAFTGEOMETRY *rg, INPUTPARAMS *ip, int cnf1, int cnf2)
{
    float hbonden = 0;
    float balls = 0;

    hbonden = rafthbonds(rg, ip, cnf1, cnf2);
   
    if(cnf1 == cnf2)
      balls = balltoballinternal(rg, ip, cnf1);
    else
	balls = balltoballexternal(rg, ip, cnf1, cnf2);

    return hbonden +  balls;
}

/*
  do the hydrogen bonds component of the forcefield
  Params: rg - geometry module
          ip - input parameters
          cnf1 - first conformer
          cnf2 - second conformer
 */
static float rafthbonds(RAFTGEOMETRY *rg, INPUTPARAMS *ip, int cnf1, int cnf2)
{
    float answer = 0;

    if(cnf1 == cnf2)
	answer = donortoacceptor(rg, ip, cnf1, cnf2);
    else
    {
	answer = donortoacceptor(rg, ip, cnf1, cnf2);
        answer += donortoacceptor(rg, ip, cnf2, cnf1);
    }

    return answer;
}

/*
  ball to ball forcefield for same strand
  Params: rg - the geometry module
          ip - input parameters
          cnf - conformer index
 */
float balltoballinternal(RAFTGEOMETRY *rg, INPUTPARAMS *ip, int cnf)
{
    int i;
    int j;
    int ib;
    int jb;
    int Ni;
    int Nj;
    int iball;
    int jball;
    float answer = 0;
    int len;
    int window;
    float maxdist2;
    float d2;

    int flags[1024];
    float minrad;
    /*
    int k;
    float d;
    int Nskip;
    */

    /* residue radii, currently unused */
    /*
    float resrad[20] = {2.9, 3.48, 3.3, 3.93, 4.79, 
                       1.9, 4.36, 4.38, 4.57, 4.44, 
                       4.41, 3.42, 3.44, 4.09, 4.8,
		       3.05, 3.60, 3.91, 5.21, 4.90};
    */
 
    window = ip-&gt;window;
    len = rg_getcnflen(rg, cnf);
    if(window == 0)
	window = len;

    for(i=0;i&lt;len;i++)
      flags[i] = 1;

    /* looping over residues */
    for(i=0;i&lt;len-1;i++)
    {
        Ni = rg_Nballs(rg, cnf, i);
        for(ib=2;ib&lt;Ni;ib++)
        {
	    /* skip backbone ball for N-terminal residue */
	   if(i == 0 &amp;&amp; ib == 2)
	       continue;
           iball = rg_getballid(rg, cnf, i, ib);
           /* calaculete max interaction distance for the ball */
           minrad = 10.84 - 3.42 + rg_rminrs(rg, iball);
           maxdist2 = minrad * minrad;
          
           j = i + window;
           if(j &gt;= len)
	       j = len -1;
          
#if 0
           /* if we are on a backbone ball, exclude distant residues */
           if(ib == 2)
           {
	       k = j;
             
               while(k &gt; i)
               {
		   /* if residue more than 14.42 angstoms away we can exclude it */
                   /* we can also exclude residues near it */
                  jball = rg_getballid(rg, cnf, k, 2);
                  d2 = vlen2(rg-&gt;balls[iball].pos, rg-&gt;balls[jball].pos);
                  if(d2 &gt; 14.42 * 14.42)
                  {
		      d = sqrt(d2);
                      Nskip = (int) ((d - 14.42)/8.0) + 1;
                      while(Nskip--)
			  flags[k--] = 1;
                  }
                  else
		      flags[k--] = 1;
               }
               
           }
#endif
           
           /* now loop over the residues */
	  
           for(j=i+1;j&lt;=i+window &amp;&amp; j &lt; len;j++)
           { 
               if(flags[j])
               {
                   Nj = rg_Nballs(rg, cnf, j);

	           for(jb=2; jb &lt; Nj; jb++)
	           {
                     jball = rg_getballid(rg, cnf, j, jb);
                     d2 = vlen2(rg-&gt;balls[iball].pos, rg-&gt;balls[jball].pos);
                 
                     if(d2 &lt; maxdist2)
		     {
	               answer += internalball(rg, ip, iball, jball, sqrt(d2) );
                     }
	          }
               }
           }

                 
           for(j=i+window+1;j&lt;len;j++)
	   {
             Nj = rg_Nballs(rg, cnf, j);
             for(jb=2;jb &lt; Nj; jb++)
	     {
               jball = rg_getballid(rg, cnf, j, jb);
               answer += clashenergy(rg, iball, jball);
	     }
	   }
      
           /* finally do a rough and ready backbone steric collision test */
           /*
           j = len -1;
           if(ib == 2)
	       while(j &gt; i + window)
               {
                  jball = rg_getballid(rg, cnf, j, 2);
                  d2 = vlen2(rg-&gt;balls[iball].pos, rg-&gt;balls[jball].pos);
                  if(d2 &lt; 25.0f)
		      answer += 2.0f;

	         else if(d2 &gt; 8.0 * 8.0)
		 {
		    Nskip = (int) ( (sqrt(d2) - 5.0) / 8.0);
		    j -= Nskip; 
		}
                  j--;
               } 
	  
	   */
        }
    }

    return answer;
}

static float balltoballexternal(RAFTGEOMETRY *rg, INPUTPARAMS *ip, int cnf1, int cnf2)
{
    int len1;
    int len2;
    int i;
    int j;
    int ib;
    int jb;
    int Ni;
    int Nj;
    int iball;
    int jball;
    float d2;
    float minrad;
    float maxdist2;
    float answer = 0;

    len1 = rg_getcnflen(rg, cnf1);
    len2 = rg_getcnflen(rg, cnf2);

    for(i=0; i&lt; len1; i++)
    {
        Ni = rg_Nballs(rg, cnf1, i);
	for(ib=2;ib&lt;Ni;ib++)
        {
	    /* no N-terminal backbone ball */
	   if(i==0 &amp;&amp; ib == 2)
	       continue;
           iball = rg_getballid(rg, cnf1, i, ib);
           /* calculate max interaction distance for the ball */
           minrad = 10.84 - 3.42 + rg_rminrs(rg, iball);
           maxdist2 = minrad * minrad;
         
	   for(j=0;j&lt;len2;j++)
           {
	       Nj = rg_Nballs(rg, cnf2, j);
	       for(jb=2;jb&lt;Nj;jb++)
               {
		   /* no N-terminal backbone ball */
		  if(j ==0 &amp;&amp; jb == 2)
		      continue;
		  jball = rg_getballid(rg, cnf2, j, jb);
                  d2 = vlen2(rg-&gt;balls[iball].pos, rg-&gt;balls[jball].pos);
                  if(d2 &lt; maxdist2)
		    answer += externalball(rg, ip, iball, jball, sqrt(d2));
               }
            }
          }
       }  

    return answer;
}

/*
  calculate hysrogen bonds 
  Parmas: rg - the geometry
          ip - input parameters
          donor - conor conformer
          acceptor - acceptor conformer
 */
static float donortoacceptor(RAFTGEOMETRY *rg, INPUTPARAMS *ip, int donor, int acceptor)
{
    int donorlen;
    int i;
    int ja;
    int id;
    float flatbo;
    float rminij;
    float ienrs;
    float jenrs;
    float enhbij;
    float distij;
    float answer = 0;
    char isec;
    char jsec;
    int jr;

    donorlen = rg_getcnflen(rg, donor);
    for(i=1;i&lt;donorlen;i++)
    {
        id = rg_getballid(rg, donor, i, 0); 
	ja = getnearestacceptor(rg, donor, i, acceptor, ip, &amp;distij);
       
        if(ja != -1)
        {
            enhbij = 0;
            rminij = rg_rminrs(rg, id) + rg_rminrs(rg, ja);
	    flatbo = rg_nnlenr(rg, id) + rg_nnlenr(rg, ja);
            ienrs = rg_kenres(rg, id);
            jenrs = rg_kenres(rg, ja);
            if(distij &lt; flatbo)
            {
		enhbij = ienrs + jenrs;
                rg_sethdonor(rg, id);
                rg_sethacceptor(rg, ja);
            }
	    else if(distij &lt; rminij)
            {
		enhbij = ((distij-flatbo)/(rminij-flatbo)) * (ienrs+jenrs)-ienrs-jenrs;
                rg_sethdonor(rg, id);
                rg_sethacceptor(rg, ja);
	    }
            jr = rg_residue(rg, ja);
            isec = rg_sectype(rg, donor, i);
            jsec = rg_sectype(rg, acceptor, jr);
            if(isec == &apos;H&apos; &amp;&amp; jsec == &apos;H&apos;)
		enhbij *= ip-&gt;aascal;
            else if(isec == &apos;H&apos; &amp;&amp; jsec == &apos;B&apos;)
                enhbij *= ip-&gt;abscal;
            else if(isec == &apos;H&apos;)
                enhbij *= ip-&gt;oscal;
            else if(isec == &apos;B&apos; &amp;&amp; jsec == &apos;H&apos;)
                enhbij *= ip-&gt;abscal;
            else if(isec == &apos;B&apos; &amp;&amp; jsec == &apos;B&apos;)
                enhbij *= ip-&gt;bbscal;
            else
                enhbij *= ip-&gt;oscal;

            answer += enhbij; 
        }
        if(enhbij == 0)
	    answer += ip-&gt;exhben;
    }

    return answer;
}

/*
  get the nearest acceptor ball
  Parmas: rg - the geometry object
          donorcnf - donor conformer
          acceptorcnf - acceptor conformer
          ip - input parameters
          dist - return for bal distnce;
  Returns: id of acceptor ball, -1 if noe
 */
static int getnearestacceptor(RAFTGEOMETRY *rg, int donorcnf, int dres, int acceptorcnf, INPUTPARAMS *ip, float *distij)
{
    int i;
    float bestd2 = 10000;
    float d2;
    int len;
    int starti;
    int endi;
    int answer = -1;
    int iddonor;
    int idacceptor;

    iddonor = rg_getballid(rg, donorcnf, dres, 0);
    len = rg_getcnflen(rg, acceptorcnf);
    if(ip-&gt;window)
    {
	starti = dres - ip-&gt;window;
        if(starti &lt; 0)
	    starti = 0;
        endi = dres + ip-&gt;window;
        if(endi &gt; len - 2)
	    endi = len - 2;
    }
    else
    {
      starti = 0;
      endi = len - 2;
    }
   
    for(i=starti;i&lt;=endi;i++)
    {
        if(donorcnf == acceptorcnf)
        {
	    if( abs(i - dres) &lt;= ip-&gt;iexseq )
		continue;
	}
        idacceptor = rg_getballid(rg, acceptorcnf, i, 1);
	d2 = vlen2(rg-&gt;balls[iddonor].pos, rg-&gt;balls[idacceptor].pos);
        if(d2 &lt; bestd2)
        {
	    bestd2 = d2;
            answer = idacceptor;
	}
    }
    *distij = sqrt(bestd2);

    return answer;
}

/*
  calculate ball energy
 */
static float internalball(RAFTGEOMETRY *rg, INPUTPARAMS *ip, int iball, int jball, float d)
{
    float answer = 0;
    char itype;
    char jtype;
    int ir;
    int jr;
    float hard;
    float slope;
    float rminij;
    float nnlen;
    float ienrs;
    float jenrs;
    float nplen;
  
    itype = rg_balltype(rg, iball);
    jtype = rg_balltype(rg, jball);

    rminij = rg_rminrs(rg, iball) + rg_rminrs(rg, jball);

    if(itype == &apos;B&apos; || jtype == &apos;B&apos;)
    {
        ir = rg_residue(rg, iball);
        jr = rg_residue(rg, jball);
        if(ir == jr -1)
          answer = 0;
        else if(itype == &apos;B&apos; &amp;&amp; jtype == &apos;B&apos;)
	{
	    answer = clashenergy(rg, iball, jball);
        }
	else if(itype == &apos;B&apos; &amp;&amp; jtype == &apos;N&apos; &amp;&amp; ir != 0)
        {
	    answer = clashenergy(rg, iball, jball);
        }
        else if(itype == &apos;B&apos; &amp;&amp; jtype == &apos;P&apos; &amp;&amp; ir != 0)
        {
	    answer = clashenergy(rg, iball, jball);
	}
        else if(itype == &apos;N&apos; &amp;&amp; jtype == &apos;B&apos;)
        {
	    answer = clashenergy(rg, iball, jball);
        }
        else if(itype == &apos;P&apos; &amp;&amp; jtype == &apos;B&apos;)
        {
	    answer = clashenergy(rg, iball, jball);
        }
    }
    else if(itype == &apos;P&apos; &amp;&amp; jtype == &apos;P&apos;)
    {
      if(d &gt; rminij)
        answer = electrostatic(rg, iball, jball, d);
    }
    else if(itype == &apos;N&apos; &amp;&amp; jtype == &apos;N&apos;)
    {
	/* hydrophobic - hydrophibic */
        nnlen = (rg_nnlenr(rg, iball) + rg_nnlenr(rg, jball)) * 0.5;
        ienrs = rg_kenres(rg, iball);
        jenrs = rg_kenres(rg, jball);
        if( d &lt; rminij)
	{
	    hard = (rg_hardrs(rg, iball) + rg_hardrs(rg, jball)) * 0.5;
            slope = - (hard + ienrs + jenrs)/rminij;
            answer = d * slope + hard;   
        }
        else if(d &lt; rminij + nnlen)
        {
	    slope = (ienrs + jenrs)/nnlen;
            answer = slope * (d - rminij) - (ienrs + jenrs);
        } 
    }
    else if(itype == &apos;P&apos; &amp;&amp; jtype == &apos;N&apos;)
    {
        nplen = rg_nplenr(rg, iball);
        ienrs = rg_kenres(rg, iball);
        jenrs = rg_kenres(rg, jball);
        if( d &lt; rminij)
        {
            hard = (rg_hardrs(rg, iball) + rg_hardrs(rg, jball)) * 0.5;
            slope = - (hard - (jenrs - ienrs))/rminij;
            answer = d * slope + hard;
        }
        else if(d &lt; rminij + nplen)
        {
	    slope = - (jenrs - ienrs)/nplen;
            answer = slope * (d - rminij) + (jenrs - ienrs);
        }
    }
    else if(itype == &apos;N&apos; &amp;&amp; jtype == &apos;P&apos;)
    {
        nplen = rg_nplenr(rg, jball);
        ienrs = rg_kenres(rg, iball);
        jenrs = rg_kenres(rg, jball);
        if( d &lt; rminij)
        {
	    hard = (rg_hardrs(rg, iball) + rg_hardrs(rg, jball)) * 0.5;
            slope = - (hard - (ienrs - jenrs))/rminij;
            answer = d * slope + hard;
	}
        else if(d &lt; rminij + nplen)
        {
	    slope = - (ienrs - jenrs)/nplen;
            answer = slope * (d - rminij) + (ienrs - jenrs);
        }
    }
    else if(itype == &apos;D&apos; &amp;&amp; jtype == &apos;N&apos;)
    {
	if(!rg_gethdonor(rg, ir))
        {
	    nplen = rg_nplenr(rg, iball);
            if(d &lt; nplen + rminij)
            {
		slope = ip-&gt;pinten/(nplen + rminij);
	        answer = slope * d;
            } 
    
        }
    }
    else if(itype == &apos;A&apos; &amp;&amp; jtype == &apos;N&apos;)
    {
        if(!rg_gethacceptor(rg, ir))
        {
	    nplen = rg_nplenr(rg, iball);
            if(d &lt; nplen + rminij)
            {
		slope = ip-&gt;pinten/(nplen + rminij);
	        answer = slope * d;
            } 
        }
    }

    return answer;
     
}

/*
  calculate ball energy
  virtually the same as internal energy except don&apos;t exclde adjacent
  backbone balls and exclude both ir and jr == 0 for backbone clash.
 */
static float externalball(RAFTGEOMETRY *rg, INPUTPARAMS *ip, int iball, int jball, float d)
{
    float answer = 0;
    char itype;
    char jtype;
    int ir;
    int jr;
    float hard;
    float slope;
    float rminij;
    float nnlen;
    float ienrs;
    float jenrs;
    float nplen;
  
    itype = rg_balltype(rg, iball);
    jtype = rg_balltype(rg, jball);

    rminij = rg_rminrs(rg, iball) + rg_rminrs(rg, jball);

    if(itype == &apos;B&apos; || jtype == &apos;B&apos;)
    {
        ir = rg_residue(rg, iball);
        jr = rg_residue(rg, jball);

        if(itype == &apos;B&apos; &amp;&amp; jtype == &apos;B&apos;)
	    answer = clashenergy(rg, iball, jball);
	else if(itype == &apos;B&apos; &amp;&amp; jtype == &apos;N&apos; &amp;&amp; ir != 0)
        {
	    answer = clashenergy(rg, iball, jball);
        }
        else if(itype == &apos;B&apos; &amp;&amp; jtype == &apos;P&apos; &amp;&amp; ir != 0)
        {
	    answer = clashenergy(rg, iball, jball);
	}
        else if(itype == &apos;N&apos; &amp;&amp; jtype == &apos;B&apos; &amp;&amp; jr != 0)
        {
	    answer = clashenergy(rg, iball, jball);
        }
        else if(itype == &apos;P&apos; &amp;&amp; jtype == &apos;B&apos; &amp;&amp; jr != 0)
        {
	    answer = clashenergy(rg, iball, jball);
        }
    }
    else if(itype == &apos;P&apos; &amp;&amp; jtype == &apos;P&apos;)
    {
      if(d &gt; rminij)
        answer = electrostatic(rg, iball, jball, d);
    }
    else if(itype == &apos;N&apos; &amp;&amp; jtype == &apos;N&apos;)
    {
	/* hydrophobic - hydrophibic */
        nnlen = (rg_nnlenr(rg, iball) + rg_nnlenr(rg, jball)) * 0.5;
        ienrs = rg_kenres(rg, iball);
        jenrs = rg_kenres(rg, jball);
        if( d &lt; rminij)
	{
	    hard = (rg_hardrs(rg, iball) + rg_hardrs(rg, jball)) * 0.5;
            slope = - (hard + ienrs + jenrs)/rminij;
            answer = d * slope + hard;   
        }
        else if(d &lt; rminij + nnlen)
        {
	    slope = (ienrs + jenrs)/nnlen;
            answer = slope * (d - rminij) - (ienrs + jenrs);
        } 
    }
    else if(itype == &apos;P&apos; &amp;&amp; jtype == &apos;N&apos;)
    {
        nplen = rg_nplenr(rg, iball);
        ienrs = rg_kenres(rg, iball);
        jenrs = rg_kenres(rg, jball);
        if( d &lt; rminij)
        {
            hard = (rg_hardrs(rg, iball) + rg_hardrs(rg, jball)) * 0.5;
            slope = - (hard - (jenrs - ienrs))/rminij;
            answer = d * slope + hard;
        }
        else if(d &lt; rminij + nplen)
        {
	    slope = - (jenrs - ienrs)/nplen;
            answer = slope * (d - rminij) + (jenrs - ienrs);
        }
    }
    else if(itype == &apos;N&apos; &amp;&amp; jtype == &apos;P&apos;)
    {
        nplen = rg_nplenr(rg, jball);
        ienrs = rg_kenres(rg, iball);
        jenrs = rg_kenres(rg, jball);
        if( d &lt; rminij)
        {
	    hard = (rg_hardrs(rg, iball) + rg_hardrs(rg, jball)) * 0.5;
            slope = - (hard - (ienrs - jenrs))/rminij;
            answer = d * slope + hard;
	}
        else if(d &lt; rminij + nplen)
        {
	    slope = - (ienrs - jenrs)/nplen;
            answer = slope * (d - rminij) + (ienrs - jenrs);
        }
    }
    else if(itype == &apos;D&apos; &amp;&amp; jtype == &apos;N&apos;)
    {
	if(!rg_gethdonor(rg, ir))
        {
	    nplen = rg_nplenr(rg, iball);
            if(d &lt; nplen + rminij)
            {
		slope = ip-&gt;pinten/(nplen + rminij);
	        answer = slope * d;
            } 
    
        }
    }
    else if(itype == &apos;A&apos; &amp;&amp; jtype == &apos;N&apos;)
    {
        if(!rg_gethacceptor(rg, ir))
        {
	    nplen = rg_nplenr(rg, iball);
            if(d &lt; nplen + rminij)
            {
		slope = ip-&gt;pinten/(nplen + rminij);
	        answer = slope * d;
            } 
        }
    }

    return answer;
     
}

/*
  electrostatic energy polar to polar balls
 */
static float electrostatic(RAFTGEOMETRY *rg, int iball, int jball, float d)
{
    float answer = 0;
    float rminij;
    float hard;
    float slope;
    int dir;

    return 0;
    rminij = rg_rminrs(rg, iball) + rg_rminrs(rg, jball);
    if(d &gt; rminij)
    {
      dir = rg_charge(rg, iball) * rg_charge(rg, jball);
      hard = 5;
      slope = -(hard/rminij);
      answer = d * slope + hard;
      answer *= dir;
    }
    return answer;    
}

/*
  clash energy for balls
 */
static float clashenergy(RAFTGEOMETRY *rg, int ida, int idb)
{
    float d;
    float rminij;
    float answer = 0;
    float hard;
    float slope;
   
    d = vlen(rg-&gt;balls[ida].pos, rg-&gt;balls[idb].pos);
    rminij = rg_rminrs(rg, ida) + rg_rminrs(rg, idb);
    if(d &lt; rminij)
     {
	hard = (rg_hardrs(rg, ida) + rg_hardrs(rg, idb)) * 0.5;
        slope = -hard / rminij;
        answer = d * slope + hard;
    }   

    return answer;
}

/*
  length of a vector
 */
static float vlen(float *a, float *b)
{
   return sqrt( (a[0]-b[0])*(a[0]-b[0]) + (a[1]- b[1])*(a[1]-b[1]) + (a[2]-b[2])*(a[2]-b[2]) ); 
}

/*
  squared length of a vector
 */
static float vlen2(float *a, float *b)
{
   return (a[0]-b[0])*(a[0]-b[0]) + (a[1]- b[1])*(a[1]-b[1]) + (a[2]-b[2])*(a[2]-b[2]); 
}

			</file>
			<file name="torsion.h" type="text">
#ifndef torsion_h
#define torsion_h

float calctorsion(float *A, float *B, float *C, float *D);
void puttor(float *D, float *A, float *B, float *C, float len, float theta, float phi);

#endif

			</file>
			<file name="readconformer.c" type="text">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;

#include &quot;readconformer.h&quot;

static void trim(char *str);
static char *getline(FILE *fp);

CONFORMERS *readconformers(char *fname)
{
    FILE *fp;
    CONFORMERS *cs;
    char *angles;
    int N = 0;
    int i;
    int index;

    fp = fopen(fname, &quot;r&quot;);
    if(!fp)
	return 0;
    cs = malloc(sizeof(CONFORMERS));
    if(!cs)
	goto error_exit;
    while(1)
    {
	if( fscanf(fp, &quot;%d\n&quot;, &amp;index) != 1)
	    break;
        if(index != N - 1)
	    goto error_exit;
        cs-&gt;conf = realloc(cs-&gt;conf, (N +1)* sizeof(CONFORMER));
        if(!cs-&gt;conf)
	   goto error_exit;
        cs-&gt;N = N + 1;
        angles = getline(fp);
        if(!angles)
	    goto error_exit;
        trim(angles);
        cs-&gt;conf[N].len = strlen(angles);
        cs-&gt;conf[N].angs = malloc(cs-&gt;conf[N].len * sizeof(int));
        if(!cs-&gt;conf[N].angs)
	    goto error_exit;

        for(i=0;i&lt;cs-&gt;conf[N].len;i++)
	    cs-&gt;conf[N].angs[i] = angles[i] - &apos;0&apos;;
        free(angles);

        if(fscanf(fp, &quot;%lf %lf %lf\n&quot;, &amp;cs-&gt;conf[N].rot[0],
		  &amp;cs-&gt;conf[N].rot[1], &amp;cs-&gt;conf[N].rot[2]) != 3)
	    goto error_exit;
        if(fscanf(fp, &quot;%lf %lf %lf\n&quot;, &amp;cs-&gt;conf[N].trans[0],
		  &amp;cs-&gt;conf[N].trans[1], &amp;cs-&gt;conf[N].trans[2]) != 3)
            goto error_exit;
        N++;
    }
    if(!feof(fp))
	goto error_exit;

 error_exit:
    if(fp)
	fclose(fp);
    killconformers(cs);
    return 0;
}

void killconformers(CONFORMERS *cs)
{
    int i;

    if(cs)
    {
	if(cs-&gt;conf)
        {
	    for(i=0;i&lt;cs-&gt;N;i++)
		free(cs-&gt;conf[i].angs);
            free(cs-&gt;conf);
        }
        free(cs);
    }
}




/*
  trim leading and trailing whitespace from a string
  Params: str - the string to trim
 */
static void trim(char *str)
{
    char *ptr;
    char *ptr2;

    ptr = str;
    while(isspace(*ptr))
	ptr++;
    ptr2 = str;
    while(*ptr)
	*ptr2++ = *ptr++;
    *ptr2 = 0;
    
    while(ptr2-- &gt; str)
    {
	if(isspace(*ptr2))
	    *ptr2 = 0;
        else
	    break;
    }
}


/*
  read a line of text
  Params: fp - pointer to open file
  Returns: line read, NULL on EOF or out of memory
  Notes: return allocated with malloc
 */
static char *getline(FILE *fp)
{
    char *buff;
    int nread = 0;
    int buffsize = 128;
    int ch;
    char *temp;

    buff = malloc(128);
    if(!buff)
	return 0;

    while((ch = fgetc(fp))!=&apos;\n&apos;)
    {
	if(ch == EOF)
        {
	    if(nread == 0)
            {
		free(buff);
                return 0;
	    }
            break;
        }
        buff[nread] = (char) ch;
        nread++;
        if(nread == buffsize-1)
        {
	    temp = realloc(buff, buffsize + 64);
            if(!temp)
            {
		free(buff);
                return 0;
            }
            buff = temp;
            buffsize += 64;
        }
    }
    buff[nread] = 0;
    return buff;
}

			</file>
			<file name="readfff.h" type="text">
#ifndef readfff_h
#define readfff_h


typedef struct{
    char type;            /* ball type */
    float radius;         /* ball radius */
    float vector_pos;     /* ball position along Beta vector */
    float potential;      /* ball potential */
    float hardness;       /* ball hardness */
    float NN_length;      /* nonpolar nonpolar length */
    float NP_length;      /* nonpolar polar length */
    float Rad_factor;     /* radius factor? */
}FFFBALL;

typedef struct{
    FFFBALL *ball;        /* describes balls */
    int Nballs;           /* number of balls */
    char aaid;            /* amino acid */
}FFFRES;

typedef struct{
    int N;                /* number of amino acid types */
    FFFRES *res;          /* residues */
}FORCEFIELDPARAMS;

FORCEFIELDPARAMS *ffp_clone(FORCEFIELDPARAMS *ffp);
void killforcefieldparams(FORCEFIELDPARAMS *ffp);
FORCEFIELDPARAMS *readforcefieldparams(char *fname);

#endif

			</file>
			<file name="readconformerset.h" type="text">
#ifndef readangs_h
#define readangs_h

typedef struct
{
    double omega;            /* omega angle */
    double phi;              /* phi (degrees) */
    double psi;               /* psi (degrees) */
    int id;                  /* identifier (1 based) */
    char secondary;          /* secondary structure type */
} CONFORMERDESC;

typedef struct
{
    char id;                /* Amino acid 1-letter code */
    int Nconformers;        /* number of conformers in angle set */ 
    CONFORMERDESC *conf;        /* the conformers */ 
} AA_CONFSET;

typedef struct 
{
    AA_CONFSET aa_conf[20];     /* 20 conformer sets */
} CONFORMERSET;


CONFORMERSET *readconformerset(char *path);
CONFORMERSET *cset_clone(CONFORMERSET *cs);
void killconformerset(CONFORMERSET *cs);
int getNconformers(CONFORMERSET *cs, char aa);
int getconformer(CONFORMERSET *cs, char aa, int id, float *omega, float *phi, float *psi, char *secondary);
int getconformeri(CONFORMERSET *cs, char aaidx, int id, float *omega, float *phi, float *psi, char *secondary);

#endif

			</file>
			<file name="readinputdata.h" type="text">
#ifndef readinputdata_h
#define readinputdata_h

#include &quot;readinput.h&quot;
#include &quot;readconformerset.h&quot;
#include &quot;readfff.h&quot;
#include &quot;readsequence.h&quot;
#include &quot;readconformer.h&quot;

typedef struct
{
    INPUTPARAMS *ip;          /* input parameters file */
    CONFORMERSET *cfd;        /* descriptors for balls */
    FORCEFIELDPARAMS *ffp;    /* forcefield parameters (balls) */
    SEQUENCE *seq;            /* the sequence */
    CONFORMERS *conf;         /* the conformer */
} INPUTDATA;

INPUTDATA *readinputdata(char *fname);
void killinputdata(INPUTDATA *id);


#endif

			</file>
			<file name="rotmtx.c" type="text">
#include &lt;math.h&gt;
#include &lt;string.h&gt;

void rotmat(double eua, double eub, double eug, double rot[3][3])
{
  double tol = 0.005;
  double ca, sa, cb, sb, cg, sg;
  double rot2[3][3], rot3[3][3], rot4[3][3], rot5[3][3], rot6[3][3];
  double a, b, c, d;


  /* -----Precalculate the sines and cosines of the three rotation angles. */

  ca = cos(eua);
  sa = sin(eua);
  cb = cos(eub);
  sb = sin(eub);
  cg = cos(eug);
  sg = sin(eug);

  /* -----Construct the Rz.Ry rotation matrix. */
  
  rot[0][0] = cb * cg;
  rot[1][0]  = sg;
  rot[2][0] = -sb * cg;
  rot[0][1] = -cb*sg;
  rot[1][1] = cg;
  rot[2][1] = sb * sg;
  rot[0][2] = sb;
  rot[1][2] = 0.0;
  rot[2][2] = cb;
  /* Our next rotation axis is the x&apos; axis (ie column 1 of rot).
     Rotate space about x axis so that the next rotation axis lies in the
      xz plane. Let (a,b,c) be the unit vector along the rotation axis.
  */

  a = rot[0][0];
  b = rot[0][1];
  c = rot[0][2];
  /* Define &apos;d&apos; as the length of the projection of (a,b,c) onto the yz axis.*/
  d = sqrt(b*b + c*c);
  /* If d is zero then (a,b,c) lies along the x axis, so rotation by eua */
  if(d &lt; tol)
  {
    rot6[0][0]=rot[0][0];
    rot6[1][0]=rot[1][0];
    rot6[2][0]=rot[2][0];
    rot6[0][1]=ca*rot[0][1]+sa*rot[0][2];
    rot6[1][1]=ca*rot[1][1]+sa*rot[1][2];
    rot6[2][1]=ca*rot[2][1]+sa*rot[2][2];
    rot6[0][2]=ca*rot[0][2]-sa*rot[0][1];
    rot6[1][2]=ca*rot[1][2]-sa*rot[1][1];
    rot6[2][2]=ca*rot[2][2]-sa*rot[2][1];
  }
  else
  {
    /* Rotate the rotation axis so that it lies in the original xz plane.
       The rotation angle to achieve this is the angle between the projection
       of the rotation axis in the yz plane and the z-axis. This is calculated
       from the scalar product of the z component of the unit vector ra and its
       yz projection (=ra(3)/d). The sin of the angle is determined by 
       considering the vector product (=ra(2)/d).
    */
    /* Apply x rotation to rot. */

      rot2[0][0]=rot[0][0];
      rot2[1][0]=rot[1][0];
      rot2[2][0]=rot[2][0];
      rot2[0][1]=(c/d)*rot[0][1]-(b/d)*rot[0][2];
      rot2[1][1]=(c/d)*rot[1][1]-(b/d)*rot[1][2];
      rot2[2][1]=(c/d)*rot[2][1]-(b/d)*rot[2][2];
      rot2[0][2]=(b/d)*rot[0][1]+(c/d)*rot[0][2];
      rot2[1][2]=(b/d)*rot[1][1]+(c/d)*rot[1][2];
      rot2[2][2]=(b/d)*rot[2][1]+(c/d)*rot[2][2];

      /* Rotate space about the y axis so that the rotation axis lies along the          positive z axis.
       */
      rot3[0][0]=d*rot2[0][0]-a*rot2[0][2];
      rot3[1][0]=d*rot2[1][0]-a*rot2[1][2];
      rot3[2][0]=d*rot2[2][0]-a*rot2[2][2];
      rot3[0][1]=rot2[0][1];
      rot3[1][1]=rot2[1][1];
      rot3[2][1]=rot2[2][1];
      rot3[0][2]=a*rot2[0][0]+d*rot2[0][2];
      rot3[1][2]=a*rot2[1][0]+d*rot2[1][2];
      rot3[2][2]=a*rot2[2][0]+d*rot2[2][2];

      /* Rotate about the z-axis by eua. */
      rot4[0][0]=ca*rot3[0][0]+sa*rot3[0][1];
      rot4[1][0]=ca*rot3[1][0]+sa*rot3[1][1];
      rot4[2][0]=ca*rot3[2][0]+sa*rot3[2][1];
      rot4[0][1]=-sa*rot3[0][0]+ca*rot3[0][1];
      rot4[1][1]=-sa*rot3[1][0]+ca*rot3[1][1];
      rot4[2][1]=-sa*rot3[2][0]+ca*rot3[2][1];
      rot4[0][2]=rot3[0][2];
      rot4[1][2]=rot3[1][2];
      rot4[2][2]=rot3[2][2];

      /* Rotate by the inverse of the y axis rotation matrix defined
         above (step 2).
      */
      rot5[0][0]=d*rot4[0][0]+a*rot4[0][2];
      rot5[1][0]=d*rot4[1][0]+a*rot4[1][2];
      rot5[2][0]=d*rot4[2][0]+a*rot4[2][2];
      rot5[0][1]=rot4[0][1];
      rot5[1][1]=rot4[1][1];
      rot5[2][1]=rot4[2][1];
      rot5[0][2]=a*rot4[0][0]-d*rot4[0][2];
      rot5[1][2]=a*rot4[1][0]-d*rot4[1][2];
      rot5[2][2]=a*rot4[2][0]-d*rot4[2][2];

      /* Rotate by the inverse of the x axis rotation matirx defined
         above (step 1).
      */
      rot6[0][0]=rot5[0][0];
      rot6[1][0]=rot5[1][0];
      rot6[2][0]=rot5[2][0];
      rot6[0][1]=(c/d)*rot5[0][1]+(b/d)*rot5[0][2];
      rot6[1][1]=(c/d)*rot5[1][1]+(b/d)*rot5[1][2];
      rot6[2][1]=(c/d)*rot5[2][1]+(b/d)*rot5[2][2];
      rot6[0][2]=(b/d)*rot5[0][1]-(c/d)*rot5[0][2];
      rot6[1][2]=(b/d)*rot5[1][1]-(c/d)*rot5[1][2];
      rot6[2][2]=(b/d)*rot5[2][1]-(c/d)*rot5[2][2];
  }

   
  memcpy(rot, rot6, sizeof(double) * 9 );
   
}

			</file>
			<file name="localpotentialraft.c" type="text">

/*
  Anneal using RAFT / local potential in balance
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;anneal.h&quot;
#include &quot;readinput.h&quot;
#include &quot;raftgeometry.h&quot;
#include &quot;raft.h&quot;
#include &quot;rg_localpotential.h&quot;


typedef struct
{
    INPUTPARAMS *ip;   /* input params */ 
    RAFTGEOMETRY *rg;  /* RAFT geometry object */    
    int Nres;          /* no residues */
    double locpotp;    /* local / global potential balance */    
} WORKSPACE;

static void *clone(void *obj, void *ptr);
static void kill(void *obj, void *ptr);
static int  copy(void *dest, void *src, void *ptr);
static void mutate(void *obj, void *ptr);
static double score(void *obj, void *ptr);

int *localpotentialraft(char *seq, double locpotp, CONFORMERSET *cs, FORCEFIELDPARAMS *ffp, INPUTPARAMS *ip, int iterations)
{
  WORKSPACE work;
  int *cnf;
  int i;

  work.ip = ip;
  work.Nres = strlen(seq);
  work.rg = raftgeometry(ffp, cs);
  work.locpotp = locpotp;

  rg_addconformer(work.rg, seq); 

 

  cnf = malloc(strlen(seq) * sizeof(int));
  for(i=0;i&lt;work.Nres;i++)
    cnf[i] = (rand() % 6) + 1;

  anneal(cnf, clone, kill, copy, score, mutate, iterations, &amp;work);

  return cnf;
}


/*
  clone  conformer.
  Params: obj - object to clone
          ptr - workspace
  Returns: cloned object
 */
static void *clone(void *obj, void *ptr)
{
    WORKSPACE *wk =ptr;
    int *answer;

    answer = malloc(wk-&gt;Nres * sizeof(int));
    if(answer)
      memcpy(answer, obj, wk-&gt;Nres * sizeof(int));
    return answer;
}

/*
  destroy cloned object
  Params: obj - the object
          ptr - workspace
 */
static void kill(void *obj, void *ptr)
{
    free(obj);
}

/*
  copy object
  Parmas: dest - destination object
          src - source object
          ptr - workspace
  Returns: 0 on success
 */
static int  copy(void *dest, void *src, void *ptr)
{
    WORKSPACE *wk = ptr;
 
    memcpy(dest, src, wk-&gt;Nres * sizeof(int));
    return 0;
}

/*
  mutate an object
  Params: obj - the object
          ptr - workspace
 */
static void mutate(void *obj, void *ptr)
{
    WORKSPACE *wk = ptr;
    int *sol = obj;
    int target;

    target = rand() % wk-&gt;Nres;
    sol[target] = (rand() % 6) + 1;    
}

#include &lt;float.h&gt;
/*
  score object
  Params: obj - the object
          ptr - workspace
  Returns: score
 */
static double score(void *obj, void *ptr)
{
    WORKSPACE *wk = ptr;
    int *sol = obj;
    double answer;
    int i;
    int cnf[1024];
    static double best = 100000.0;

    for(i=0;i&lt;wk-&gt;Nres;i++)
      cnf[i] = sol[i] - 1;
    
    rg_setconformer(wk-&gt;rg, 0, cnf, 0, 0);
    answer = raft(wk-&gt;rg, wk-&gt;ip);
    answer += rg_localpotential3(wk-&gt;rg) * wk-&gt;locpotp;
        
    if(answer &lt; best)
    {
      // for(i=0;i&lt;wk-&gt;Nres;i++)
      //printf(&quot;%d&quot;, cnf[i]);
      //printf(&quot;  %.*f %.*f\n&quot;, DBL_DIG, best, DBL_DIG, answer);
      best = answer;
    }

    return answer;
}

			</file>
			<file name="readsequence.c" type="text">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;math.h&gt;

typedef struct
{
    int len;         /* length of sequence */
    char *seq;        /* sequnece (NUL-terminated) */
} SEQUENCE;

SEQUENCE *readsequence(char *fname);
void killsequence(SEQUENCE *seq);

static int issequence(char *seq);
static int isamino(int ch);
static void trim(char *str);
static char *getline(FILE *fp);

/*
  read a sequence from a file
  Params: fname - name of the file to read
  Returns: sequnece on success, 0 on fail
 */
SEQUENCE *readsequence(char *fname)
{
    FILE *fp;
    SEQUENCE *seq;
    char buff[1024];
    float version;

    fp = fopen(fname, &quot;r&quot;);
    if(!fp)
	return 0;
    seq = malloc(sizeof(SEQUENCE));
    if(!seq)
	goto error_exit;
    fgets(buff, 1024, fp);
    trim(buff);
    if(strcmp(buff, &quot;%SEQUENCE FILE&quot;))
	goto error_exit;
    fgets(buff, 1024, fp);
    if(sscanf(buff, &quot;%%VERSION %f\n&quot;, &amp;version) != 1)
	goto error_exit;
    if( floor(version) != 1.0)
        goto error_exit;
    if(fscanf(fp, &quot;%d\n&quot;, &amp;seq-&gt;len) != 1)
	goto error_exit;
    seq-&gt;seq = getline(fp);
    if(!seq-&gt;seq)
	goto error_exit;
    trim(seq-&gt;seq);
    if(strlen(seq-&gt;seq) != seq-&gt;len)
	goto error_exit;
    if(!issequence(seq-&gt;seq))
	goto error_exit;

    fclose(fp);
    
    return seq;
 error_exit:
    killsequence(seq);
    if(fp)
	fclose(fp);
    return 0;
}

/*
  sequence destructor
  Parmas: seq - object to destroy
 */
void killsequence(SEQUENCE *seq)
{
    if(seq)
    {
	free(seq-&gt;seq);
        free(seq);
    }
}

/*
  is a string a valid amino acid sequence
  Params: seq - sequence to test
  Returns: 1 if all amino acids, else 0
 */
static int issequence(char *seq)
{
    while(*seq)
    {
	if(!isamino(*seq))
	    return 0;
        seq++;
    }

    return 1;
}

/*
  is a character an amino acid code?
  Params: ch - character to test
  Returns: 1 if amino acid, else 0
 */
static int isamino(int ch)
{
    return strchr(&quot;ACDEFGHIKLMNPQRSTVWY&quot;, ch) ? 1 : 0;
}

/*
  trim leading and trailing whitespace from a string
  Params: str - the string to trim
 */
static void trim(char *str)
{
    char *ptr;
    char *ptr2;

    ptr = str;
    while(isspace(*ptr))
	ptr++;
    ptr2 = str;
    while(*ptr)
	*ptr2++ = *ptr++;
    *ptr2 = 0;
    
    while(ptr2-- &gt; str)
    {
	if(isspace(*ptr2))
	    *ptr2 = 0;
        else
	    break;
    }
}

/*
  read a line of text
  Params: fp - pointer to open file
  Returns: line read, NULL on EOF or out of memory
  Notes: return allocated with malloc
 */
static char *getline(FILE *fp)
{
    char *buff;
    int nread = 0;
    int buffsize = 128;
    int ch;
    char *temp;

    buff = malloc(128);
    if(!buff)
	return 0;

    while((ch = fgetc(fp))!=&apos;\n&apos;)
    {
	if(ch == EOF)
        {
	    if(nread == 0)
            {
		free(buff);
                return 0;
	    }
            break;
        }
        buff[nread] = (char) ch;
        nread++;
        if(nread == buffsize-1)
        {
	    temp = realloc(buff, buffsize + 64);
            if(!temp)
            {
		free(buff);
                return 0;
            }
            buff = temp;
            buffsize += 64;
        }
    }
    buff[nread] = 0;
    return buff;
}

			</file>
			<file name="rg_localpotential.h" type="text">
#ifndef rg_localpotential_h
#define rg_localpotential_h

float rg_localpotential(RAFTGEOMETRY *rg);
float rg_localpotential2(RAFTGEOMETRY *rg);
float rg_localpotential3(RAFTGEOMETRY *rg);

#endif

			</file>
			<file name="writeoutput.c" type="text">
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#include &quot;rotmtx.h&quot;

static void printmtx(FILE *fp, double *mtx);
static void eulertomtx(double *mtx, double *rot, double *pos);

/*
  write the output file
  Parmas: fname - name of output file
          seq - the sequence
          cnf - the conformers
          rot - Euler angles
          pos - translations
          Ncnf - number of strands
          score - the energy
 */

int writeoutput(char *fname, char *seq, int *cnf, double *rot, double *pos, int Ncnf, float score)
{
    FILE *fp;
    int i;
    int j;
    int len;
    int answer = 0;
    double rotation[3] = {0.0, 0.0, 0.0};
    double translation[3] = {0.0, 0.0, 0.0};
    double mtx[16];

    fp = fopen(fname, &quot;w&quot;);
    if(!fp)
	return -1;
    fprintf(fp, &quot;%%CONFORMER FILE\n&quot;);
    fprintf(fp, &quot;%%VERSION 2.0\n&quot;);
    fprintf(fp, &quot;%d\n&quot;, Ncnf);
   
    len = strlen(seq);
    for(i=0;i&lt;Ncnf;i++)
    {
	fprintf(fp, &quot;%d\n&quot;, len);
        fprintf(fp, &quot;%s\n&quot;, seq);
        for(j=0;j&lt;len;j++)
	    fprintf(fp, &quot;%d&quot;, cnf[j*Ncnf+i]);
        fprintf(fp, &quot;\n&quot;);
        /* Fortran to C array conversion */
        if(rot)
	{
          rotation[0] = rot[i];
          rotation[1] = rot[i+ 1 * Ncnf];
          rotation[2] = rot[i+ 2 * Ncnf];
        }
        fprintf(fp, &quot;eua %f eub %f eug %f\n&quot;, rotation[0], rotation[1], rotation[2]);
        if(pos)
	{
          translation[0] = pos[i];
          translation[1] = pos[i+ 1 *  Ncnf];
          translation[2] = pos[i+ 2 * Ncnf];
        }
        fprintf(fp, &quot;Pos %f %f %f\n&quot;, translation[0], translation[1], translation[2]);
        eulertomtx(mtx, rotation, translation);
        printmtx(fp, mtx);
    }
    fprintf(fp, &quot;energy %f\n&quot;, score);
    if(ferror(fp))
	answer = -1;
    if(fclose(fp) == EOF)
	answer = -1;
    return answer;
}

static void printmtx(FILE *fp, double *mtx)
{
    fprintf(fp,&quot;%f %f %f %f\n&quot;, mtx[0], mtx[1], mtx[2], mtx[3]);
    fprintf(fp,&quot;%f %f %f %f\n&quot;, mtx[4], mtx[5], mtx[6], mtx[7]);
    fprintf(fp,&quot;%f %f %f %f\n&quot;, mtx[8], mtx[9], mtx[10], mtx[11]);
    fprintf(fp,&quot;%f %f %f %f\n&quot;, mtx[12], mtx[13], mtx[14], mtx[15]);
}

static void eulertomtx(double *mtx, double *rot, double *pos)
{
  double r[3][3];
  int i, ii;
  
  rotmat(rot[0], rot[1], rot[2], r);
  for(i=0;i&lt;3;i++)
    for(ii=0;ii&lt;3;ii++)
      mtx[i*4+ii] = r[i][ii];

  mtx[0 * 4 + 3] = pos[0];
  mtx[1 * 4 + 3] = pos[1];
  mtx[2 * 4 + 3] = pos[2];

  mtx[3 * 4 + 0] = 0.0;
  mtx[3 * 4 + 1] = 0.0;
  mtx[3 * 4 + 2] = 0.0;
  mtx[3 * 4 + 3] = 1.0; 
  
}

			</file>
			<file name="vector.c" type="text">
/*
  Basic vector functions
  All single--precision floating point
 */

#include &lt;math.h&gt;

#include &quot;vector.h&quot;

/*
  obtain the angle abc
 */
float vang(float *a, float *b, float *c)
{
  float ba[3];
  float bc[3];
  float len;

  vsub(ba, a, b);
  vsub(bc, c, b);
  len = vlen(ba) * vlen(bc);
  return acos(dot(ba,bc)/ len);
  
}
/*
  get the crossproduct of two vectors.
  Params: ans - return pointer for answer.
          pt1 - first vector
		  pt2 - second vector.
  Notes: crossproduct is at right angles to the two vectors.
*/
void crossproduct(float *ans, float *pt1, float *pt2)
{
  ans[0] = pt1[1] * pt2[2] - pt1[2] * pt2[1];
  ans[1] = pt1[2] * pt2[0] - pt1[0] * pt2[2];
  ans[2] = pt1[0] * pt2[1] - pt1[1] * pt2[0];
}

/*
  get the dotproduct of two vectors
  Params: a - vector 1
          b - vector 2
  Returns: dot product
  Notes = cosine of angle between if both vectors are normal 
 */

float dot(float *a, float *b)
{
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/*
  normalize a vector
  Params: v - vector to normalize
  Returns: 0 on success, -1 on zero vector
 */
int normalize(float *v)
{
  double len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
  if(len == 0)
    return -1;
  v[0] /= len;
  v[1] /= len;
  v[2] /= len;
  return 0;
}

/*
  subtract two vectors
  Params: res - result
          a - vector 1
          b - vector to subtract
 */
void vsub(float *res, float *a, float *b)
{
  res[0] = a[0] - b[0];
  res[1] = a[1] - b[1];
  res[2] = a[2] - b[2];
}

/*
  length of a vector
 */
float vlen(float *v)
{
  return sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
}

/*
  squared length of a vector
 */
float vlen2(float *v)
{
  return v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
}

/*
  distance between two points
 */
float vdist(float *a, float *b)
{
  return sqrt( (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]) + (a[2]-b[2])*(a[2]-b[2]));
}

/*
  squared distnace between two points.
 */
float vdist2(float *a, float *b)
{
  return (a[0]-b[0])*(a[0]-b[0]) + (a[1]-b[1])*(a[1]-b[1]) + (a[2]-b[2])*(a[2]-b[2]);
}

			</file>
			<file name="readinput.h" type="text">
#ifndef readinput_h
#define readinput_h
 
typedef struct
{
  int window;
  int grddim;
  float cellen;
  float delang;
  int numcnf;
  int numsim;
  float initmp;
  int tsteps;
  float tmpfac;
  int seed;
  int mutlim;
  float maxmut;
  int nlimit;
  int krdang;
  char *oppang;
  int krdbsq;
  char *seqbas;
  int krdfff; 
  char *ffffil;
  char *outfil;
  int iexseq;
  int hsecel;
  int khonly;  
  float exhben;
  float pinten;
  float aascal;
  float abscal;
  float bbscal;
  float oscal;
} INPUTPARAMS;

INPUTPARAMS *readinputparams(char *fname);
void killinputparams(INPUTPARAMS *ip);

#endif


			</file>
			<file name="bbone.c" type="text">
#include &lt;math.h&gt;
#include &lt;assert.h&gt;

#define degtorad(theta) ( (theta)/180.0 * M_PI)
 
/*
  drop-in C replacement for Fortran 77 bbone.
  Gets protein backbone from phi/psi.omega angles
  Params:
    vnh - return for N hydrogens
    vo - return for Oxygen
    va - return for Carbon Alpha 
    vb - return for Carbon Beta
    vn - return for Nitrogen
    vc - return for Carbon (C)
    phi - phi angles (radians)
    psi - psi angles (radians)
    omega - omega angles 0 or PI (note, omegas precede residue)
    N - no residues (&lt;1024)
 */
void bbone(double vnh[][3], double vo[][3], double va[][3], double vb[][3], double vn[][3], double vc[][3], double *phi, double *psi, double *omega, int N)
{
  static double spsi[1024], cpsi[1024], sphi[1024], cphi[1024];
  double pi = M_PI;
  int ir;
  int i, j, k;

  double angacn, angcna, angnac, angaco, angnab, angbac, angcnh;
  double lac, lcn, lna, lco, lab, lnh;

  double vn1, vn2;
  double ac1, ac2, ac3, ac4, ac5;
  double bc1, bc2;
  double vac1, vac2;
  double vcc1, vcc2, vcc3, vcc4, vcc5;
  double vnhc1, vnhc2;

  double at1, at2, at3, at4, at5;
  double bt1, bt2;
  double vat1, vat2;
  double vct1, vct2, vct3, vct4, vct5;
  double vnht1, vnht2;


  double r[3][3];
  double a[3], b[3], c[3];

  assert(N &lt;= 1024);

  angacn = degtorad(116.0);
  angcna = degtorad(122.0);
  angnac = degtorad(111.0);
  angaco = degtorad(121.9968);
  angnab = degtorad(107.63);
  angbac = degtorad(112.81);
  angcnh = degtorad(116.0);
   
  lac=1.5100;
  lcn=1.3200;
  lna=1.4600;
  lco=1.2368;
  lab=1.5386;
  lnh=1.0800;

  /* cis/trans */
  vn1=lcn*sin(angacn);
  vn2=lcn*cos(angacn);
  /*cis */
  ac1=cos(angnac)*cos(angcna-angacn);
  ac2=cos(angnac);
  ac3=sin(angnac)*sin(angcna-angacn);
  ac4=cos(angnac)*sin(angcna-angacn);
  ac5=sin(angnac)*cos(angcna-angacn);
  bc1=cos(angcna-angacn);
  bc2=sin(angcna-angacn);
  vac1=lna*bc2;
  vac2=lna*bc1;
  vcc1=lac*ac5;
  vcc2=lac*sin(angnac);
  vcc3=lac*ac4;
  vcc4=lac*ac3;
  vcc5=lac*ac1;
  vnhc1=lnh*sin(angacn+angcnh);
  vnhc2=lnh*cos(angacn+angcnh);
  /* c-----trans */
  at1=cos(angnac)*cos(angcna+angacn);
  at2=ac2;
  at3=sin(angnac)*sin(angcna+angacn);
  at4=cos(angnac)*sin(angcna+angacn);
  at5=sin(angnac)*cos(angcna+angacn);
  bt1=cos(angcna+angacn);
  bt2=sin(angcna+angacn);
  vat1=lna*bt2;
  vat2=lna*bt1;
  vct1=lac*at5;
  vct2=vcc2;
  vct3=lac*at4;
  vct4=lac*at3;
  vct5=lac*at1;
  vnht1=lnh*sin(angcnh-angacn);
  vnht2=lnh*cos(angcnh-angacn);

  /* -Read phi and psi angles and convert to double precision radians.
     Also calculate sin/cos of phi and psi for passing into loop. */
  for(ir =0;ir&lt;N;ir++)
  {
    cphi[ir]=cos(phi[ir]);
    sphi[ir]=sin(phi[ir]);
    cpsi[ir]=cos(psi[ir]);
    spsi[ir]=sin(psi[ir]);
  }
  /*
  Alpha carbon of residue 1 placed at (0,0,0). Alpha carbon-to-carbonyl carbon
  vector of residue 1 is placed along the z-axis (+ve direction). Nitrogen-to-
  alpha carbon vector of residue 1 placed in the +x,-z-plane. 

  Calculate the backbone nitrogen, alpha-carbon, carbonyl-carbon, carbonyl-oxygen,
   and beta-carbon vectors of residue 1.
  */

  vn[0][0] = lna*sin(angnac);
  vn[0][1] = 0.0;
  vn[0][2] = lna*cos(angnac);
  va[0][0] = 0.0;
  va[0][1] = 0.0;
  va[0][2] = 0.0;
  vc[0][0] = 0.0;
  vc[0][1] = 0.0;
  vc[0][2] = lac;
  vo[0][0] = vc[0][0] -(lco*sin(angaco)*cpsi[0]);
  vo[0][1] = vc[0][1] -(lco*sin(angaco)*spsi[0]);
  vo[0][2] = vc[0][2] -(lco*cos(angaco));

  /* x and z elements of vb calculated using scalar products (using angbac and angnab
     along with the vn and vc vectors). y element obtained using pythagoras.
  */
  vb[0][2] = lab*cos(angbac);
  vb[0][0] = lab*((cos(angnab)-cos(angnac)*cos(angbac))/sin(angnac));
  vb[0][1] = -sqrt(lab*lab-vb[0][0] * vb[0][0]- vb[0][2] * vb[0][2]);

  /*  The above are not influenced by omega.
      Initiate the rotation matrix r to the unit vector I.
  */

  r[0][0] = 1.0;
  r[0][1] = 0.0;
  r[0][2] = 0.0;
  r[1][0] = 0.0;
  r[1][1] = 1.0;
  r[1][2] = 0.0;
  r[2][0] = 0.0;
  r[2][1] = 0.0;
  r[2][2] = 1.0;

  /* xyz coordinate calculation loop */ 
  for(i=1;i&lt;N;i++)
  {
    for(j=0;j&lt;3;j++)
    {

  /* calculate the backbone nitrogen, alpha-carbon, carbonyl-carbon
     and and nitrogen hydrogen vectors (vn,va,vc,vnh). */ 

    vn[i][j] =vc[i-1][j]+r[0][j]*(vn1*cpsi[i-1])
                      +r[1][j]* (vn1*spsi[i-1])
                      +r[2][j]*(-vn2);
    if(floor(omega[i]-pi) == 0.0)
    {
      /* cis peptide so calculate vectors accordingly. */     
      va[i][j] =vn[i][j]+r[0][j]*(vac1*cpsi[i-1])
                    +r[1][j] *(vac1*spsi[i-1])
                    +r[2][j] * (vac2);
     vc[i][j]=va[i][j]+r[0][j]*(-(vcc1*cpsi[i-1]*cphi[i])
       +(vcc2*spsi[i-1]*sphi[i])
       -(vcc3*cpsi[i-1]))
       +r[1][j]*(-(vcc1*spsi[i-1]*cphi[i])
       -(vcc2*cpsi[i-1]*sphi[i]) 
       -(vcc3*spsi[i-1]))  
       +r[2][j]*(vcc4*cphi[i]-vcc5);
     vnh[i][j] = vn[i][j]+r[0][j]*(-vnhc1*cpsi[i-1])
       +r[1][j]*(-vnhc1*spsi[i-1])
       +r[2][j]*(vnhc2); 

     /* -----calculate the three orthogonal unit vectors a,b,c which initially. lie
     on the global x,y,z axes, respectively.
     */

               a[j]= r[0][j] *(ac1*cpsi[i-1]*cphi[i]
		      -ac2*spsi[i-1]*sphi[i]-ac3*cpsi[i-1])
                   +r[1][j] *(ac1*spsi[i-1]*cphi[i]
                   +ac2*cpsi[i-1]*sphi[i]-ac3*spsi[i-1])
		     +r[2][j] *(-ac4*cphi[i]-ac5);

               b[j]=r[0][j]*(bc1*cpsi[i-1]*sphi[i]
                 +spsi[i-1] *cphi[i])
                   +r[1][j]*(bc1*spsi[i-1]*sphi[i]
                   -cpsi[i-1]*cphi[i])
		 +r[2][j]*(-bc2*sphi[i]);
               c[j]=(vc[i][j]-va[i][j])/lac;
    }            

    else
    {
      /* trans peptide so calculate vectors accordingly. */
               va[i][j]=vn[i][j]+r[0][j]*(-vat1*cpsi[i-1])
                    +r[1][j]*(-vat1*spsi[i-1])
                    +r[2][j]*(vat2);
               vc[i][j]=va[i][j]+r[0][j]*((vct1*cpsi[i-1]*cphi[i])
                   -(vct2*spsi[i-1]*sphi[i])
                   +(vct3*cpsi[i-1]))
                   +r[1][j]*((vct1*spsi[i-1]*cphi[i])
                   +(vct2*cpsi[i-1]*sphi[i])
                   +(vct3*spsi[i-1]))
		 +r[2][j]*((vct4*cphi[i])-(vct5));
               vnh[i][j]=vn[i][j]+r[0][j]*(vnht1*cpsi[i-1])
                    +r[1][j]*(-vnht1*spsi[i-1])
		 +r[2][j]*(vnht2);

	       /* calculate the three orthogonal unit vectors a,b,c which initially lie
		  on the global x,y,z axes, respectively. */

               a[j]=r[0][j]*(-at1*cpsi[i-1]*cphi[i]
                 +at2*spsi[i-1]*sphi[i]+at3*cpsi[i-1])
                   +r[1][j]*(-at1*spsi[i-1]*cphi[i]
                 -at2*cpsi[i-1]*sphi[i]+at3*spsi[i-1])
		 +r[2][j]*(-at4*cphi[i]-at5);
               b[j]=r[0][j]*(-bt1*cpsi[i-1]*sphi[i]
                 -spsi[i-1]*cphi[i])
                  +r[1][j]*(-bt1*spsi[i-1]*sphi[i]
                   +cpsi[i-1]*cphi[i])
                   +r[2][j]*(-bt2*sphi[i]);
               c[j]=(vc[i][j]-va[i][j])/lac;

        }
   }


 /* calculate the next rotation matrix. */

         r[0][0]=a[0];
         r[0][1]=a[1];
         r[0][2]=a[2];
         r[1][0]=b[0];
         r[1][1]=b[1];
         r[1][2]=b[2];
         r[2][0]=c[0];
         r[2][1]=c[1];
         r[2][2]=c[2];

/* calculate the carbonyl-carbon and beta-carbon vector for residue i. */

       for(k=0;k&lt;3;k++)
       {
            vo[i][k] = vc[i][k]+r[0][k]*(-lco*sin(angaco)*cpsi[i])
                    +r[1][k]*(-lco*sin(angaco)*spsi[i])
                    +r[2][k]*(-lco*cos(angaco));
            vb[i][k] = va[i][k]+r[0][k]*vb[0][0]
                    +r[1][k]*vb[0][1]
	            +r[2][k]*vb[0][2];
       }    
   }  

}

			</file>
			<file name="angpot.c" type="text">
/*
  Statistical local potental arrays.
  (Note Fortran order is different to C order. Amino acids are
    in columns).

  Assume the torsion angle is give by Carbon Alphas ABCD

  ephi1 - potential for first phi angle (with respect to residue C)
  ephi2 - potential for second phi angle (with respect to residue B)
  etheta - potential for simple angle
  ephi12 - pairwise phi1 / phi2 potential
  ethphi1 - pairwise theta / phi1
  ethphi2 - pairwise theta / phi2
 
  phi1rg - bins (in degrees) for phi1
  phi2rg - bins (in degrees) for phi2
  thetrg - bins (in degrees) for theta
   
 */
float ephi1[12][20] = {
  { 1.33, 0.57, 0.65, 1.02, 0.48, -0.25, 0.3, 1.33, 1.04, 1.45, 1.28, 0.2, 1.46, 1.1, 0.99, 0.74, 0.6, 1.11, 0.85, 0.37, },
  { -1.73, -1.27, -1.38, -1.73, -1.46, -0.87, -1.44, -1.46, -1.59, -1.7, -1.66, -1.4, -0.16, -1.7, -1.62, -1.22, -1.23, -1.31, -1.44, -1.43, },
  { 0.05, 0.15, -0.16, -0.03, 0.23, 0.2, 0.01, 0.55, 0.03, 0.26, 0.13, 0.01, 1.44, 0.01, 0.07, -0.23, 0.17, 0.6, 0.04, 0.24, },
  { 0.69, 0.43, 0.59, 0.93, 0.88, 0.64, 0.7, 0.79, 0.56, 0.7, 0.61, 0.71, 3.69, 0.63, 0.7, 0.37, 0.57, 0.75, 0.69, 0.82, },
  { 0.75, 0.42, 0.71, 1.05, 0.75, 0.77, 0.74, 0.9, 0.87, 0.96, 0.79, 0.85, 2.82, 0.87, 0.79, 0.47, 0.59, 0.96, 0.67, 0.77, },
  { 0.36, -0.06, 0.65, 0.72, 0.04, 0.53, 0.22, 0.15, 0.47, 0.46, 0.28, 0.51, 0.39, 0.48, 0.34, 0.1, -0.13, -0.03, 0.07, 0.03, },
  { -0.17, -0.7, -0.09, -0.08, -0.8, 0.18, -0.54, -1.04, -0.28, -0.62, -0.53, -0.12, -0.43, -0.29, -0.36, -0.35, -0.75, -1.13, -0.64, -0.79, },
  { 0.09, -0.17, -0.38, -0.1, -0.07, -0.32, -0.12, -0.34, -0.29, -0.21, -0.11, -0.31, -0.99, -0.13, -0.19, -0.31, -0.4, -0.38, -0.13, -0.1, },
  { 0.24, 0.21, -0.14, 0.13, 0.46, -0.64, 0.25, 0.52, 0.09, 0.45, 0.52, 0.03, -1.27, 0.4, 0.26, -0.03, 0.21, 0.45, 0.16, 0.48, },
  { 1.21, 1.24, 0.79, 0.97, 1.46, 0.46, 1.22, 1.79, 1.17, 1.8, 1.64, 0.99, -0.36, 1.42, 1.29, 0.94, 1.35, 1.67, 1.28, 1.53, },
  { 2.24, 2.05, 1.61, 1.94, 2.21, 0.37, 2.01, 2.85, 2.13, 2.85, 2.75, 1.48, 1.48, 2.41, 2.25, 1.78, 2.19, 2.7, 2.02, 1.97, },
  { 1.73, 1.56, 0.9, 1.78, 1.9, 0.66, 1.42, 2.77, 1.75, 2.64, 1.88, 0.63, 1.85, 1.84, 1.72, 1.21, 1.92, 2.68, 1.79, 1.72, },
};


float ephi2[12][20] = {
  { 1.76, 1.25, 1.24, 1.41, 1.12, 0.6, 1.01, 1.76, 1.52, 1.93, 1.79, 0.9, 1.25, 1.62, 1.48, 1.37, 1.27, 1.59, 1.32, 1.03, },
  { -1.33, -0.72, -0.88, -1.36, -0.93, -0.42, -0.85, -1.06, -1.14, -1.24, -1.18, -0.86, -0.53, -1.22, -1.17, -0.69, -0.67, -0.89, -1.04, -0.9, },
  { 0.04, 0.04, -0.26, -0.08, -0.12, -0.15, -0.23, 0.32, -0.01, -0.06, -0.01, -0.39, 0.29, -0.07, -0.02, -0.1, 0.02, 0.37, -0.12, -0.12, },
  { 0.19, -0.01, -0.22, 0.12, -0.04, -0.16, -0.15, 0.27, 0.04, 0.08, 0.11, -0.34, 0.58, 0.03, 0.1, -0.06, 0.01, 0.28, 0.04, -0.06, },
  { 0.07, -0.17, -0.22, 0.12, -0.07, -0.09, -0.14, 0.11, 0.03, 0.06, 0.03, -0.24, 0.63, 0.04, 0.05, -0.15, -0.06, 0.12, -0.03, -0.07, },
  { -0.21, -0.43, -0.27, -0.04, -0.32, -0.07, -0.28, -0.24, -0.14, -0.14, -0.21, -0.24, 0.38, -0.14, -0.17, -0.37, -0.33, -0.3, -0.31, -0.31, },
  { -0.48, -0.75, -0.38, -0.33, -0.71, -0.21, -0.55, -0.92, -0.44, -0.61, -0.61, -0.33, -0.25, -0.45, -0.5, -0.6, -0.72, -0.98, -0.68, -0.71, },
  { -0.21, -0.41, -0.17, -0.15, -0.33, -0.21, -0.29, -0.43, -0.34, -0.27, -0.33, -0.08, -0.77, -0.27, -0.31, -0.44, -0.55, -0.52, -0.25, -0.31, },
  { 0.26, 0.17, 0.17, 0.26, 0.39, -0.14, 0.28, 0.37, 0.1, 0.35, 0.23, 0.28, -0.93, 0.2, 0.15, -0.04, -0.08, 0.27, 0.45, 0.38, },
  { 1.28, 1.2, 0.89, 1.14, 1.48, 0.09, 1.16, 1.37, 1.03, 1.4, 1.37, 1.03, 0.04, 1.15, 1.11, 1.12, 1.23, 1.2, 1.34, 1.37, },
  { 2.03, 2.18, 1.68, 1.7, 2.13, 0.52, 1.84, 1.77, 1.62, 2.04, 2.23, 1.87, 1.17, 1.81, 1.83, 1.92, 2.13, 1.75, 1.87, 2.01, },
  { 2.48, 2.74, 2.15, 2.03, 2.59, 1.2, 2.33, 2.15, 1.97, 2.43, 2.64, 2.58, 1.39, 2.26, 2.25, 2.41, 2.55, 2.13, 2.23, 2.35, },
};


float etheta[10][20] = {
  { 6.99, 6.57, 6.09, 8.18, 7, 6.65, 7.11, 8.02, 7.34, 7.11, 6.92, 6.66, 6.42, 6.53, 7.92, 8.05, 6.6, 7.14, 5.96, 7.55, },
  { 4.45, 6.57, 4.74, 4.44, 5.74, 4.82, 5.72, 5.24, 4.37, 4.95, 4.97, 4.42, 3.71, 4.53, 5.52, 4.83, 4.41, 4.91, 4.46, 4.78, },
  { -0.71, -0.07, -0.43, -0.63, -0.01, 0.15, -0.17, -0.15, -0.53, -0.45, -0.48, -0.31, -0.39, -0.56, -0.53, -0.34, 0, -0.05, -0.27, 0.08, },
  { -1.46, -1.08, -1.41, -1.52, -1.25, -1.41, -1.28, -1.14, -1.42, -1.43, -1.4, -1.43, -1.07, -1.47, -1.4, -1.19, -1.09, -1.01, -1.29, -1.21, },
  { 0.49, -0.16, -0.42, 0.16, -0.1, 0.06, -0.3, -0.16, 0.02, 0.07, 0.27, -0.46, -0.03, 0.14, 0.1, 0.28, -0.08, -0.13, 0, -0.12, },
  { -0.06, -0.47, -0.3, -0.07, -0.32, 0.36, -0.31, -0.69, -0.17, -0.33, -0.14, -0.19, -1.08, -0.04, -0.17, -0.27, -0.34, -0.66, -0.33, -0.3, },
  { 0.17, -0.29, 0.24, 0.15, -0.23, -0.08, -0.09, -0.49, -0.04, -0.19, -0.16, 0.19, -0.38, -0.01, -0.03, -0.33, -0.48, -0.61, -0.18, -0.31, },
  { 0.4, -0.13, 0.84, 0.56, -0.15, -0.14, 0.09, 0.26, 0.32, 0.52, 0.11, 0.62, 2.06, 0.3, 0.17, -0.1, -0.36, -0.07, 0.08, -0.23, },
  { 0.9, 0.38, 1.47, 1.66, 0.54, 0.01, 0.79, 2.12, 1.56, 2.24, 1.13, 1.28, 4.44, 1.43, 1.27, 0.34, 0.76, 1.62, 0.68, 0.54, },
  { 3.88, 3.24, 4.6, 4.78, 3.59, 1.83, 3.81, 5.53, 4.7, 6.1, 4.15, 4.32, 6.42, 4.53, 4.52, 3.38, 4.38, 5.76, 3.77, 3.58, },
};


float ephi12[12][12][20] =  {
{  {-0.84, -0.54, -0.77, -1.29, -0.49, 0.56, -0.63, -1.4, -1.41, -1.72, -1.2, -0.16, -0.6, -1.09, -1.16, -0.69, -1.03, -1.33, -0.99, -0.66, },
  {-0.28, 0.42, -0.24, -0.5, 0.51, 0.53, 0.07, -0.3, -0.84, -0.49, -0.24, 0.18, 0.52, -0.54, -0.41, -0.34, -0.4, -0.35, 0.25, 0.32, },
  {-1.56, -0.62, -0.67, -1.35, -0.48, 0.09, -0.47, -0.85, -1.41, -1.39, -1.39, -0.25, -1.1, -1.24, -1.15, -0.91, -0.83, -0.94, -0.65, -0.18, },
  {-1.26, 0.45, -0.41, -1.36, -0.27, 0.53, -0.15, -0.73, -1.22, -0.9, -1.02, -0.27, -1.18, -1.22, -1.14, -0.58, -0.65, -0.92, -0.83, -0.39, },
  {-1.42, -0.05, -0.54, -1.39, -0.61, 0.25, -0.19, -1.33, -1.62, -1.39, -1.26, -0.46, -1.32, -1.43, -1.4, -0.83, -0.71, -0.85, -0.75, -0.57, },
  {-1.18, -0.36, -1.05, -1.51, -0.14, -0.16, -0.81, -1.8, -1.65, -1.82, -1.44, -0.51, -0.76, -1.41, -1.37, -0.94, -1.05, -1.41, -0.91, -0.4, },
  {-0.85, 0.48, -1.37, -0.84, 0.5, -0.16, -0.07, 0.04, -1.15, -0.59, -0.17, -0.13, -0.77, -1.17, -0.72, -0.74, -0.46, 0.29, 0.03, 0.45, },
  {-1.29, 0.06, -1.09, -1.11, -0.08, 0.21, -0.29, -0.26, -1.17, -0.76, -0.94, 0.07, -0.91, -0.9, -0.8, -0.78, -0.48, -0.08, -0.31, 0.03, },
  {-1.34, 0.38, -0.65, -1.18, -0.32, 1.07, -0.36, -0.54, -1.23, -0.89, -0.94, 0.08, -0.81, -1.15, -0.81, -0.72, -0.54, -0.64, -0.81, -0.4, },
  {-2.3, -0.18, -1.4, -2.04, -1.13, -0.06, -0.92, -1.57, -2.17, -1.63, -1.56, -0.88, -1.54, -1.74, -1.85, -1.43, -1.19, -1.75, -0.53, -0.96, },
  {-2.15, -1.57, -0.87, -1.8, -0.71, 0.47, -0.77, -1.66, -1.85, -1.58, -1.66, -0.37, -1.45, -1.7, -1.24, -1.57, -0.97, -1.71, -0.43, -0.74, },
  {-0.66, 0.01, 0.41, -0.45, -0.48, -0.2, -0.28, -0.97, -0.46, -1.21, -0.5, 0.93, -1.32, -0.43, -0.24, -0.44, -0.17, -0.64, -0.71, -0.25, },
},
{  {1.22, 0.2, 0.64, 0.61, 0.36, 1.17, 0.48, 0.04, 0.66, 0.56, 0.7, 0.95, -0.5, 0.61, 0.72, 0.44, 0.57, 0.1, 0.54, 0.32, },
  {-0.99, -1.45, -1.22, -0.92, -1.22, -1.52, -1.21, -1.26, -1.1, -1, -1.08, -1.1, -1.61, -1.03, -1.08, -1.45, -1.47, -1.41, -1.18, -1.24, },
  {-0.31, -0.45, -0.37, -0.28, -0.32, -0.63, -0.36, -0.26, -0.45, -0.12, -0.2, -0.26, -1.14, -0.29, -0.45, -0.68, -0.45, -0.52, -0.3, -0.43, },
  {0.39, 0.75, 0.59, 0.51, 0.14, 0.13, 0.31, 0.6, 0.31, 0.52, 0.43, 0.76, 0.59, 0.49, 0.18, 0.08, 0.02, 0.46, -0.04, 0, },
  {1.19, 1.52, 1.14, 1.07, 0.69, 0.67, 0.83, 1.05, 0.67, 1.22, 1.52, 1.1, -1.06, 0.98, 0.96, 0.67, 0.82, 0.93, 0.98, 0.86, },
  {1.61, 1.44, 0.87, 1.12, 1.44, 0.9, 0.91, 1.42, 0.86, 1.35, 1.61, 1.05, -0.98, 1.04, 1.08, 0.87, 0.61, 1.33, 1.15, 1.01, },
  {1.4, 2.25, 0.8, 1.16, 1.9, 0.82, 1.34, 2.21, 0.83, 1.7, 1.77, 0.92, -0.6, 1.36, 1.21, 0.82, 0.96, 2.01, 1.54, 1.76, },
  {0.78, 1.25, 0.87, 0.88, 1.03, 0.86, 0.89, 1.53, 0.87, 1.37, 1.51, 1.33, -0.34, 1.24, 0.99, 0.44, 0.99, 1.24, 1.02, 0.98, },
  {0.17, 0.6, 0.2, 0.11, 0.04, 0.97, 0.31, 0.4, 0.13, 0.37, 0.55, 0.59, -0.24, 0.23, 0.22, 0.07, 0.24, 0.07, 0.27, 0.17, },
  {0.34, 0.51, 0.15, 0.14, 0.27, 0.76, 0.11, 0.31, 0.3, 0.55, 0.47, 0.42, 0.35, 0.3, 0.41, -0.09, 0.14, 0.32, 0.68, 0.39, },
  {1.04, 0.99, 1.15, 1.2, 1.04, 1.61, 0.81, 0.92, 1.21, 1.1, 0.62, 1.22, -0.06, 0.94, 0.92, 0.86, 0.97, 0.59, 1.08, 0.65, },
  {1.51, 0.68, 1.58, 1.45, 0.85, 1.51, 1.25, 0.94, 1.43, 1.73, 1.62, 1.99, -0.03, 1.4, 1.49, 1.54, 0.98, 0.53, 1.06, 0.94, },
},
{  {0.49, -0.21, 0.47, -0.02, 0.01, 0.16, 0.18, -0.26, 0.09, -0.02, 0.16, 0.76, -0.8, 0.12, -0.02, 0.37, -0.08, -0.53, -0.22, 0.1, },
  {0.47, 0.15, 0.51, 0.59, 0.43, 0.45, 0.51, 0.34, 0.51, 0.18, 0.23, 0.45, -0.22, 0.44, 0.41, 0.27, 0.37, 0.26, 0.26, 0.48, },
  {-1.1, -0.81, -0.66, -0.92, -0.64, -0.6, -0.9, -0.95, -0.9, -0.89, -0.98, -0.46, -1.25, -0.85, -0.89, -0.96, -0.89, -0.84, -0.88, -0.58, },
  {-0.17, 0.62, 0.52, 0.08, 0.49, 0.55, 0.69, 0.23, 0.29, 0.3, 0.33, 1.04, 0.47, 0.5, 0.21, 0.02, 0.43, 0.31, 0.1, 0.21, },
  {0.27, 0.47, 0.88, 0.35, 0.76, 0.69, 0.42, 0.04, 0.48, 0.25, 0.02, 0.81, -1.23, 0.47, 0.45, 0.33, 0.32, 0.41, 0.09, 0.32, },
  {0.53, 0.85, 0.55, 0.34, 0.64, 0.84, 0.68, 0.47, 0.3, 0.45, 0.66, 0.49, -1.57, 0.83, 0.45, 0.44, 0.18, 0.46, 0.12, 0.59, },
  {0.46, 1.49, 0.71, 0.31, 1.25, 0.68, 1.03, 1.18, 0.33, 0.87, 0.85, 0.88, -1.26, 0.44, 0.54, 0.47, 0.53, 1.21, 0.59, 1.45, },
  {-0.21, 0.39, 0.53, 0.01, 0.72, 0.27, 0.62, 0.32, 0.21, 0.41, 0.24, 0.81, -0.82, 0.29, 0.25, 0.12, 0.48, 0.33, 0.27, 0.67, },
  {-0.15, 0.34, 0.28, -0.07, 0.33, 0.88, 0.34, -0.26, 0.17, 0.09, -0.01, 0.62, -0.1, 0.2, 0.22, 0.29, 0.33, -0.17, -0.01, 0.24, },
  {0.19, 0.24, 0.38, 0.29, 0.33, 0.58, 0.24, -0.16, 0.17, 0.33, 0.14, 0.86, 0.56, 0.39, 0.01, 0.13, 0.26, -0.05, 0.08, 0.54, },
  {0.14, -0.11, 0.66, 0.19, 0.45, 0.77, 0.11, -0.59, 0.17, 0.34, 0.83, 0.96, -0.29, 0.14, 0.32, 0.06, 0.72, 0.11, -0.29, 0.41, },
  {0.26, -0.24, 0.09, -0.28, 0.36, 0.3, -0.07, -0.99, -0.11, -0.11, 0.09, 0.59, -0.22, 0.06, 0.12, 0.37, -0.23, -0.69, 0.03, 0.08, },
},
{  {0.32, 0.53, 0.13, 0.33, 0.05, -0.88, -0.12, -0.19, 0.23, -0.02, -0.25, -0.1, -0.03, 0.09, 0.33, 0.57, 0.12, -0.04, -0.17, -0.09, },
  {1.18, 0.69, 0.57, 1, 0.63, 0.12, 0.54, 1.39, 0.8, 0.88, 1.03, 0.34, 0.8, 0.82, 0.87, 0.63, 0.55, 1.33, 0.69, 0.62, },
  {0.17, 0.45, 0.18, 0.2, 0.31, 0.46, 0.32, 0.77, 0.2, 0.14, -0.01, 0.01, 1.04, -0.07, 0.09, 0.13, 0.13, 1.05, 0.29, 0.29, },
  {1.15, 1.11, 1.36, 1.09, 1.15, 1.27, 1.26, 1.08, 1.08, 1.14, 1.15, 1.06, 0.87, 1.04, 1.08, 1.21, 0.92, 1.6, 0.88, 1.36, },
  {1.28, 1.44, 1.36, 0.87, 1.06, 1.37, 1.16, 1.2, 1.06, 0.75, 1.42, 1, -0.05, 0.84, 1.22, 1.19, 0.87, 1.04, 1.1, 1.47, },
  {0.88, 0.78, 1.05, 1.06, 1.04, 1.25, 1.2, 0.99, 0.95, 0.65, 0.83, 0.7, 0.24, 1.15, 1, 1.03, 0.39, 0.95, 0.95, 1.28, },
  {1.21, 1.42, 1.14, 1.27, 2.02, 0.96, 1.45, 1.85, 1.04, 1.34, 1.16, 1.09, 0.42, 1.02, 1.13, 0.97, 1.07, 1.93, 1.52, 1.87, },
  {1.1, 0.97, 0.88, 0.93, 1.56, -0.18, 0.94, 1.79, 0.82, 1.49, 0.97, 0.59, 0.5, 0.84, 0.86, 1.15, 1.37, 1.76, 1.7, 1.36, },
  {1.17, 1.53, 1.07, 1.35, 1.39, -0.27, 1.36, 2.01, 1.39, 1.93, 0.93, 0.8, 1.22, 1.16, 1.25, 1.4, 1.29, 1.38, 1.72, 1.91, },
  {1.32, 0.62, 1.07, 1.48, 1.31, 0, 0.98, 1.22, 1.39, 1.31, 1.13, 0.45, 1.23, 0.95, 1.15, 0.99, 1.01, 1.54, 0.39, 1.02, },
  {1.5, 0.51, -0.32, -0.24, 0.29, -1.17, 0.29, 0.85, 0.21, 0.34, 0.31, -0.18, 0.88, -0.52, -0.19, -0.09, 0.35, 0.2, -0.25, 0.79, },
  {-0.07, -0.26, -0.13, -0.13, 0.23, -0.11, -0.04, -0.08, -0.34, 0.12, 0.34, -0.16, -0.55, 0, -0.06, 0.18, -0.44, 0.82, 0.23, 0.1, },
},
{  {0.6, 0.52, 0.03, 0.36, 0.39, -1.02, 0.37, 0.88, 0.22, 0.52, 0.18, -0.37, 0.49, 0.06, 0.23, 0.83, 0.59, 1.09, 0.19, 0.31, },
  {2.35, 1.73, 1.09, 1.97, 1.23, 0.45, 1.09, 2.63, 1.78, 2.06, 1.74, 0.67, 1.17, 1.79, 1.95, 1.48, 1.34, 2.18, 1.64, 1.26, },
  {1.6, 0.99, 0.99, 1.44, 1.25, 1.02, 1.24, 1.11, 1.26, 0.94, 1.01, 0.79, 0.77, 0.89, 1.3, 1.37, 1.46, 1.33, 1.05, 0.83, },
  {1.2, 0.96, 1.34, 1.25, 1.04, 1.35, 0.9, 0.99, 1.41, 1.27, 0.98, 0.97, -0.97, 1.4, 1, 1.81, 1.36, 1.18, 1.04, 1.01, },
  {1.05, 1.27, 1.39, 1.4, 1.25, 1.61, 1.77, 1.06, 1.34, 0.98, 0.96, 1.2, 1.69, 1.41, 1.32, 1.46, 1.54, 1.06, 1.17, 1.2, },
  {0.81, 0.85, 1.04, 1.01, 1.02, 1.26, 1.28, 0.68, 1.02, 0.48, 1.01, 0.57, 1.48, 1.22, 0.95, 1.22, 1.01, 1.02, 1.57, 1.3, },
  {0.98, 1.24, 1.24, 0.82, 1.07, 0.84, 0.81, 1, 1, 1.03, 1.29, 0.82, 0.79, 1.02, 0.94, 1.19, 1.24, 0.96, 1.27, 1.25, },
  {0.84, 0.73, 0.83, 0.53, 0.94, -0.68, 0.42, 1.3, 0.42, 1.05, 0.76, 0.06, 1.03, 0.49, 0.43, 1.07, 1.43, 1.3, 0.7, 1.15, },
  {0.96, 0.48, 0.47, 0.99, 0.76, -1.43, 0.45, 1.6, 0.43, 0.95, 0.41, -0.18, 0.92, 0.38, 0.61, 1.13, 1.37, 1.43, 1.1, 0.94, },
  {1.18, 0.65, 0.96, 1.33, 0.42, -0.76, 1.06, 0.97, 1.34, 1.67, 0.29, 0.05, 1.2, 0.87, 0.58, 1.38, 0.9, 0.89, 0.56, 0.44, },
  {0.46, 0.25, 0.59, 0.36, 0.48, -0.36, 0.18, 2.4, 0.44, 0.63, -0.12, 0.08, 0.39, 0.22, 0.66, 1.05, 0.49, 1.15, 0.4, 1.05, },
  {0.74, 0.92, 0.4, 0.09, 0.8, -0.14, 0.28, 0.87, 0.41, 0, 0.56, -0.16, 0.36, -0.05, 0.71, 0.93, 0.57, 0.7, 0.45, 0.54, },
},
{  {-0.23, 0.17, -0.34, -0.15, -0.03, 0.17, -0.06, 0.49, -0.03, 0.15, 0.11, -0.4, 0.36, -0.2, -0.04, 0.47, 1.11, 0.64, 0.04, 0.03, },
  {3.06, 2.19, 1.63, 2.67, 1.66, 1.49, 1.5, 2.66, 2.61, 2.71, 2.5, 1.26, 0.62, 2.49, 2.56, 2.58, 2.67, 2.51, 2.23, 1.73, },
  {1.51, 1.16, 0.9, 1.4, 0.57, 1.57, 1.01, 0.25, 1.44, 0.76, 1.17, 0.63, 0.1, 1.45, 1.39, 1.67, 1.19, 0.48, 0.78, 0.77, },
  {0.7, 0.21, 0.2, 0.71, -0.13, 1.53, 0.48, -0.06, 0.93, 0.13, 0.54, 0.27, -0.32, 0.64, 0.58, 0.99, 0.77, -0.04, 0.49, 0.34, },
  {0.61, 0.67, 0.12, 0.51, 0.28, 1.28, 0.78, 0.11, 0.6, 0.09, 0.39, 0.24, 0.84, 1.05, 0.56, 0.89, 1.05, 0.19, -0.09, 0.2, },
  {0.18, 0.11, 0.15, 0.12, 0.34, 0.58, 0.28, 0.23, 0.41, 0.16, 0.23, 0.04, 0.91, 0.27, 0.35, 0.4, 0.78, 0.36, 0.09, 0.14, },
  {-0.18, -0.11, -0.12, -0.22, -0.25, 0.19, -0.12, -0.27, 0.09, -0.33, -0.23, -0.32, 0.11, -0.07, -0.09, 0.06, 0.21, -0.18, -0.24, -0.17, },
  {0.04, -0.16, -0.2, -0.3, -0.29, -0.27, -0.14, -0.39, -0.23, -0.36, -0.15, -0.35, -0.25, -0.24, -0.21, 0.5, 0.37, -0.39, -0.16, -0.31, },
  {0.4, -0.02, 0.21, 0.09, -0.06, -0.42, 0.3, -0.21, 0.15, -0.15, 0.1, -0.16, -0.06, -0.02, 0.18, 0.71, 0.66, -0.29, -0.04, 0.04, },
  {0.66, 0.81, 0.53, 0.46, 0.13, 0.11, 0.42, 0.26, 0.51, 0, 0, 0.23, -0.1, 0.13, 0.64, 0.63, 0.93, 0.23, -0.09, 0.14, },
  {0.43, 0.11, 0.42, 0.62, 0.5, 1.02, 0.65, 0.11, 0.55, 0, 0.12, 0.16, -0.27, 0.3, 0.41, 0.72, 0.98, 0.13, 0.35, 0.52, },
  {0.21, 0.59, 0.31, 0.19, 0.23, 0.18, 0.06, 0.06, 0.39, -0.03, -0.34, 0.11, -0.23, 0.87, -0.03, 0.81, 0.6, 0.11, -0.25, 0.11, },
},
{  {-0.56, 0.25, -0.42, -0.36, 0.1, 1.05, 0.05, 0.01, -0.38, -0.21, -0.35, -0.18, 0.09, -0.41, -0.31, -0.21, 0.5, -0.04, -0.1, 0.19, },
  {3.05, 2, 1.87, 2.77, 1.83, 2.24, 1.76, 2.44, 2.67, 2.65, 3.01, 1.47, 0.86, 2.77, 2.69, 2.04, 2.14, 2.55, 2.29, 1.72, },
  {1.32, 0.55, 0.16, 1.15, 0.46, 1.41, 0.74, 0.3, 1.26, 0.72, 0.94, 0.12, 0.4, 1.03, 1.1, 0.92, 0.7, 0.52, 0.48, 0.48, },
  {-0.06, -0.3, -0.72, -0.02, -0.14, 0.78, 0.03, -0.03, 0.24, -0.04, 0.21, -0.71, -0.69, 0.09, 0.23, 0.05, 0.16, 0.01, -0.27, -0.05, },
  {-0.07, -0.01, -0.35, -0.03, 0.06, 0.18, 0.17, 0.22, 0.27, -0.07, 0.01, -0.29, 0.18, -0.27, 0.09, 0.02, 0.07, 0.28, -0.24, 0.02, },
  {-0.5, -0.07, -0.4, -0.33, -0.08, -0.4, -0.05, -0.01, 0.07, -0.18, -0.32, -0.4, 1.09, -0.34, -0.17, -0.35, 0.09, 0.14, -0.18, -0.16, },
  {-1.01, -0.86, -0.93, -0.99, -0.88, -0.84, -0.91, -0.81, -0.72, -1.04, -0.97, -1.05, 0.04, -0.85, -0.84, -0.75, -0.7, -0.72, -0.88, -0.91, },
  {-0.58, -0.56, -0.72, -0.74, -0.71, 0.15, -0.66, -0.67, -0.59, -0.85, -0.68, -0.84, -0.06, -0.71, -0.66, -0.27, -0.53, -0.61, -0.73, -0.73, },
  {0.02, -0.17, -0.28, -0.04, -0.18, 1.01, -0.18, -0.19, -0.02, -0.28, -0.08, -0.43, -0.09, -0.05, -0.24, 0.13, 0.01, 0.03, -0.5, -0.32, },
  {0.25, 0.06, -0.22, 0.38, 0.01, 1.25, 0.31, 0.09, 0.21, -0.21, -0.06, -0.17, -0.1, 0.12, 0, 0.11, -0.05, 0.16, -0.23, 0.02, },
  {-0.01, -0.08, -0.15, 0.37, -0.11, 1.56, 0.29, 0.13, -0.12, -0.39, -0.51, -0.08, -0.27, -0.04, 0.05, 0.44, -0.21, -0.19, -0.38, -0.06, },
  {-0.13, -0.07, -0.14, -0.19, 0.06, 0.61, -0.08, -0.05, -0.08, -0.29, -0.18, 0.1, 0.15, -0.14, -0.27, 0.01, 0.36, -0.11, -0.48, -0.05, },
},
{  {-0.57, -0.48, 0.22, -0.22, -0.3, 1.17, -0.26, 0.05, -0.02, -0.42, -0.05, 0.02, -0.03, 0.02, -0.05, -0.28, -0.78, 0.05, -0.35, -0.26, },
  {1.88, 1.52, 1.36, 2, 1.21, 1.59, 1.13, 2.15, 1.81, 1.45, 1.78, 1.16, 1.16, 2, 1.87, 1.19, 1.1, 2.04, 1.8, 1.23, },
  {0.73, -0.09, 0.33, 0.71, 0.02, 0.66, 0.23, 0.1, 0.6, 0.21, 0.31, 0.2, 0.94, 0.48, 0.62, 0.37, 0.03, 0.09, 0.23, 0.13, },
  {-0.54, -0.58, -0.8, -0.65, -0.35, 0.05, -0.96, -0.52, -0.62, -0.63, -0.53, -0.76, -0.34, -0.69, -0.62, -0.61, -0.49, -0.49, -0.19, -0.59, },
  {-0.85, -0.77, -1.03, -0.86, -0.75, -0.44, -1, -0.81, -0.67, -0.82, -0.64, -0.96, 1.71, -0.66, -0.7, -0.67, -0.59, -0.75, -0.73, -0.75, },
  {-0.79, -0.55, -0.48, -0.45, -0.88, -0.59, -0.62, -0.53, -0.47, -0.5, -0.66, -0.58, 1.18, -0.49, -0.5, -0.45, -0.23, -0.54, -0.55, -0.73, },
  {-0.49, -0.39, -0.01, -0.53, -0.59, -0.09, -0.55, -0.41, -0.45, -0.38, -0.49, -0.29, 0.41, -0.58, -0.44, -0.26, -0.15, -0.4, -0.53, -0.62, },
  {-0.25, -0.35, -0.01, -0.36, -0.39, 0.62, -0.42, -0.42, -0.29, -0.46, -0.44, -0.12, 0.24, -0.4, -0.35, -0.16, -0.07, -0.25, -0.44, -0.39, },
  {-0.35, -0.44, -0.54, -0.27, -0.4, 1.15, -0.64, -0.46, -0.22, -0.49, -0.46, -0.39, -0.08, -0.35, -0.3, -0.33, -0.27, -0.27, -0.38, -0.47, },
  {-0.35, -0.89, -0.55, -0.17, -0.44, 0.73, -0.5, -0.5, -0.24, -0.51, -0.27, -0.53, -0.24, -0.38, -0.24, -0.17, -0.17, -0.32, -0.45, -0.45, },
  {-0.26, 0.09, -0.13, -0.43, -0.29, 0.92, -0.09, -0.68, -0.13, -0.18, 0.75, -0.04, 0.3, -0.01, -0.29, -0.36, -0.28, -0.07, -0.53, -0.55, },
  {-0.81, -0.36, 0.25, -0.35, -0.7, 0.32, 0.11, -0.48, -0.24, -0.45, -0.28, 0.74, 0.02, -0.27, -0.32, -0.29, -0.09, -0.22, -0.42, -0.27, },
},
{  {-0.43, -0.37, -0.18, -0.27, -0.55, 0.87, -0.27, -0.56, -0.28, -0.25, -0.46, -0.25, 0.47, -0.1, -0.21, -0.75, -0.39, -0.37, 0.22, -0.48, },
  {1, 0.81, 0.37, 0.95, 0.67, 1.19, 0.23, 1.26, 1.03, 0.79, 1.14, 0.08, 2.18, 0.82, 0.94, 0.81, 0.84, 1.19, 1.16, 0.31, },
  {0.23, -0.2, 0, 0.25, -0.24, 0.3, -0.09, -0.04, 0.23, -0.19, 0.03, -0.11, 1.86, 0.15, 0.28, 0.18, -0.13, -0.12, 0.14, -0.33, },
  {-0.91, -0.84, -0.5, -0.93, -0.74, -0.6, -0.8, -1.01, -0.96, -1.13, -1.09, -0.83, 0.3, -1.16, -0.65, -0.7, -0.71, -0.79, -0.54, -0.4, },
  {-1.21, -1.15, -0.72, -1.2, -1.2, -0.93, -1.08, -1.02, -1.05, -1.12, -1.16, -0.91, 0.86, -1.11, -1.13, -0.86, -0.79, -0.94, -0.95, -0.99, },
  {-0.88, -0.88, -0.35, -0.8, -1.15, -0.48, -0.9, -0.8, -0.69, -0.81, -0.96, -0.35, 1.26, -0.91, -0.88, -0.56, -0.73, -0.82, -1.05, -0.95, },
  {-0.12, -0.21, 0.23, -0.16, -0.32, 0.16, -0.08, 0.05, -0.21, 0.05, -0.35, -0.05, 0.82, -0.15, -0.31, -0.04, -0.39, 0.03, -0.07, -0.21, },
  {-0.46, -0.31, -0.14, -0.23, -0.4, 0.28, -0.29, -0.14, -0.26, -0.41, -0.59, -0.21, 0.4, -0.44, -0.32, -0.88, -0.94, -0.07, -0.23, -0.25, },
  {-0.69, -0.77, -0.53, -0.53, -0.38, 0.62, -0.7, -0.55, -0.58, -0.67, -0.75, -0.4, -0.01, -0.5, -0.67, -1.03, -1.1, -0.35, -0.01, -0.47, },
  {-0.83, -0.62, -0.49, -0.79, -0.58, -0.03, -0.94, -0.67, -0.66, -0.9, -1.04, -0.42, -0.07, -0.79, -0.76, -0.77, -0.84, -0.68, -0.77, -0.85, },
  {-0.63, -0.77, 0.02, -0.55, -1.05, 0.3, -0.72, -0.91, -0.26, -0.83, -1.2, -0.03, 0.27, -0.04, -0.7, -0.51, -0.67, -0.52, 0.15, -1.02, },
  {-0.55, -0.58, 0.12, 0.11, -0.67, 0.14, -0.46, -0.27, -0.2, -0.29, -0.74, 0.27, 0.37, -0.33, -0.22, -0.86, -0.58, -0.46, -0.03, -0.35, },
},
{  {-1.02, -0.55, -0.37, -0.84, -0.57, 0.22, -0.73, -0.11, -0.41, -0.31, -0.68, -0.37, 1.08, -0.79, -1.01, -0.58, -0.14, -0.35, -0.38, -0.76, },
  {1.88, 1.23, 1.6, 1.82, 0.9, 0.8, 0.77, 1.66, 1.6, 1.96, 1.47, 0.86, 2.86, 1.66, 1.41, 1.16, 1.21, 1.36, 1.16, 1.02, },
  {0.45, -0.26, 0.45, 0.53, -0.21, -0.42, 0.05, 0.22, 0.34, -0.07, -0.18, 0.42, 1.87, -0.01, 0.21, 0.47, 0.14, 0.13, 0.14, -0.22, },
  {-0.72, -0.59, -0.17, -0.59, -0.63, -1.03, -0.45, -0.1, -0.64, -0.67, -1.24, -0.68, 0.72, -0.51, -0.49, -0.63, -0.66, -0.2, -0.66, -0.79, },
  {-0.95, -1.13, -0.77, -0.51, -0.73, -0.9, -0.97, -0.34, -0.42, -0.55, -1.48, -1.2, 0.68, -0.82, -0.92, -0.89, -1.29, -0.78, 0.05, -0.8, },
  {-0.61, -1.04, -1.09, -0.73, -0.66, -0.53, -1.06, -0.2, -0.45, -0.68, -0.94, -1.16, 1.03, -0.6, -0.82, -0.69, -1.03, -0.61, -0.62, -0.67, },
  {0.24, -0.13, -0.48, 0.04, 0.17, -0.17, -0.01, 0.56, -0.02, -0.04, 0.43, -0.37, 0.91, -0.1, -0.05, -0.14, -0.24, 0.64, 0.26, 0.29, },
  {-0.61, -0.48, -0.87, -0.06, 0.07, -0.13, 0.08, 0.96, -0.02, -0.13, 0.17, -0.86, 0.32, -0.29, -0.13, -0.3, -0.23, 0.69, 0.32, 0.06, },
  {-0.56, -0.48, -0.27, -0.19, -0.28, 0.28, -0.25, 0.64, -0.32, -0.36, -0.85, -0.53, 0.31, -0.48, -0.21, -0.49, -0.09, 0.19, 0.42, -0.18, },
  {-0.79, -0.6, -0.13, -0.1, -0.74, -0.27, -0.64, -0.44, -0.32, -0.7, -0.13, -0.58, 0.22, -0.55, -0.03, -0.3, -0.26, -0.52, -0.4, -0.5, },
  {-1.16, -1.27, -0.76, -0.83, -1.23, 0.16, -0.92, -0.66, -0.78, -1.05, 0.15, -1.12, 0.29, -0.9, -0.58, -0.84, -0.58, -0.4, -0.04, -0.65, },
  {-0.97, -0.63, -1.18, -0.97, -1.39, -0.3, -1.07, 0.12, -0.71, -1.09, -1.75, -1.16, 0.55, -1.24, -0.71, -1.38, -1.36, -0.87, -1.2, -1.2, },
},
{  {-0.64, -0.62, -0.57, 0.72, 0.02, -0.11, 0.01, 0.64, -0.19, -0.05, 0.06, -0.67, 0.44, -0.25, -0.34, -0.68, -0.17, 0.32, 0.59, 0.72, },
  {2.24, 1.41, 2.3, 2.71, 1.41, 0.32, 1.22, 2.33, 2.08, 2.28, 2.6, 1.26, 3.03, 2.46, 1.87, 1.74, 1.43, 3.06, 2.18, 1.83, },
  {0.5, -0.2, 0.71, 1.14, 0.1, -0.8, 0.4, 1.42, 1.08, 0.83, -0.17, 0.17, 1.84, 0.58, 1.05, 0.56, 0.72, 0.74, 0.99, 0.7, },
  {0.17, -0.07, 0.46, 0.4, 0.41, -1.11, 0.31, 0.59, 0.48, 0.46, -0.18, -0.12, 0.28, 0.73, -0.11, 0.46, -0.08, 0.44, 0.75, -0.01, },
  {-0.15, -0.87, -0.45, -0.01, -0.34, -0.56, 0.49, 0.29, 0.58, 0.2, 0.15, -0.19, 0.46, -0.2, 0.43, -0.19, -0.34, 0.3, -0.15, -0.18, },
  {-0.6, -0.68, -0.65, -0.62, -0.43, -0.16, -0.38, -0.69, -0.38, -0.82, -0.19, -0.75, 1.1, -0.91, -0.28, -0.47, -0.51, -0.65, -0.24, 0.02, },
  {-0.18, -0.33, -0.31, 0, 0.03, -0.44, -0.35, 0.29, 0.22, -0.01, 0.26, -0.42, 1.63, -0.36, -0.28, -0.16, 0.07, 0.34, 0.47, 0.09, },
  {0.08, 0.81, 0.24, 0.17, 0.2, -0.14, -0.3, 0.7, 0.37, 0.37, -0.42, -0.21, 1.49, -0.08, 0.52, 0.06, 0.42, 0.95, -0.13, 0.27, },
  {0.74, -0.55, 0.74, 0.74, -0.13, 0.15, 0.29, 0.98, 0.61, 0.71, 0.12, -0.3, 1.71, 0.36, 0.22, 0.36, 0.59, 1.18, 0.58, 0.21, },
  {0.29, 0.5, 0.27, 0.44, -0.17, -0.69, -0.55, 0.41, 0.5, -0.2, -0.3, -0.33, 2.03, 1.04, 0.06, 0.58, 0.75, 2.16, -0.53, -0.25, },
  {-1.44, -1.4, -1.63, -0.96, -1.26, -0.52, -1.88, 0.04, -1.51, -0.99, -2.32, -2.15, 1.39, -1.45, -1.22, -1.21, -1.19, -0.66, -1.27, -1.38, },
  {-2.01, -1.61, -2.45, -2.25, -1.2, -0.93, -2.06, -0.28, -2.17, -1.84, -2.04, -2.91, -0.18, -2.42, -2.35, -1.57, -0.92, -0.46, -1.05, -2.13, },
},
{  {-0.39, -0.77, 0.09, -0.48, -0.35, -0.89, -0.58, 0.09, -0.54, -0.25, -1.6, -0.57, -0.27, -0.34, -0.76, -0.47, -0.02, -0.06, -0.68, 0.1, },
  {1.44, 1.36, 0.94, 1.13, 0.85, -0.15, 0.56, 0.98, 1.3, 1.21, 0.64, 0.7, 1.83, 1.32, 1.07, 0.7, 0.6, 1.24, 1.13, 1.09, },
  {-0.28, -0.58, 0.17, 0.18, -0.28, -0.79, -0.73, -0.18, 0.23, -0.11, -0.3, -0.32, 0.93, -0.14, 0.16, 0.12, -0.58, -0.45, -0.35, -0.26, },
  {-0.59, -1.32, -0.41, -1.09, -1.15, -0.78, -0.97, -0.29, -0.46, -0.59, -1.18, -1.08, -1.73, -0.92, -0.92, -0.91, -0.84, -0.24, -0.71, -0.98, },
  {-0.65, -0.33, -0.26, -0.83, -1.15, 0.04, -1.45, -0.4, -0.93, -0.61, -1.36, -0.9, -0.16, -1.05, -0.62, -0.75, -0.59, -0.34, -0.51, -1.59, },
  {-1.42, -1.47, -1.61, -1.89, -1.66, -1, -1.91, -1.84, -1.95, -2.21, -1.65, -1.8, 0.23, -2.01, -1.74, -1.44, -1.38, -1.82, -1.56, -1.78, },
  {-1.16, -1, -1.23, -1.04, -0.73, -1.3, -0.81, -0.87, -1.1, -1.16, -0.8, -1.1, 0.27, -1.09, -1.13, -1.13, -1.05, -0.74, -0.96, -0.85, },
  {-1.11, -0.95, -1.26, -0.64, -1.1, -0.88, -0.75, -0.12, -0.76, -0.32, -1.04, -0.81, 0.06, -0.88, -0.71, -1.12, -0.78, -0.16, -0.66, -0.94, },
  {-0.89, -0.82, -0.53, -0.7, -0.91, -0.1, -0.83, -0.2, -0.54, -0.14, -0.29, -1.01, 0.33, -0.91, -0.52, -0.46, -0.43, -0.43, -0.47, -0.57, },
  {-1.14, -2, -1.22, -1.13, -1.32, -1.31, -1.18, -0.66, -1.1, -1.04, -1.12, -1.51, 0.02, -1.35, -1.28, -0.67, -1.35, -0.99, -1.11, -1.62, },
  {-2.43, -1.55, -2.27, -2.12, -2.34, -1.74, -2.52, -1.03, -1.9, -2.01, -2.22, -2.1, -1.02, -2.18, -2.29, -1.69, -2.25, -1.04, -2.33, -1.91, },
  {-1.05, -2.17, -0.23, -0.5, -1.25, -1.53, -0.39, -1.17, -0.55, -0.84, -0.25, -0.82, -0.66, -0.74, -0.66, -0.79, -1.72, 0.08, -0.02, -0.97, },
},
};


float ethph1[12][10][20]  = {
{  {-3.12, -3.04, -1.18, -3.5, -2.96, -1.32, -2.78, -3.81, -2.83, -2.55, -3.75, -1.58, -2.55, -2.48, -3.47, -3.22, -1.69, -2.49, -2.62, -2.85, },
  {-0.58, -3.04, 0.17, -0.86, -1.71, 0.51, -1.39, -1.03, -1.25, -0.38, -1.8, -0.04, -1.92, -0.49, -1.07, -0.7, -1.1, -0.95, -1.12, -0.08, },
  {1.52, 1.41, 0.78, 1.23, 1.21, 0.57, 1.01, 1.97, 1.21, 1.3, 1.09, 0.57, -0.38, 1.23, 1.61, 1.3, 1.77, 2.06, 0.97, 1.1, },
  {1.03, 0.45, 0.35, 0.87, 0.73, -0.38, 0.67, 1.02, 0.96, 0.79, 0.59, 0.16, -0.5, 0.81, 0.89, 0.84, 0.58, 1.07, 0.64, 0.8, },
  {-0.99, -1.08, -0.54, -1.06, -1.26, 0.33, -0.85, -1.03, -1.08, -1.25, -1.05, -0.47, -0.6, -1.11, -1.03, -0.9, -1.21, -0.97, -1.14, -1.27, },
  {0.04, -0.04, -0.14, -0.05, 0.06, 0.43, -0.15, 0.1, 0, 0.22, 0.21, -0.15, 1.24, -0.16, -0.11, 0.37, 0.12, 0.11, -0.27, -0.04, },
  {0.39, 1.04, 0.14, -0.12, 0.65, 0.39, 0.44, 0.2, 0.16, 0.14, 0.44, 0.62, 2.16, 0.16, 0.26, 0.47, 0.97, 0.3, 0.34, 0.81, },
  {-1.16, 0.2, -0.56, -1.2, -0.16, 0.15, -0.46, -0.85, -1.02, -1.12, -0.73, -0.08, 1.11, -1, -0.96, -0.57, -0.16, -0.72, -0.37, -0.09, },
  {-1.78, -0.56, -1.2, -1.7, -0.23, 0.57, -0.52, -1.44, -1.49, -1.46, -1.52, -0.82, -0.57, -1.32, -1.41, -1.29, -0.69, -1.18, 0.02, -0.29, },
  {-2.36, -1.5, -0.79, -1.89, -0.81, 0.82, -0.87, -2.02, -0.89, -1.54, -2.59, -1.55, -2.55, -1.18, -1.16, -0.95, -0.56, -1.11, -1.12, 0.43, },
},
{  {0.63, -1.2, 0.84, -0.76, -0.33, 0, -1.04, -1.02, -0.2, 0.6, -0.81, -0.67, -1.63, 0.32, -0.86, -1.26, 0.14, -0.07, -0.34, -1.05, },
  {1.1, -1.2, 0, 1.88, 0.23, -0.12, 0.35, 0.14, 0.98, 0.82, 1.13, 0.65, -1.45, 0.52, 0.44, 1.96, 0.25, -0.14, 0.06, 0.63, },
  {-0.33, -0.66, -0.34, -0.24, -0.51, -0.5, -0.35, -0.68, -0.34, -0.44, -0.42, -0.27, -1.01, -0.33, -0.4, -0.42, -0.65, -0.78, -0.48, -0.54, },
  {-0.44, -0.81, -0.5, -0.42, -0.69, -0.46, -0.6, -0.77, -0.48, -0.5, -0.52, -0.47, -0.59, -0.46, -0.5, -0.71, -0.79, -0.87, -0.64, -0.71, },
  {0.92, 0.6, 0.95, 0.67, 0.47, 0.44, 0.35, 0.92, 0.61, 0.78, 0.72, 0.47, 1.03, 0.79, 0.67, 0.35, 0.34, 0.74, 0.74, 0.4, },
  {3.43, 2.35, 1.91, 2.86, 2.31, 1.57, 2.01, 2.73, 2.65, 3.19, 3.06, 1.74, 3.13, 2.89, 2.7, 2.51, 2.49, 2.57, 2.62, 2.32, },
  {3.19, 2.57, 1.9, 2.49, 2.21, 1.24, 2.09, 2.43, 2.7, 2.76, 2.97, 1.91, 4.06, 2.77, 2.59, 2.49, 2.39, 2.4, 2.62, 2.22, },
  {2.46, 1.77, 1.45, 1.82, 1.41, 0.58, 1.15, 1.97, 1.81, 2.06, 2.26, 1.39, 2.03, 2.01, 1.94, 1.41, 1.41, 1.71, 1.83, 1.33, },
  {2.57, 1.96, 2.03, 2.02, 1.69, 1.05, 1.22, 1.54, 1.71, 2.34, 2.41, 1.55, -0.06, 1.86, 1.89, 1.48, 1.29, 1.82, 2, 1.5, },
  {1.96, 1.44, 0.95, 1.95, 1.98, 1.77, 1.56, 0.36, 1.75, 1.61, 1.96, 2.36, -0.94, 1.21, 1.44, 1.11, 1.26, 1.32, 1.16, 1.31, },
},
{  {-1.15, -2.62, -0.38, -2.45, -2.02, -1.08, -2.49, -3.03, -1.82, -2.05, -2.6, -1.39, -2.53, -2.49, -2.55, -2.25, -2.36, -1.99, -2.52, -2.72, },
  {-1.17, -2.62, -1.23, -1.01, -2.15, -1.45, -1.8, -1.87, -1.34, -1.67, -2.27, -1.35, -0.52, -1.35, -1.54, -1.23, -0.45, -2.15, -1.7, -1.89, },
  {-0.83, -1.05, -0.84, -0.83, -0.94, -0.91, -1.01, -0.84, -0.87, -0.76, -0.75, -0.83, -1.2, -0.83, -0.89, -1.1, -1.09, -0.9, -0.97, -1.02, },
  {0.17, 0.07, 0.08, 0.17, 0.07, 0.32, 0.02, 0.21, 0.16, 0.14, 0.08, 0.15, -0.18, 0.22, 0.15, 0, 0.01, 0.07, 0.16, 0.04, },
  {0.52, 0.32, 0.46, 0.73, 0.4, 0.53, 0.53, 0.07, 0.43, 0.43, 0.12, 0.29, 0.39, 0.34, 0.36, 0.58, 0.39, 0.13, 0.38, 0.29, },
  {1.07, 0.89, 0.53, 0.98, 0.73, 0.81, 0.82, 0.25, 1.02, 0.92, 0.99, 0.4, 1.67, 1.01, 1.07, 1.15, 0.78, 0.4, 0.71, 0.86, },
  {0.59, 0.11, 0.59, 0.52, 0.05, 0.42, 0.41, 0.26, 0.56, 0.16, 0.53, 0.3, 1.55, 0.51, 0.6, 0.82, 0.44, 0.25, 0.29, 0.23, },
  {0.85, 0.13, 0.6, 0.34, -0.04, -0.21, 0.16, 0.1, 0.34, -0.17, 0.2, 0.09, 0.21, 0.2, 0.48, 0.44, 0.17, 0.14, 0.11, -0.06, },
  {0.85, 0.48, 0.51, 0.7, 0.59, -0.53, 0.57, -0.08, 0.24, 0.57, 0.35, 0.99, -0.55, 0.12, 0.22, 0.84, 0.13, 0.4, 0.63, 0.61, },
  {1.96, 0.02, 0.42, -0.66, 0.69, -0.05, 0.11, -0.55, -0.57, -1.04, -0.52, -0.15, -2.53, 0.6, -0.25, 1.73, -0.14, -0.6, 0.38, 0.56, },
},
{  {-2.48, -2.9, -2.23, -3.41, -2.66, -1.51, -3.17, -3.27, -2.35, -1.8, -3.08, -2.09, -4.78, -2.02, -3.18, -2.85, -2.35, -2.13, -2.47, -3.3, },
  {-1.32, -2.9, -0.88, -1.62, -1.41, -0.38, -1.79, -1.89, -1.17, -1.83, -1.14, -0.95, -2.07, -0.72, -1.48, -1.24, -1.41, -0.59, -0.96, -1.22, },
  {1.18, 1.18, 1.08, 1.04, 0.82, 1.02, 0.85, 1.09, 1.18, 1.22, 1.27, 1.19, 0.23, 1.54, 1.17, 0.75, 0.99, 1.1, 0.82, 0.63, },
  {0.4, 0.83, 0.61, 0.56, 0.38, 0.99, 0.66, 0.69, 0.55, 0.52, 0.44, 0.72, -0.24, 0.61, 0.37, 0.35, 0.34, 0.53, 0.12, 0.32, },
  {-0.46, -0.15, -0.5, -0.27, -0.22, 0.57, -0.13, -0.59, -0.09, -0.21, -0.21, -0.35, -0.54, -0.14, -0.3, -0.03, -0.17, -0.36, -0.36, -0.25, },
  {-0.7, -0.51, -0.63, -0.61, -0.55, 0.07, -0.63, -0.51, -0.4, -0.69, -0.73, -0.6, 0.15, -0.71, -0.48, -0.47, -0.47, -0.5, -0.44, -0.32, },
  {-0.85, -0.69, -0.49, -0.88, -0.47, -0.45, -0.57, -0.09, -0.8, -0.58, -0.68, -0.58, 0.06, -0.91, -0.6, -0.57, -0.16, -0.1, -0.47, -0.44, },
  {-0.22, 0.09, -0.27, -0.74, 0.16, -0.51, -0.23, 0.09, -0.83, -0.38, -0.04, -0.67, -0.43, -0.6, -0.4, 0.11, -0.07, 0.14, 0.59, 0, },
  {-0.11, 0.08, -0.29, -0.56, 0.27, -1.05, 0.06, 0.06, -0.15, 0.78, -0.13, -0.72, -2.8, -0.21, -0.35, 0.15, -0.05, -0.19, 0.74, 0.46, },
  {-0.75, -0.26, -1.03, -0.7, 0.04, -1.2, -0.97, -0.79, 0.29, -0.79, -0.31, -1.14, -4.78, -0.72, -1.17, -0.57, -0.53, -1.44, -0.27, -0.71, },
},
{  {-1.85, -2.89, -2.63, -3.53, -2.54, -1.64, -3.21, -3.38, -3.35, -2.75, -3.26, -2.23, -3.91, -2.25, -3.27, -2.95, -1.69, -2.35, -2.45, -3.25, },
  {-1.38, -2.89, -1, -0.49, -1.98, -0.92, -1.83, -1.3, -0.78, -0.58, -1.32, -0.69, -1.2, -0.95, -1.57, -0.83, -0.59, -0.11, -0.94, -1.17, },
  {1.6, 2.66, 1.61, 1.28, 0.88, 1.22, 1.07, 0.9, 1.27, 1.24, 1.25, 1.37, -0.33, 1.54, 1.49, 1.18, 1.13, 1.24, 1.22, 0.67, },
  {1.11, 1, 1.13, 1.08, 0.91, 1.49, 0.88, 0.94, 0.83, 0.84, 1.14, 1.17, -0.53, 0.91, 0.98, 0.89, 0.91, 0.86, 0.84, 0.94, },
  {-0.55, -0.15, -0.47, -0.47, -0.08, 0.83, 0.01, -0.45, -0.27, -0.39, -0.42, -0.31, -0.3, -0.21, -0.42, -0.04, -0.15, -0.37, -0.33, -0.31, },
  {-1.07, -0.27, -0.83, -1.01, -0.61, -0.38, -0.51, -0.55, -0.73, -0.71, -0.93, -0.75, 1.64, -0.96, -0.9, -0.68, -0.46, -0.5, -0.59, -0.5, },
  {-0.71, -0.32, -0.43, -0.93, -0.21, -0.47, -0.45, -0.13, -0.72, -0.58, -0.32, -0.7, 0.48, -0.76, -0.61, -0.38, -0.06, -0.04, -0.43, -0.23, },
  {-0.42, -0.38, -0.58, -0.51, 0.16, -0.16, -0.22, -0.12, -0.51, -0.5, -0.32, -0.57, -0.65, -0.61, -0.36, -0.15, -0.11, -0.25, -0.02, 0.25, },
  {-1.03, -0.91, -1.21, -0.93, -1.12, -1.25, -1.2, -0.85, -1.02, -1.25, -1.45, -1.25, -3.32, -0.87, -0.86, -0.67, -1.23, -0.73, -0.92, -0.99, },
  {-1.37, -1.64, -1.37, -1.93, -1.63, -1.67, -2, -2.28, -1.81, -2.44, -0.49, -1.84, -3.91, -1.65, -1.26, -1.23, -1.86, -1.65, -1.86, -2.05, },
},
{  {-1.45, -2.41, -1.18, -3.2, -1.82, -1.41, -2.7, -2.63, -2.26, -1.55, -2.75, -1.89, -1.48, -1.86, -2.82, -2.58, -0.97, -1.35, -1.85, -2.51, },
  {-0.52, -2.41, -0.53, -0.16, -0.57, -0.27, -2, 0.14, 0.71, 0.62, -0.81, -1.04, -0.57, -0.97, -1.11, -0.46, 1.23, 0.19, -0.34, -0.43, },
  {2.27, 1.84, 1.97, 2.02, 1.82, 2, 1.69, 2.02, 2.01, 1.93, 2.25, 2.08, 0.04, 2.58, 2.37, 2.32, 2.1, 1.86, 1.44, 1.75, },
  {1.33, 1.11, 0.91, 1.03, 1.09, 1.61, 1, 0.76, 0.78, 0.67, 1.2, 0.88, -0.75, 1.21, 1.15, 1.2, 0.62, 0.78, 0.84, 1.04, },
  {-0.46, 0.04, -0.37, -0.64, 0.23, 0.3, -0.09, -0.37, -0.42, -0.5, -0.51, -0.16, 0.57, -0.53, -0.51, -0.28, -0.31, -0.24, -0.15, 0.28, },
  {-0.2, 0.09, -0.28, -0.14, 0.25, -0.45, 0.15, 0.16, -0.11, -0.02, 0.08, -0.26, 1.53, -0.21, 0.13, 0.34, 0.61, 0.37, 0.53, 0.35, },
  {-0.37, 0.13, -0.45, -0.61, 0.12, -0.12, -0.28, -0.18, -0.43, -0.38, -0.3, -0.59, 0.4, -0.44, -0.35, 0.06, 0.27, 0.03, 0.03, 0, },
  {-1.49, -0.83, -1.55, -1.53, -0.94, -0.78, -0.99, -1.14, -1.27, -1.32, -1.25, -1.37, -0.34, -1.38, -1.36, -1.09, -0.87, -1.02, -0.93, -0.89, },
  {-1.64, -1.22, -1.28, -1.66, -1.45, -1.12, -1.4, -1.64, -1.41, -1.86, -1.54, -1.32, -0.19, -1.63, -1.49, -1.15, -1.08, -1.61, -1.6, -1.39, },
  {-1.05, -1.16, -1.31, -1.75, -1.64, -1.15, -0.79, -0.84, -0.72, -1.64, -1.59, -1.16, -1.48, -1.95, -1.21, -1.17, -0.82, -2.04, -1.6, -1.18, },
},
{  {-1.62, -1.77, -0.44, -2.4, -0.99, -1.05, -1.94, -1.44, -1.51, -0.48, -1.95, -1.26, -1.36, -1.09, -2.12, -2.13, -0.35, -0.26, -1.14, -1.69, },
  {0.52, -1.77, 0.91, 0.64, 0.27, 0.08, -1.25, 0.64, 1.46, 1.69, 0, 0.28, 1.35, 0.21, 0.28, 1.08, 0.46, 1.98, 0.37, 1.09, },
  {1.7, 2.39, 1, 1.46, 1.78, 1.3, 1.63, 2.38, 1.46, 1.87, 2.02, 1.11, 0.07, 1.62, 1.68, 1.52, 1.37, 2.22, 1.76, 2.32, },
  {1.11, 1.37, 0.54, 0.99, 1.65, 1.16, 1.12, 1.76, 0.76, 1.24, 1.39, 0.76, -0.35, 1.02, 1.07, 0.71, 0.95, 1.71, 1.18, 1.69, },
  {-0.31, 0.39, -0.35, -0.12, 0.16, 0.18, 0.1, 0.17, 0.02, -0.14, -0.1, -0.22, 0.42, -0.25, -0.02, -0.05, 0.42, 0.3, 0.29, 0.39, },
  {-0.51, -0.31, -0.41, -0.6, -0.57, -0.88, -0.54, -0.51, -0.4, -0.72, -0.51, -0.57, 0.4, -0.51, -0.47, -0.07, -0.21, -0.44, -0.44, -0.51, },
  {-1.17, -0.77, -0.72, -1.21, -0.84, -0.91, -0.94, -0.78, -0.98, -0.96, -1.01, -0.87, -0.08, -1.05, -1.04, -0.63, -0.67, -0.71, -0.85, -0.84, },
  {-1.2, -0.78, -0.78, -1.13, -0.68, -0.7, -0.65, -0.57, -0.95, -0.78, -0.99, -0.81, -0.5, -0.99, -0.97, -0.8, -0.59, -0.43, -0.9, -0.68, },
  {-0.43, -0.04, 0.02, -0.44, 0.06, 0.04, 0.08, 0.24, -0.25, -0.28, 0.03, 0.02, 0.22, -0.44, -0.03, -0.06, 0.22, 0.34, -0.13, -0.05, },
  {0.58, 0.47, -0.34, -0.1, 0.22, 0.87, 0.26, -0.34, -0.48, -0.16, 0.13, 1.08, -0.66, -0.19, 0.18, 0.24, 0.49, 1.13, -0.33, 0.67, },
},
{  {-1.18, -2.3, -0.85, -2.38, -1.71, -1.65, -2.35, -2.14, -1.5, -0.88, -2.37, -1.08, -0.1, -1.25, -2.3, -2.18, -0.7, -1.7, -1.64, -2.38, },
  {-0.02, -2.3, 0.09, -0.73, -0.46, 0.17, -0.97, 0.63, -0.48, -0.51, -1.11, -0.23, 0.52, -0.65, -0.59, -0.75, -0.11, -0.56, -1.53, -0.71, },
  {0.53, 0.26, 0.44, 0.48, 0.53, -0.56, 0.24, 0.75, 0.38, 0.84, 0.56, 0.19, 0.04, 0.55, 0.64, 0.4, 0.58, 0.65, 0.81, 0.55, },
  {0.64, 0.81, 0.35, 0.67, 0.92, 0.19, 0.54, 1.32, 0.57, 1.06, 1.09, 0.41, 0.02, 0.73, 0.61, 0.58, 0.96, 1.25, 0.81, 0.96, },
  {-0.57, -0.35, -0.35, -0.43, -0.16, 0.36, -0.18, -0.47, -0.32, -0.53, -0.47, -0.24, 0.21, -0.48, -0.34, -0.12, 0.15, -0.4, -0.44, -0.13, },
  {-0.86, -0.57, -0.32, -0.89, -0.75, -0.37, -0.6, -0.61, -0.71, -0.85, -0.92, -0.45, 0.07, -0.89, -0.85, -0.58, -0.64, -0.58, -0.74, -0.76, },
  {-0.86, -0.46, -0.71, -0.76, -0.66, -0.65, -0.5, -0.38, -0.68, -0.67, -0.75, -0.65, -0.28, -0.79, -0.71, -0.73, -0.72, -0.36, -0.58, -0.62, },
  {-0.08, 0.21, 0.13, -0.02, 0.1, 0.02, 0.1, 0.23, 0.26, -0.01, 0.01, 0.11, -0.23, 0.17, 0.26, 0.21, 0.19, 0.34, 0.13, 0.08, },
  {0.88, 1.06, 1.37, 0.47, 0.61, 1.61, 0.79, 0.92, 0.88, 0.59, 0.71, 1.21, 0.27, 0.96, 0.85, 1.21, 1, 1.15, 0.55, 0.68, },
  {0.32, 0.34, 0.23, 1.02, 1.69, 1.77, 0.94, -0.35, -0.25, -0.56, -0.69, 1.26, -0.1, 0.05, 1.11, 1.11, 0.14, 0.38, 0.55, -0.02, },
},
{  {-1.34, -2.68, -0.4, -2.62, -2.25, -0.93, -2.72, -3, -1.88, -1.55, -3, -1.41, 0.17, -1.78, -2.74, -2.45, -1.31, -2.52, -1.94, -2.96, },
  {-0.58, -2.68, 0.26, -0.82, -0.99, 0.2, -1.34, -0.92, 0.4, -0.48, -1.05, 0.13, 1.09, 0.21, -0.34, 0.07, -0.49, 0.4, -0.44, -0.18, },
  {0.22, 0.25, 0.13, 0.11, -0.07, 0.49, 0.06, 0.03, 0.25, 0.25, 0.34, 0.18, 0.4, 0.24, 0.23, 0.45, 0.14, -0.19, 0.32, 0.04, },
  {0.54, 0.74, 0.35, 0.53, 0.47, -0.24, 0.51, 0.72, 0.5, 0.72, 0.64, 0.19, 0.51, 0.52, 0.57, 0.52, 0.81, 0.57, 0.6, 0.58, },
  {-0.55, -0.31, -0.29, -0.5, -0.39, -0.6, -0.32, -0.63, -0.42, -0.59, -0.53, -0.22, -0.09, -0.61, -0.36, -0.06, -0.12, -0.75, -0.46, -0.27, },
  {-1.1, -0.93, -0.57, -0.99, -0.76, 0.14, -0.8, -0.6, -1.01, -0.88, -1.03, -0.57, -0.36, -1.01, -1.01, -0.99, -0.93, -0.46, -0.9, -0.92, },
  {-0.42, -0.11, -0.3, -0.18, -0.01, 0.21, -0.12, 0.34, -0.06, -0.07, -0.39, -0.2, -0.19, -0.18, -0.32, -0.46, -0.31, 0.42, -0.2, -0.16, },
  {1.22, 1.25, 0.83, 0.92, 0.58, 0.36, 0.8, 0.96, 1.18, 0.61, 0.87, 0.94, 0.25, 0.92, 1.01, 0.98, 0.77, 1.08, 0.85, 0.85, },
  {1.49, 1.03, 1.33, 0.91, 0.81, 1.39, 1.2, 1.11, 0.95, 0.49, 1.18, 1.4, 1.06, 1.01, 1.13, 1.43, 1.2, 0.6, 0.94, 0.84, },
  {1.08, -0.04, 1.09, 0.79, 1.15, 2.63, -0.12, -0.51, 0.06, -1.64, -0.22, 0.93, -0.92, 0.21, -0.03, 1.12, 0.23, -0.44, 0.26, 0.32, },
},
{  {-2.3, -3.71, -1.32, -3.45, -3.24, -1.33, -3.7, -4.27, -2.96, -3.59, -4.12, -3.06, -1.43, -2.8, -3.77, -3.42, -2.45, -3.06, -3.05, -4.01, },
  {0.24, -3.71, 0.03, -0.41, -1.99, -0.89, -2.31, -2.19, -1.38, -0.73, -2.86, -0.83, 0.03, -1.91, -1.37, -0.2, -1.35, -0.82, -1.55, -2.34, },
  {0.82, 0.85, 0.48, 0.54, 0.18, 0.21, 0.36, 0.65, 0.57, 0.98, 0.45, 0.16, 1.52, 0.85, 0.81, 0.4, 0.6, 0.64, 0.24, 0.58, },
  {0.68, 0.54, 0.48, 0.54, 0.4, 0.51, 0.47, 0.46, 0.65, 0.76, 0.7, 0.43, 1.19, 0.74, 0.56, 0.34, 0.65, 0.6, 0.77, 0.48, },
  {-0.89, -0.83, -0.39, -0.73, -0.59, -0.88, -0.51, -0.67, -0.67, -0.85, -0.68, -0.39, -0.67, -0.78, -0.74, -0.46, -0.51, -0.69, -0.67, -0.6, },
  {-1.3, -0.75, -0.8, -1.11, -0.58, -0.37, -0.77, -0.46, -1.12, -0.95, -1.1, -0.6, -0.58, -1.26, -1.06, -0.85, -0.85, -0.52, -0.69, -0.78, },
  {-0.33, 0.26, -0.14, 0.04, -0.08, 0.38, 0.09, 0.25, 0.13, 0.09, 0.13, -0.04, 0.09, 0.04, 0.02, -0.03, 0, 0.29, -0.05, 0.24, },
  {1.08, 0.59, 0.5, 0.58, 0.6, -0.14, 0.83, 0.4, 0.84, 0.17, 0.13, 0.23, 0.16, 0.38, 0.61, 0.53, 0.4, 0.11, -0.11, 0.24, },
  {1.59, 0.88, 0.9, 0.5, 0.27, -0.31, 0.06, -0.77, 0.62, 0.03, -0.12, 0.11, -0.7, 0.1, 0.68, 0.63, 0.62, 0.27, 0.28, 0.3, },
  {-0.58, -0.38, -0.53, -0.74, -0.53, 0.15, -1.1, -1.78, -0.32, -1.89, -1.34, -0.73, -0.73, -0.81, -1.47, 1.26, -0.22, -1.67, -1.55, -0.04, },
},
{  {-3.33, -4.52, -2.14, -4.42, -4, -1.24, -4.48, -5.33, -3.91, -3.94, -5.22, -2.86, -2.57, -3.79, -4.73, -4.26, -3.28, -4.08, -3.8, -4.45, },
  {-1.89, -4.52, -1.49, -1.38, -2.75, 0.59, -3.1, -2.56, -2.04, -2.47, -3.28, -0.63, -0.56, -1.79, -2.33, -1.74, -1.78, -1.85, -2.29, -1.67, },
  {1.48, 1.03, 0.95, 1.17, 0.52, 1.06, 0.6, 0.35, 0.66, 1.06, 0.57, 0.71, 1.28, 0.53, 1.24, 0.8, 1.37, 1.17, 0.13, 0.39, },
  {0.73, 0.19, 0.31, 0.48, 0.53, -0.1, 0.12, 0.61, 0.72, 0.87, 0.53, -0.03, 0.57, 0.47, 0.52, 0.36, 0.62, 0.27, 0.75, 0.71, },
  {-0.87, -0.09, -0.38, -0.64, -0.34, -0.56, -0.16, -0.68, -0.75, -0.61, -0.36, -0.04, -0.53, -0.74, -0.71, -0.41, -0.03, -0.03, -0.73, 0.09, },
  {-0.83, -0.11, -0.3, -0.83, -0.54, -0.25, -0.28, -0.09, -0.66, -0.62, -0.81, -0.06, -0.15, -0.66, -0.65, -0.3, -0.7, -0.54, -0.55, -0.45, },
  {-0.64, 0.4, -0.23, -0.5, 0, 0.65, 0, -0.2, -0.32, -0.59, -0.34, 0.17, -0.45, -0.3, -0.36, -0.02, -0.25, -0.06, 0.15, -0.27, },
  {-0.32, -0.3, -0.41, 0.06, 0.2, 0.8, 0.05, -0.4, 0.16, -0.44, -0.2, -0.19, -1.05, -0.05, 0.31, -0.05, 0.27, -0.09, -0.11, 0.07, },
  {-0.91, -1.15, -1.16, -1.12, -0.91, -0.19, -0.93, -0.53, -1.27, -1.47, -1.23, -1.07, -2.38, -0.77, -1.22, -0.81, -0.94, 0.05, -0.82, -1.09, },
  {-1.83, -1.88, -0.66, -2.12, -1.29, -0.81, -1.19, -2.85, -2.37, -2.93, -3.14, -1.62, -3.27, -2.89, -2.93, -1.2, -1.06, -2.7, -1.6, -1.58, },
},
{  {-2.82, -4.03, -1.43, -4.26, -3.68, -1.54, -3.89, -5.25, -3.54, -3.73, -4.35, -2.01, -2.94, -3.22, -4.2, -3.69, -3.02, -4.06, -3.57, -4.2, },
  {-0.28, -4.03, -0.77, -2.14, -2.43, -0.81, -2.51, -2.47, -0.57, -1.57, -2.4, -0.88, -1.33, -1.23, -2.49, -0.47, -0.82, -1.83, -2.07, -1.42, },
  {0.82, 0.22, 0.13, 0.5, 0.28, 0.32, -0.22, 0.53, 0.31, 0.19, -0.08, -0.46, 0.28, 0.4, 0.69, 0.9, 0.75, 0.3, 0.58, 0.14, },
  {0.75, 0.36, -0.02, 0.3, 0.63, 0.29, 0.17, 0.69, 0.3, 0.32, 0.75, -0.1, 0.33, 0.3, 0.32, 0.56, 0.1, 0.45, 0.64, 0.29, },
  {0.05, -0.07, 0.6, 0.01, 0.08, 0.46, 0.57, -0.37, 0.12, -0.09, 0, 0.75, -0.35, 0.27, 0.26, 0.42, -0.12, 0.17, 0.31, 0.39, },
  {0.18, 0.81, 0.41, -0.01, 0.5, -0.44, 0.35, -0.18, 0.25, -0.29, -0.24, 0.59, -0.07, 0.01, 0.1, 0.61, 0.4, -0.09, 0.01, -0.16, },
  {0.31, 0.34, 0.34, 0.1, 0.36, -0.24, 0.47, 0.17, 0.31, 0.07, 0.17, 0.47, -0.23, 0.27, 0.61, 0.51, 0.35, 0.26, -0.32, 0.3, },
  {-0.82, -0.27, -0.6, -0.74, -0.37, 0.11, -0.46, -0.89, -0.7, -0.32, -0.25, 0.13, -0.67, -0.6, -0.7, -0.38, -0.25, -0.7, -0.32, -0.03, },
  {-2.09, -1.47, -1.75, -2.1, -1.63, -0.54, -1.24, -1.83, -2.07, -2.26, -1.9, -1.06, -2.35, -2.07, -2.05, -1.66, -1.3, -1.58, -1.65, -1.26, },
  {-2.42, -0.7, -2.02, -1.96, -1.89, -1.07, -2.39, -2.76, -2.7, -2.72, -2.68, -1.06, -2.94, -2.32, -2.18, -1.79, -2.4, -3.78, -2.07, -1.84, },
},
};


float ethph2[12][10][20]  = {
{  {-2.86, -3.72, -2.47, -3.89, -2.91, -1.47, -3.49, -4.25, -3.3, -3.02, -4.26, -2.28, -2.34, -3, -3.96, -3.85, -2.36, -2.98, -3.09, -3.51, },
  {-1.7, -3.72, -0.42, -1.25, -2.35, -0.75, -2.8, -1.47, -1.72, -1.55, -2.32, -0.04, -1.02, -2.39, -1.56, -1.32, -1.55, -1.44, -1.59, -0.73, },
  {-0.4, 0.03, -0.46, -0.33, 0.29, 0.9, 0.24, -0.28, -0.5, -0.28, -0.23, 0.31, -0.37, -0.38, -0.19, -0.47, -0.29, -0.22, -0.16, 0.28, },
  {-0.92, 0.08, -0.82, -0.81, 0.08, 0.96, -0.14, -0.76, -1.08, -0.92, -0.65, 0.16, -0.81, -0.88, -0.71, -0.83, -0.8, -0.71, 0, 0.14, },
  {-2.04, -0.8, -1.16, -2.11, -1, -0.22, -1.06, -1.73, -2.29, -2.03, -1.81, -0.73, -1.44, -2.03, -1.95, -1.8, -1.61, -1.74, -1.32, -1.01, },
  {-1.53, 0.14, -0.71, -1.42, 0.17, -0.87, -0.24, -0.12, -1.42, -0.59, -0.92, -0.21, -1.12, -1.12, -1, -0.77, -0.52, -0.17, -0.49, -0.31, },
  {-0.49, 0.65, 0.01, -0.42, 0.51, -0.12, 0.09, 0.47, -0.39, 0.25, -0.36, 0, -0.47, -0.29, -0.15, -0.07, 0.21, 0.91, -0.21, 0.44, },
  {-0.52, 0.68, -0.15, -0.62, 0.45, 0.25, 0.09, 0.34, -0.53, -0.09, -0.4, 0.29, -1.12, -0.49, -0.57, -0.07, 0.16, 0.43, 0.15, 0.56, },
  {0.01, 0.53, 0.28, -0.42, 0.99, 1.09, 0.35, -0.65, -0.3, -0.63, -0.27, 0.79, -1.05, -0.67, -0.36, -0.07, 0.39, 0.06, -0.11, 0.52, },
  {0.26, -0.39, -0.98, -1.18, -0.2, 1.95, -0.19, -2.86, -2.05, -2.01, -2.18, 0.06, -3.03, -1, -1.94, 0.13, -0.83, -1.59, -0.9, -0.23, },
},
{  {0.23, -1.75, 0.35, -1.12, -0.85, -1.14, -1.62, -1.42, -0.65, 0.15, -1.29, -0.52, -1.26, -0.86, -1.31, -1.79, -0.43, -1.19, -0.74, -1.58, },
  {0.07, -1.75, -0.5, -0.02, -0.7, -0.23, -0.24, -0.85, 0.24, 0.37, -0.44, -0.24, -0.26, 0.04, -0.01, -0.18, -0.02, -0.56, -0.62, -0.6, },
  {-0.86, -1.35, -1.05, -0.8, -1.16, -1.15, -1.13, -1.18, -0.99, -0.91, -0.95, -0.95, -1.28, -0.94, -0.99, -1.27, -1.39, -1.35, -1.01, -1.23, },
  {-0.87, -1.29, -0.92, -0.82, -1.16, -0.83, -1.08, -1.19, -0.96, -0.89, -0.96, -0.76, -1.33, -0.9, -0.96, -1.27, -1.34, -1.35, -1.06, -1.19, },
  {0.68, 0.5, 0.95, 0.63, 0.37, 0.44, 0.44, 0.77, 0.45, 0.8, 0.63, 0.88, 0.36, 0.59, 0.48, 0.08, 0.16, 0.49, 0.51, 0.22, },
  {2.81, 2.25, 2.27, 2.54, 2.14, 1.73, 1.81, 2.63, 2.52, 3.04, 2.54, 2.03, 1.93, 2.51, 2.42, 1.91, 1.99, 2.46, 2.51, 2.19, },
  {3.01, 3.17, 2.28, 2.85, 2.79, 1.75, 2.48, 3.5, 3.12, 3.84, 4.18, 2.65, 1.88, 2.9, 3, 2.42, 2.82, 3.43, 3.21, 2.78, },
  {2.75, 2.39, 2.38, 2.54, 2.82, 1.89, 3, 2.97, 2.52, 3.03, 3.12, 2.42, 0.53, 2.56, 2.7, 1.94, 2.03, 3.22, 2.51, 2.53, },
  {2.49, 2.25, 1.97, 1.87, 2.47, 2.38, 1.99, 1.77, 2.14, 1.73, 2.7, 2.29, -0.78, 1.72, 1.93, 1.95, 1.72, 2.32, 2.75, 2.07, },
  {1.73, 0.89, 1.14, 1.18, 1.16, 1.97, 1.67, 1.06, 0.89, 0.06, 0.38, 1.81, -0.57, 0.73, 0.71, 1.27, 0.7, 0.89, 1.46, 1, },
},
{  {-1.83, -2.51, -1.37, -2.4, -1.67, -0.72, -2.25, -2.8, -1.77, -2.13, -2.47, -0.99, -1.39, -1.31, -2.46, -2.39, -1.81, -1.76, -2.35, -2.36, },
  {-1.3, -2.51, -1.22, -1.23, -1.11, -0.69, -1.55, -1.13, -1.2, -1.43, -1.22, -0.55, -1.62, -1.4, -1.45, -1.56, -0.87, -2.01, -1.54, -0.68, },
  {-0.62, -0.72, -0.48, -0.6, -0.69, -0.58, -0.59, -0.9, -0.6, -0.63, -0.7, -0.21, -1.66, -0.45, -0.59, -0.93, -0.9, -0.93, -0.83, -0.59, },
  {-0.07, -0.26, 0.05, 0.04, 0.04, 0.03, 0, -0.1, -0.01, -0.1, -0.09, 0.24, -1.26, 0.02, -0.02, -0.34, -0.23, -0.16, -0.31, -0.03, },
  {0.19, 0.2, 0.9, 0.43, 0.41, 0.36, 0.19, 0.18, 0.28, 0.3, 0.03, 0.63, 0.68, 0.31, 0.12, -0.11, -0.26, 0.1, 0.18, 0.26, },
  {2.21, 1.44, 2.08, 1.86, 1.57, 1.3, 1.56, 2.12, 1.93, 2.56, 2.19, 1.79, 2.33, 1.88, 1.82, 1.9, 1.64, 1.75, 1.69, 1.4, },
  {2.51, 2.56, 3.09, 2.34, 3.76, 1.87, 2.38, 2.99, 2.61, 3.13, 2.82, 2.64, 2.46, 2.82, 2.54, 2.5, 2.83, 2.95, 2.4, 3.71, },
  {2.41, 2.25, 2.5, 2.51, 2.59, 1.98, 2.47, 2.76, 2.25, 3.25, 2.73, 2.56, 0.41, 2.61, 2.51, 2.47, 2.23, 2.51, 2.84, 2.94, },
  {1.96, 1.61, 1.79, 1.55, 2.6, 2.2, 2.47, 1.49, 1.7, 2.05, 1.53, 2.18, -1.35, 1.48, 2.24, 2.19, 2.02, 1.46, 3.63, 2.58, },
  {0.87, 0.82, -0.39, 1, 1.73, 2.14, 0.36, -0.32, 0.87, -0.02, 0.3, 1.34, -2.08, -0.02, 0.25, 1.19, 0.41, -0.37, -0.15, 1.61, },
},
{  {-1.29, -2.46, -0.32, -2.6, -1.75, -0.71, -2.33, -2.75, -1.83, -1.18, -2.58, -1.74, -2.37, -1.41, -2.59, -2.42, -1.11, -2.36, -1.82, -2.42, },
  {-0.35, -2.46, 0.34, -0.47, -1.19, -0.68, -0.94, -1.07, -0.81, -0.11, -0.63, -0.42, 0.34, -0.52, -1.29, 0.11, -0.3, -0.53, -0.31, -1.03, },
  {1.45, 1.3, 0.99, 1.5, 1.43, -0.08, 1.15, 1.79, 1.14, 1.64, 1.18, 0.72, 0.63, 1.13, 1.23, 0.97, 1.1, 1.84, 1.42, 1.56, },
  {0.61, 0.26, 0.1, 0.5, 0.34, -0.74, 0.19, 0.98, 0.36, 0.43, 0.41, -0.08, -0.04, 0.29, 0.35, 0.08, 0.08, 0.78, 0.34, 0.33, },
  {0.18, 0.1, 0.7, 0.27, 0.08, -0.45, 0.13, 0.32, 0.17, 0.24, 0.1, 0.22, 0.55, 0.17, 0.16, -0.03, -0.35, 0.51, 0.07, 0.05, },
  {1.84, 1.45, 2.21, 1.79, 1.62, 0.99, 1.38, 2.15, 2.12, 2.32, 2.08, 1.71, 2.53, 1.78, 1.74, 2.06, 1.76, 2.13, 1.53, 1.42, },
  {2.13, 2.61, 2.82, 2.48, 2.99, 1.85, 3.07, 2.76, 2.37, 3.03, 2.3, 2.78, 2.28, 2.55, 2.42, 2.71, 3.26, 2.76, 2.94, 3.04, },
  {2.37, 2.64, 2.64, 2.02, 2.83, 2.1, 2.74, 2.93, 2.62, 2.47, 2.62, 3.89, 1.07, 2.17, 2.76, 2.78, 2.55, 2.33, 2.13, 2.65, },
  {2.32, 3.05, 1.91, 2.12, 3.11, 2.46, 3.99, 3.15, 2.85, 2.31, 2.51, 2.72, -1.08, 2.99, 3.37, 2.46, 2.25, 2.47, 2.08, 3.21, },
  {1.83, 0.88, 0.48, 0.8, 0.96, 2.02, 0.97, -0.26, 0.12, -0.86, 0.19, 0.6, -1.68, -0.11, 0.12, 1.16, 1.12, -0.28, 0.38, 1.55, },
},
{  {-1.17, -2.3, -0.31, -2.6, -1.72, -1.48, -2.34, -2.59, -1.82, -1.16, -2.51, -1.83, -1.73, -1.42, -2.53, -2.33, -1.03, -1.51, -1.75, -2.41, },
  {0.28, -2.3, 0.34, 1.14, -0.47, -0.75, -0.95, 0.18, 1.15, -0.37, -1.25, -0.29, 0.98, -0.12, -0.13, 0.19, -0.22, 0.03, -0.25, -0.33, },
  {2.53, 1.35, 1.36, 1.99, 1.67, -0.55, 1.16, 2.94, 1.42, 2.05, 1.76, 0.56, 1.39, 1.51, 1.84, 1.83, 1.88, 2.6, 1.71, 1.81, },
  {1.36, 0.81, 0.48, 1.19, 0.78, -1.01, 0.55, 1.86, 0.92, 1.27, 1, -0.05, 0.55, 0.91, 0.91, 0.96, 0.86, 1.62, 1.05, 0.83, },
  {0.23, 0.37, 0.67, 0.43, 0.28, -1.09, 0.47, 0.65, 0.34, 0.52, 0.18, 0.22, 0.18, 0.47, 0.33, 0.45, 0.4, 0.6, 0.41, 0.34, },
  {1.29, 1.18, 1.71, 1.2, 1.2, 0.59, 1.21, 1.22, 1.48, 1.22, 1.55, 1.06, 1.47, 1.34, 1.38, 1.38, 1.63, 1.02, 1.32, 1.3, },
  {1.73, 1.34, 1.9, 1.39, 1.36, 1.77, 1.3, 1.1, 1.71, 1.46, 1.53, 1.64, 2.07, 1.59, 1.43, 1.72, 1.8, 1.29, 1.21, 1.25, },
  {1.72, 2.32, 2.54, 1.58, 1.92, 2.06, 1.59, 1.48, 1.7, 2.04, 1.6, 2.5, 2.63, 1.81, 1.88, 1.92, 2.17, 1.79, 2.06, 2.08, },
  {2.03, 2.51, 3.21, 2.13, 2.66, 2.76, 2.88, 1.92, 1.76, 1.77, 2.59, 2.85, 0.25, 1.6, 2.5, 2.6, 2.32, 2.92, 2.15, 2.31, },
  {1.95, 1.03, 1.17, 0.8, 1.68, 1.95, 0.96, -0.1, 0.82, -0.14, 0.27, 1.2, -1.73, 0.57, 0.87, 2.34, 1.19, -0.12, 0.45, 0.87, },
},
{  {-0.89, -2.04, -0.96, -2.44, -1.47, -0.8, -2.19, -2.24, -2.34, -0.95, -2.26, -1.14, -1.48, -1.24, -2.31, -2.11, -0.77, -1.09, -1.47, -2.17, },
  {0.27, -2.04, 1.08, 0.2, -0.91, -0.36, -1.5, 0.54, 1.32, 0.12, -1.01, -0.3, -0.15, 0.75, 0.09, 1.11, 1.43, 1.15, 0.04, -0.5, },
  {2.6, 2.21, 1.43, 2.5, 1.83, 0.53, 1.24, 3.86, 2.02, 2.29, 2.1, 0.79, 1.5, 2.06, 2.36, 2.48, 3.35, 2.93, 2.28, 2.01, },
  {2.26, 1.72, 0.87, 2.06, 1.68, 0.08, 1.22, 2.59, 1.72, 1.94, 1.75, 0.58, 0.66, 1.79, 1.65, 2.04, 2.64, 2.37, 2, 1.87, },
  {-0.08, -0.17, -0.31, -0.12, -0.29, -0.33, -0.01, -0.36, 0.09, -0.35, -0.05, -0.41, -0.75, -0.23, -0.01, 0.23, 0.62, -0.33, -0.12, -0.15, },
  {-0.12, -0.17, -0.22, -0.27, -0.42, 0.22, -0.07, -0.36, -0.13, -0.42, -0.25, -0.3, -0.42, -0.23, -0.19, 0.22, 0.22, -0.34, -0.45, -0.37, },
  {-0.04, -0.03, 0.38, -0.23, -0.26, 0.6, 0.09, -0.25, 0.04, -0.25, -0.13, 0.04, 0.06, 0.24, -0.07, 0.4, 0.25, -0.21, -0.29, -0.24, },
  {-0.03, 0.26, 0.95, -0.16, 0.1, 0.96, 0.24, 0.07, 0.25, 0.09, 0.14, 0.57, 0.4, 0.13, 0.32, 0.39, 0.6, 0.33, -0.05, 0.12, },
  {0.77, 1.06, 1.41, 0.41, 0.95, 1.5, 0.57, 0.66, 0.67, 0.49, 0.69, 1.52, -0.19, 0.81, 1.08, 0.94, 1.03, 0.57, 0.38, 0.77, },
  {1.12, 0.6, 0.53, 0.27, 0.14, 1.71, 0, 0.25, -0.11, 0.06, 0.51, 0.5, -1.48, 0.75, 0.4, 1.18, 0.07, 0.3, -0.37, 0.7, },
},
{  {-0.61, -1.72, -0.16, -2.15, -1.08, -0.67, -1.93, -1.56, -1.35, -0.49, -1.86, -1.06, -0.84, -0.93, -1.98, -1.89, -0.38, -0.41, -1.1, -1.77, },
  {0.83, -1.72, 0.09, 1.58, 0.18, -0.23, -0.54, 0.52, 0.93, 0.58, 0.08, 1.18, 0.08, 1.06, -0.68, 0.64, 0.03, 1.13, 0.4, 1, },
  {3.02, 2.62, 2.21, 3.16, 2.84, 2.15, 2.26, 3.39, 2.82, 3.07, 3.34, 1.47, 1.66, 2.69, 2.97, 2.95, 2.96, 3.85, 2.49, 3.06, },
  {2.69, 1.87, 1.2, 2.65, 2.5, 2.1, 1.83, 2.49, 2.29, 2.44, 2.6, 1.05, 1.4, 2.29, 2.55, 2.54, 2.74, 2.79, 2.82, 2.49, },
  {-0.3, -0.25, -0.91, -0.24, -0.19, 0.89, -0.13, -0.19, -0.14, -0.4, -0.22, -0.74, -0.35, -0.3, -0.26, 0, 0.4, -0.05, -0.29, -0.04, },
  {-0.76, -0.71, -0.99, -0.85, -0.83, -0.49, -0.76, -0.7, -0.7, -0.99, -0.8, -1.11, -0.49, -0.75, -0.81, -0.55, -0.61, -0.64, -0.89, -0.85, },
  {-0.87, -0.66, -0.69, -0.89, -0.79, -0.24, -0.81, -0.79, -0.67, -0.9, -0.8, -0.91, -0.34, -0.83, -0.77, -0.53, -0.65, -0.71, -0.9, -0.81, },
  {-0.87, -0.46, -0.34, -0.83, -0.54, 0.01, -0.46, -0.49, -0.52, -0.83, -0.72, -0.41, -0.24, -0.68, -0.55, -0.59, -0.4, -0.32, -0.68, -0.6, },
  {-0.54, -0.04, -0.17, -0.61, -0.34, 0.11, -0.19, -0.13, -0.37, -0.5, -0.59, 0.07, 0.04, -0.54, -0.4, -0.35, -0.24, 0.03, -0.72, -0.4, },
  {-0.21, 0, -0.46, -0.7, -0.07, 0.12, -0.24, 0.23, 1.29, -0.58, -0.19, 0.18, -0.84, -0.73, 1.42, -0.16, 0.75, 0.29, 0.4, 0, },
},
{  {-0.88, -2.05, -0.37, -2.33, -1.46, -1.35, -2.18, -2.05, -1.45, -0.83, -2.15, -1.3, -0.33, -1.11, -2.17, -2.04, -1.64, -0.86, -1.52, -2.16, },
  {0.97, -2.05, -0.12, 0.31, -0.21, 1.16, -0.79, 0.03, 1.52, 0.24, -0.89, 0.93, -0.1, 0.88, 0.23, 0.49, 0.04, 1.37, -0.02, -0.09, },
  {2, 1.41, 1.66, 2.24, 2.05, 2.18, 1.92, 3.13, 2.42, 1.76, 1.73, 1.64, 1.86, 2.31, 2.2, 1.66, 1.65, 3.24, 2.07, 2.27, },
  {1.97, 1.2, 1.57, 2.19, 1.58, 2.54, 1.47, 2.46, 1.98, 1.43, 1.84, 1.31, 2.04, 2.19, 2.2, 1.42, 1.2, 2.64, 1.84, 1.76, },
  {-0.22, -0.2, -0.44, -0.22, 0.04, 1.13, -0.24, -0.19, 0.17, -0.18, -0.14, -0.22, -0.31, -0.09, 0.09, 0.15, -0.2, -0.02, -0.11, 0.01, },
  {-0.76, -0.51, -0.86, -0.85, -0.52, -0.09, -0.78, -0.62, -0.72, -0.63, -0.7, -0.78, -0.39, -0.83, -0.7, -0.66, -0.51, -0.46, -0.57, -0.45, },
  {-0.81, -0.66, -0.7, -0.85, -0.75, -0.01, -0.84, -0.56, -0.85, -0.79, -0.75, -0.76, -0.23, -0.86, -0.79, -0.53, -0.34, -0.5, -0.71, -0.73, },
  {-0.84, -0.74, -0.8, -0.74, -0.97, -0.18, -0.92, -0.75, -0.8, -0.86, -0.73, -0.89, -0.1, -0.77, -0.81, -0.69, -0.43, -0.78, -0.9, -0.92, },
  {-1.18, -0.7, -0.52, -0.82, -1.1, -0.31, -0.99, -0.94, -0.92, -1.03, -0.7, -0.87, 0.56, -0.82, -0.74, -0.69, -0.71, -0.89, -0.9, -1.13, },
  {-1.2, -1.12, -0.67, -1.13, -1.35, -0.71, -1.28, -0.66, -1.21, -0.51, -0.76, -1.27, -0.33, -0.51, -0.96, -0.89, -0.52, -1.42, -1.72, -1.33, },
},
{  {-1.36, -2.63, -1.4, -2.74, -2.18, -0.73, -2.75, -2.85, -1.89, -2.14, -2.71, -1.66, -0.86, -2.28, -2.63, -2.44, -1.01, -1.65, -2.23, -2.86, },
  {-0.2, -2.63, -0.05, -0.39, -0.93, 0.4, -1.37, -0.77, -0.87, 0.03, -0.76, -0.81, 1.16, -0.28, -0.23, 0.08, 0.08, -0.51, -1.83, -0.09, },
  {0.97, 1.45, 0.54, 1.26, 1.69, 1.82, 1.13, 2.1, 1.4, 0.92, 1.44, 0.78, 2.85, 1.23, 1.49, 1.22, 1.8, 2.08, 1.52, 1.43, },
  {1.3, 0.94, 0.62, 1.42, 0.92, 2.28, 0.62, 1.31, 1.43, 1.02, 1.21, 0.37, 2.79, 1.11, 1.26, 1.25, 1.32, 1.71, 1.36, 0.75, },
  {0.15, 0.29, 0.62, 0.17, 0.03, 1.55, -0.08, -0.06, 0.29, 0.1, 0.07, 0.59, 0.4, 0.39, 0.37, 0.73, 0.29, 0.1, 0.36, -0.01, },
  {-1.02, -0.48, -0.59, -0.91, -0.38, -0.05, -0.62, -0.33, -0.84, -0.68, -0.83, -0.4, -0.23, -0.85, -0.78, -0.88, -0.79, -0.16, -0.35, -0.24, },
  {-1.08, -0.76, -1.1, -1.07, -0.77, -0.61, -0.82, -0.49, -1.03, -0.99, -1.01, -1.09, -0.4, -1.08, -0.95, -1.2, -1.08, -0.41, -0.5, -0.64, },
  {-0.98, -1.04, -1.13, -1.19, -1.16, -0.4, -1.16, -1.08, -1.14, -1.1, -1.17, -1.37, -0.24, -1.2, -1.17, -0.91, -1.15, -1.04, -1.08, -1.12, },
  {-1.16, -1.38, -1.13, -1.21, -1.46, -0.75, -1.31, -1.31, -1.09, -1.19, -1.25, -1.48, 1.12, -1.13, -1.21, -1.12, -0.95, -1.29, -1.23, -1.28, },
  {-1.38, -1.5, -0.82, -1.13, -1.08, -1.04, -1.25, -2.16, -0.86, -2.05, -1.73, -1.27, -0.17, -1.38, -1.53, -1.17, -1.19, -1.65, -0.73, -1.46, },
},
{  {-3.47, -3.67, -1.43, -3.63, -3.96, -1.66, -3.64, -3.85, -2.82, -2.5, -3.84, -2.41, -1.13, -2.53, -3.59, -3.6, -2.33, -2.59, -3.12, -3.85, },
  {-0.52, -3.67, -0.08, -0.58, -2.01, 0.17, -2.25, -1.08, -1.45, -1.02, -1.9, -1.27, 0.88, -1.23, -1.88, -0.38, -0.13, -0.35, -1.61, -1.08, },
  {1.72, 0.68, 0.97, 1.89, 0.79, 1.09, 0.93, 2.38, 1.8, 1.35, 0.85, 0.2, 3.27, 1.91, 1.87, 1.3, 1.71, 2.21, 0.92, 0.68, },
  {1.88, 1.68, 1.39, 2.06, 1.06, 2.01, 1.09, 1.7, 1.94, 1.77, 1.25, 0.88, 3.22, 1.66, 1.61, 1.42, 1.65, 1.64, 1.43, 1.27, },
  {0.45, 0.87, 1.05, 0.8, 0.65, 1.56, 0.08, 1, 1.14, 0.63, 0.32, 0.65, 1.91, 0.85, 0.83, 0.68, 1.14, 0.74, 0.65, 0.45, },
  {-0.65, -0.06, 0.12, -0.18, 0.01, 0.36, 0.2, 0.96, -0.21, -0.25, -0.16, -0.06, 0.17, -0.3, 0.1, -0.13, 0.14, 0.8, 0.47, 0.15, },
  {-1, -0.54, -1.56, -0.91, -0.31, -0.86, -0.51, 0.34, -0.76, -0.7, -0.61, -1.42, -0.67, -0.93, -0.72, -0.79, -0.56, 0.19, -0.53, -0.39, },
  {-0.97, -1.11, -1.95, -1.21, -0.93, -1.06, -1.33, -0.96, -1.2, -1.1, -1.15, -1.83, -0.41, -1.22, -1.22, -0.94, -1.29, -1.02, -0.63, -0.92, },
  {-1.38, -1.79, -2.15, -1.6, -1.27, -1.12, -1.61, -1.13, -1.42, -1.43, -1.84, -2.24, 0.16, -1.51, -1.83, -1.44, -1.54, -1.16, -1.01, -1.15, },
  {-1.66, -1.72, -1.89, -1.32, -0.96, -1.03, -1.44, -2.06, -1.79, -1.49, -1.76, -2.27, -1.83, -2.15, -1.28, -1.41, -2.05, -1.2, -1.61, -0.98, },
},
{  {-3.12, -4.65, -2.91, -4.18, -3.92, -1.39, -4.31, -4.26, -3.41, -3.13, -4.7, -3.25, -2.27, -3.19, -4.31, -4.41, -3.22, -3.13, -3.65, -4.49, },
  {-0.58, -4.65, -1.56, -1.14, -2.67, 0.43, -2.93, -1.48, -1.13, -1.66, -2.76, -1.02, 0.44, -1.2, -1.91, -1.88, -1.72, -0.9, -2.15, -1.71, },
  {1.12, 0.39, -0.1, 1.07, 0.09, 0.87, 0.02, 1.61, 0.68, 1.29, 0.62, -1.26, 1.65, 0.76, 0.7, 0.73, 1.18, 1.98, 0.97, 0.28, },
  {0.78, 0.44, 0.01, 0.95, 0.69, 1.56, 0.37, 0.94, 0.75, 0.83, 0.9, -0.62, 2.18, 0.6, 0.64, 0.66, 0.78, 0.82, 1.04, 0.72, },
  {-0.22, -0.22, 0.06, 0.09, -0.12, 0.6, -0.16, -0.12, -0.02, -0.27, 0.34, 0.02, 1.88, -0.44, -0.27, -0.22, 0.06, -0.08, -0.18, -0.03, },
  {0.3, -0.17, 0.33, 0.63, -0.04, -0.1, 0.28, 0.52, 0.84, 0.4, -0.13, -0.21, 2.1, 0.24, 0.28, -0.09, 0.39, 0.34, 0.69, 0, },
  {0.12, -0.19, -0.26, -0.02, 0.17, -0.94, -0.16, 1.11, 0.33, 0.48, -0.11, 0.08, 0.72, 0.01, 0.24, 0.32, 0.19, 1.33, 0.88, 0.16, },
  {-0.67, -0.25, -0.43, 0, 0.39, -1.31, -0.39, 0.56, 0.08, 0.24, 0.03, -1.07, -0.11, -0.05, -0.28, -0.37, -0.12, 0.42, 0.04, 0.11, },
  {-0.59, -0.94, -1.49, -1, -0.02, -1.31, -0.76, -0.3, -0.72, -0.2, -0.71, -1.06, -0.98, -1.08, -0.56, -0.65, -0.75, 0.6, -0.16, 1.15, },
  {-1.11, -1.32, -1.83, -1.88, -1.62, -0.89, -1.71, -1.77, -1.47, -2.12, -1.93, -2.3, -2.27, -1.2, -1.6, -1.12, -2.1, -2.44, -2.15, -0.52, },
},
{  {-3.57, -5.21, -2.68, -4.52, -4.38, -2.07, -4.81, -4.63, -3.76, -3.53, -5.12, -3.96, -2.48, -3.64, -4.73, -4.89, -3.65, -3.51, -4.01, -4.83, },
  {-2.41, -5.21, -2.03, -1.47, -3.13, -0.94, -3.42, -1.86, -0.79, -2.05, -3.17, -2.42, -1.38, -2.34, -2.34, -3.06, -2.84, -1.28, -2.51, -2.75, },
  {0.55, -0.35, -0.27, 0.53, 0.23, 1.6, -0.09, 0.6, 0.56, 0.6, 0.34, 0.06, 0.71, 0.45, 0.62, -0.08, -0.51, 0.08, 0.28, 0.25, },
  {-0.08, -0.26, -0.35, 0.41, 0.08, 1.35, 0.03, -0.07, 0.02, -0.22, -0.27, -0.23, 0.24, 0.03, 0.2, -0.55, -0.52, -0.15, 0.06, 0.22, },
  {-1.82, -1.42, -1.01, -1.53, -1.38, -1.44, -1.2, -1.07, -1.4, -1.52, -1.9, -1.39, -0.41, -1.54, -1.57, -1.56, -1.43, -1.19, -1.27, -1.3, },
  {-1, -0.87, -0.89, -1.08, -1.17, -2.05, -1.35, -0.78, -0.96, -0.68, -0.63, -1.17, 0.02, -1.1, -1.03, -0.8, -0.82, -0.78, -0.81, -1.27, },
  {-0.56, -0.83, -0.73, -0.99, -1.13, -1.5, -1.22, -0.57, -0.89, -0.48, -0.34, -0.86, 1.18, -0.91, -0.9, -0.72, -0.42, -0.55, -0.76, -1.24, },
  {-0.44, -0.9, -0.69, -0.62, -0.37, -1.41, -0.5, -0.16, -0.53, -0.52, -0.25, -0.81, -0.07, -0.81, -0.7, -0.33, -0.33, 0.41, -0.83, -0.38, },
  {0.44, -0.4, -0.26, -0.3, -0.4, -1.09, -0.56, -0.12, -0.06, 0.25, -0.72, -0.19, -1.6, 0.08, -0.29, 0.11, -0.52, -0.38, -0.52, -0.01, },
  {-1.85, -1.88, -1.2, -2.21, -0.98, -0.2, -2.2, -2.14, -1.12, -2.52, -3.04, -1.62, -2.48, -1.64, -1.33, -0.22, -2.12, -2.12, -1.81, -1.55, },
},
};


float phi1rg[12][2] = {
  { 0, 30, },
  { 30, 60, },
  { 60, 90, },
  { 90, 120, },
  { 120, 150, },
  { 150, 180, },
  { 180, 210, },
  { 210, 240, },
  { 240, 270, },
  { 270, 300, },
  { 300, 330, },
  { 330, 360, },
};


float phi2rg[12][2] = {
  { 0, 30, },
  { 30, 60, },
  { 60, 90, },
  { 90, 120, },
  { 120, 150, },
  { 150, 180, },
  { 180, 210, },
  { 210, 240, },
  { 240, 270, },
  { 270, 300, },
  { 300, 330, },
  { 330, 360, },
};


float thetrg[10][2] = {
  { 60, 70, },
  { 70, 80, },
  { 80, 90, },
  { 90, 100, },
  { 100, 110, },
  { 110, 120, },
  { 120, 130, },
  { 130, 140, },
  { 140, 150, },
  { 150, 160, },
};



			</file>
			<file name="locptx.c" type="text">
#include &lt;stdio.h&gt;
#include &lt;assert.h&gt;

#include &quot;locptx.h&quot;

#define radtodeg(theta) (theta/3.141592653589793 * 180.0)
#include &quot;torsion.h&quot;
#include &quot;vector.h&quot;

float locptx(int nres, float *ca, int *apindx, float ephi1[12][20],
	    float ephi2[12][20], float etheta[10][20], 
            float ephi12[12][12][20],float ethph1[12][10][20], 
            float ethph2[12][10][20], float phi1rg[12][2],
            float phi2rg[12][2], float thetrg[10][2])
{
  int ires;
  int irnge;
  static float phi[1024];
  static float theta[1024];
  float tenr = 0;
  float p1enr = 0;
  float p2enr = 0;
  float tp1enr = 0;
  float tp2enr = 0;
  float p12enr = 0;
  float totpot; 

  int itheta = 0;
  int iphi1 = 0;
  int  iphi2 = 0;
  int litheta, liphi1, liphi2 = 0;

  assert(nres &lt; 1024);
  
  for(ires = 1; ires &lt; nres-2; ires++)
  {
    assert(apindx[ires] &gt;= 0 &amp;&amp; apindx[ires] &lt; 20);

    phi[ires] = calctorsion( &amp;ca[ires*3-3], &amp;ca[ires*3 ], &amp;ca[ires *3 + 3], &amp;ca[ires*3+6]);
    theta[ires] = vang(&amp;ca[ires*3-3], &amp;ca[ires*3], &amp;ca[ires*3+3]);     
  }
  theta[ires] = vang(&amp;ca[ires*3-3], &amp;ca[ires*3], &amp;ca[ires*3+3]);
  /* dummy torsion) */
  phi[ires] = 3.14/2;
  
  for(ires=1;ires&lt;nres;ires++)
    theta[ires] = radtodeg(theta[ires]);
  for(ires=1;ires&lt;nres-1;ires++)
  {
    phi[ires] = radtodeg(phi[ires]);
    if(phi[ires] &lt; 0)
      phi[ires] += 360.0f;
  }
   
  for(ires=1;ires&lt;nres-1;ires++)
  {
    litheta = itheta;
    liphi1 = iphi1;
    liphi2 = iphi2;

    for(irnge=0;irnge&lt;10;irnge++)
      if(theta[ires] &gt; thetrg[irnge][0] &amp;&amp; theta[ires] &lt;= thetrg[irnge][1])
        break;
    itheta = irnge;

    for(irnge=0;irnge&lt;12;irnge++)
      if(phi[ires] &gt; phi1rg[irnge][0] &amp;&amp; phi[ires] &lt;= phi1rg[irnge][1])
        break;
    iphi1 = irnge;

    for(irnge=0;irnge&lt;12;irnge++)
      if(phi[ires] &gt; phi2rg[irnge][0] &amp;&amp; phi[ires] &lt;= phi2rg[irnge][1])
	 break;
    iphi2 = irnge;

    /* hack - some thetas out of range */
    if(itheta == 10)
    {
      itheta = 9;
    }
    assert(itheta &gt;=0 &amp;&amp; itheta &lt; 10);
    assert(iphi1 &gt;= 0 &amp;&amp; iphi1 &lt; 12);
    assert(iphi2 &gt;= 0 &amp;&amp; iphi2 &lt; 12);

    tenr += etheta[itheta][ apindx[ires] ];
    if(ires &gt; 1)
      p1enr += ephi1[liphi1][ apindx[ires] ]  / 2.0;
    if(ires &gt; 1)
      p2enr += ephi2[liphi2][ apindx[ires-1]] / 2.0;
    if(ires &gt; 1)
      tp1enr += ethph1[liphi1][itheta][apindx[ires]];
    if(ires &gt; 1) 
      tp2enr += ethph2[liphi2][litheta] [apindx[ires-1]];
    if(ires &gt; 1 &amp;&amp; ires &lt; nres - 2)
      p12enr += ephi12[iphi2][liphi1][apindx[ires]];
  }
  
  totpot = tenr + p1enr + p2enr + tp1enr + tp2enr + p12enr;
  /* Scale by RT=0.5896. */
  totpot *=  0.5896;
  
  return totpot;
}  

     /*
      subroutine locptx(info,nres,xcab,apindx,ephi1,ephi2,etheta,
     1 ephi12,ethph1,ethph2,phi1rg,phi2rg,thetrg,totpot,ncnf,icnf)

      implicit NONE

      include &quot;sizes.inc&quot;

      integer info,nres,apindx(MXRES),ires,ic,irnge,flag,jrnge,
     1 ncnf, icnf

      real xcab(ncnf,3,2,nres),ephi1(20,12),ephi2(20,12),
     1 ephi12(20,12,12),ethph1(20,10,12),ethph2(20,10,12),phi1rg(2,12),
     2 phi2rg(2,12),thetrg(2,10),ca1(3),ca2(3),ca3(3),ca4(3),
     3 phi(MXRES),theta(MXRES),l1,l2,sprod,pi,cavv1(3),cavv2(3),
     4 tenr,p1enr,p2enr,tp1enr,tp2enr,p12enr,totpot,etheta(20,10)

      pi=4.0*atan(1.0)

c-----Calculate the Ca virtual bond (theta) and torsion (phi) angles.
      do 10 ires=2,nres-2
c--------Assign Ca atom coordinates.
         do 11 ic=1,3
            ca1(ic)=xcab(icnf,ic,1,ires-1)
            ca2(ic)=xcab(icnf,ic,1,ires)
            ca3(ic)=xcab(icnf,ic,1,ires+1)
            ca4(ic)=xcab(icnf,ic,1,ires+2)
11       continue
c--------Calculate theta and phi for this residue.
          call cavang(info,ca1,ca2,ca3,ca4,phi(ires),theta(ires))
10    continue

c-----Calculate theta for nres-1.
c-----Assign Ca atom coordinates.
      do 12 ic=1,3
         cavv1(ic)=xcab(icnf,ic,1,nres-1)-xcab(icnf,ic,1,nres-2)
         cavv2(ic)=xcab(icnf,ic,1,nres)-xcab(icnf,ic,1,nres-1)
12    continue
      l1=sqrt(cavv1(1)**2+cavv1(2)**2+cavv1(3)**2)
      l2=sqrt(cavv2(1)**2+cavv2(2)**2+cavv2(3)**2)
c-----Use scalar product of two ca virtual bonds to get theta.
      sprod=(cavv1(1)*cavv2(1)+cavv1(2)*cavv2(2)+cavv1(3)*cavv2(3))/
     1       (l1*l2)
      theta(nres-1)=180.0-(180.0*(acos(sprod)/pi))


c-----Calculate and sum up the singlet and doublet angle potentials as follows.

c     E(theta,phi) = sum(i=2,n-1)(E(theta)(i))
c                   +sum(i=3,n-1)(E(phi1)(i)/2+E(phi2)(i-1)/2))
c                   +sum(i=3,n-1)(E(theta,phi2)(i-1)+E(theta,phi1)(i))
c                   +sum(i=3,n-2)(E(phi1,phi2)(i))

c-----Beware: phi1(ires)=phi(ires-1)
c             phi2(ires)=phi(ires)

c-----Singlet theta potentials.
      tenr=0.0
      do 20 ires=2,nres-1
         flag=0
         do 21 irnge=1,10
            if(theta(ires).gt.thetrg(1,irnge).and.
     1         theta(ires).le.thetrg(2,irnge))then
              tenr=tenr+etheta(apindx(ires),irnge)
              flag=1
            end if
21       continue
         if(flag.eq.0)then
c          write(info,1000) ires
c          STOP &apos;FATAL ERROR - theta value not assigned&apos;
         end if
20    continue

c-----Singlet phi1 potentials.
      p1enr=0.0
      do 30 ires=3,nres-1
         flag=0
         do 31 irnge=1,12
            if(phi(ires-1).gt.phi1rg(1,irnge).and.
     1         phi(ires-1).le.phi1rg(2,irnge))then
              p1enr=p1enr+ephi1(apindx(ires),irnge)/2.0
              flag=1
            end if
31       continue
         if(flag.eq.0)then
c          write(info,1100) ires
c          STOP &apos;FATAL ERROR - phi1 value not assigned&apos;
         end if
30    continue

c-----Singlet phi2 potentials.
      p2enr=0.0
      do 40 ires=3,nres-1
         flag=0
         do 41 irnge=1,12
            if(phi(ires-1).gt.phi2rg(1,irnge).and.
     1         phi(ires-1).le.phi2rg(2,irnge))then
              p2enr=p2enr+ephi2(apindx(ires-1),irnge)/2.0
              flag=1
            end if
41       continue
         if(flag.eq.0)then
c          write(info,1200) ires-1
c          STOP &apos;FATAL ERROR - phi2 value not assigned&apos;
         end if
40    continue

c-----Doublet (theta,phi1) potentials.
      tp1enr=0.0
      do 50 ires=3,nres-1
         flag=0
         do 51 irnge=1,10
            if(theta(ires).gt.thetrg(1,irnge).and.
     1         theta(ires).le.thetrg(2,irnge))then
              do 52 jrnge=1,12
                 if(phi(ires-1).gt.phi1rg(1,jrnge).and.
     1              phi(ires-1).le.phi1rg(2,jrnge))then
                   tp1enr=tp1enr+ethph1(apindx(ires),irnge,jrnge)
                   flag=1
                 end if
52            continue
            end if
51       continue
         if(flag.eq.0)then
c          write(info,1300) ires
c          STOP &apos;FATAL ERROR - (theta,phi1) value not assigned&apos;
         end if
50    continue

c-----Doublet (theta,phi2) potentials.
      tp2enr=0.0
      do 60 ires=3,nres-1
         flag=0
         do 61 irnge=1,10
            if(theta(ires-1).gt.thetrg(1,irnge).and.
     1         theta(ires-1).le.thetrg(2,irnge))then
              do 62 jrnge=1,12
                 if(phi(ires-1).gt.phi2rg(1,jrnge).and.
     1              phi(ires-1).le.phi2rg(2,jrnge))then
                   tp2enr=tp2enr+ethph2(apindx(ires-1),irnge,jrnge)
                   flag=1
                 end if
62            continue
            end if
61       continue
         if(flag.eq.0)then
c          write(info,1400) ires-1
c          STOP &apos;FATAL ERROR - (theta,phi2) value not assigned&apos;
         end if
60    continue

c-----Doublet (phi1,phi2) potentials.
      p12enr=0.0
      do 70 ires=3,nres-2
         flag=0
         do 71 irnge=1,12
            if(phi(ires-1).gt.phi1rg(1,irnge).and.
     1         phi(ires-1).le.phi1rg(2,irnge))then
              do 72 jrnge=1,12
                 if(phi(ires).gt.phi2rg(1,jrnge).and.
     1              phi(ires).le.phi2rg(2,jrnge))then
                   p12enr=p12enr+ephi12(apindx(ires),irnge,jrnge)
                   flag=1
                 end if
72            continue
            end if
71       continue
         if(flag.eq.0)then
c          write(info,1500) ires
c          STOP &apos;FATAL ERROR - (phi1,phi2) value not assigned&apos;
         end if
70    continue

c-----Calculate the total potential.
      totpot=tenr+p1enr+p2enr+tp1enr+tp2enr+p12enr

c-----Scale by RT=0.5896.
      totpot=0.5896*totpot

      return

1000  format(&apos;FATAL ERROR - assigning theta range for residue &apos;,i4)
1100  format(&apos;FATAL ERROR - assigning phi1 range for residue &apos;,i4)
1200  format(&apos;FATAL ERROR - assigning phi2 range for residue &apos;,i4)
1300  format(&apos;FATAL ERROR - assigning (theta,phi1) range for residue &apos;
     1,i4)
1400  format(&apos;FATAL ERROR - assigning (theta,phi2) range for residue &apos;
     1,i4)
1500  format(&apos;FATAL ERROR - assigning (phi1,phi2) range for residue &apos;
     1 ,i4)

      end

     */

			</file>
			<file name="raftgeometry.c" type="text">
/*
  memory leak fixed - free angs
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;assert.h&gt;

#include &quot;rotmtx.h&quot;
#include &quot;raftgeometry.h&quot;

#define degtorad(theta) ( (theta)/180.0 * M_PI)
#define lerp(a, b, t)  ( ((b) - (a)) * (t) + (a) )

static void rg_cnf2phipsiomega(RAFTGEOMETRY *rg, double *phi, double *psi, double *omega, char *secondary, int *conf, int cnf);
static void translatebb(double *vnh, double *vn, double *va, double *vb, double *vc, double *vo, int len, double *trans, double *rot);
static void mulpoint3(double *pt, double mtx[3][3]);
void rg_setballs(RAFTGEOMETRY *rg, int cnf, double *vnh,  double *vn, double *va, double *vb, double *vc, double *vo );

static void interp(float *res, double *a, double *base, float t);
static void putproline(float *res, double *vn, double *va, double *vb, float vecres, float procan);

static char baltyp(RAFTGEOMETRY *rg, char aa, int ballidx);
static float radius(RAFTGEOMETRY *rg, char aa, int ballidx);
static float vecres(RAFTGEOMETRY *rg, char aa, int ballidx);
static float kenres(RAFTGEOMETRY *rg, char aa, int ballidx);
static float hardrs(RAFTGEOMETRY *rg, char aa, int ballidx);
static float nnlenr(RAFTGEOMETRY *rg, char aa, int ballidx);
static float nplenr(RAFTGEOMETRY *rg, char aa, int ballidx);
static int nballs(RAFTGEOMETRY *rg, char aa);
static int aatoindex(char aa);
static char *mystrdup(const char *str);

/*
  Create the geometry object
  Params: ffp - the forcefield
          cs - the set of conformer angles
  Returns: pointer to constructed object, 0 on fail.
 */
RAFTGEOMETRY *raftgeometry(FORCEFIELDPARAMS *ffp, CONFORMERSET *cs)
{
    RAFTGEOMETRY *answer;

    answer = malloc(sizeof(RAFTGEOMETRY));
    if(!answer)
      goto error_exit;

    answer-&gt;balls = 0;
    answer-&gt;Nballs = 0;
    answer-&gt;Nconformers = 0;
    answer-&gt;cnf = 0;

    answer-&gt;ffp = ffp_clone(ffp);
    answer-&gt;cs = cset_clone(cs);
    if(!answer-&gt;ffp || !answer-&gt;cs)
      goto error_exit;

    return answer;
 error_exit:
    killraftgeometry(answer);
    return 0;
}

/*
  geometry destructor
  Params: rg - the geometry object to destroy
 */
void killraftgeometry(RAFTGEOMETRY *rg)
{
    int i;

    if(rg)
    {
        if(rg-&gt;cnf)
        {
	  for(i=0;i&lt;rg-&gt;Nconformers;i++)
          {
	    free(rg-&gt;cnf[i].seq);
            free(rg-&gt;cnf[i].secondary);
            free(rg-&gt;cnf[i].seqi);
            free(rg-&gt;cnf[i].angs);
            free(rg-&gt;cnf[i].CA);
            free(rg-&gt;cnf[i].CB);
            free(rg-&gt;cnf[i].Nballs);
	  }
        }
        free(rg-&gt;cnf);
        free(rg-&gt;balls);
        killforcefieldparams(rg-&gt;ffp);
        killconformerset(rg-&gt;cs);
        free(rg);
    }
}


/*
  add a conformer to the system
  Params: rg - the geometry object
          seq - sequence to add
  Notes: needs to be called only once, geometry changed by rg_setconfomer  
 */
void rg_addconformer(RAFTGEOMETRY *rg, char *seq)
{
   rg_addfragment(rg, seq, 1, 1);
}

/*
  add a conformer fragment to the system
  Params: rg - the geometry object
          seq - sequence to add
          start - flag for N terminal ball
          end - flag for C terminal ball
  Notes: needs to be called only once, geometry changed by rg_setconfomer  
 */
void rg_addfragment(RAFTGEOMETRY *rg, char *seq, int start, int end)
{
    int len;
    int totballs = 0;
    int i;
    int ii;
    int id;
    RAFTBALL *ptr;

    /* allocate everything */
    rg-&gt;cnf = realloc(rg-&gt;cnf, (rg-&gt;Nconformers + 1) * sizeof(RAFTCONFORMER));
    if(!rg-&gt;cnf)
      goto error_exit;
   
    len = strlen(seq); 
    assert(len &lt;= 1024);
    rg-&gt;cnf[rg-&gt;Nconformers].seq = mystrdup(seq);
    rg-&gt;cnf[rg-&gt;Nconformers].secondary = mystrdup(seq);
    rg-&gt;cnf[rg-&gt;Nconformers].seqi = malloc(len * sizeof(int));
    rg-&gt;cnf[rg-&gt;Nconformers].angs = malloc(len * sizeof(int));
    rg-&gt;cnf[rg-&gt;Nconformers].Nballs = malloc(len * sizeof(int));
    rg-&gt;cnf[rg-&gt;Nconformers].balls = malloc(len * sizeof(RAFTBALL *));
    rg-&gt;cnf[rg-&gt;Nconformers].CA = malloc(len * 3 * sizeof(float));
    rg-&gt;cnf[rg-&gt;Nconformers].CB = malloc(len * 3 * sizeof(float));
    rg-&gt;cnf[rg-&gt;Nconformers].len = len;
    rg-&gt;cnf[rg-&gt;Nconformers].start = start;
    rg-&gt;cnf[rg-&gt;Nconformers].end = end;
    if(!rg-&gt;cnf[rg-&gt;Nconformers].seq)
	goto error_exit;
    if(!rg-&gt;cnf[rg-&gt;Nconformers].secondary)
	goto error_exit;
    if(!rg-&gt;cnf[rg-&gt;Nconformers].seqi)
	goto error_exit;
    if(!rg-&gt;cnf[rg-&gt;Nconformers].angs)
       goto error_exit;
    if(!rg-&gt;cnf[rg-&gt;Nconformers].Nballs)
	goto error_exit;
    if(!rg-&gt;cnf[rg-&gt;Nconformers].balls)
	goto error_exit;
     
    /* set up ball numbers */
    for(i=0;i&lt;len;i++)
    {
        rg-&gt;cnf[rg-&gt;Nconformers].seqi[i] = aatoindex(seq[i]);
	rg-&gt;cnf[rg-&gt;Nconformers].Nballs[i] = nballs(rg, seq[i]);
        totballs += rg-&gt;cnf[rg-&gt;Nconformers].Nballs[i];
    }
    /* space for N and C termianl balls */
    if(start)
    {
      rg-&gt;cnf[rg-&gt;Nconformers].Nballs[0]++;
      totballs++;
    }
    if(end)
    {
      rg-&gt;cnf[rg-&gt;Nconformers].Nballs[len-1]++;
      totballs++;
    }

    rg-&gt;balls = realloc(rg-&gt;balls, (rg-&gt;Nballs + totballs) * sizeof(RAFTBALL));
    if(!rg-&gt;balls)
	goto error_exit;
    rg-&gt;Nballs += totballs;

    /* reset all the pointers */
    ptr = rg-&gt;balls;
    for(i=0;i&lt;=rg-&gt;Nconformers;i++)
    {
	for(ii=0;ii&lt;rg-&gt;cnf[i].len;ii++)
        {
	    rg-&gt;cnf[i].balls[ii] = ptr;
	    ptr += rg-&gt;cnf[i].Nballs[ii];
        }
    }

    /* fill in ball information */
    if(rg-&gt;Nconformers == 0)
      id = 0;
    else
      id = rg-&gt;Nballs - totballs;

    for(i=0;i&lt;rg-&gt;cnf[rg-&gt;Nconformers].len;i++)
      for(ii=0;ii&lt;rg-&gt;cnf[rg-&gt;Nconformers].Nballs[i];ii++)
      {
         rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].conformer = rg-&gt;Nconformers;
         rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].residue = i;
         rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].id = id;

	 /* N terminal ball */
        if(start &amp;&amp; i == 0  &amp;&amp; ii == rg-&gt;cnf[rg-&gt;Nconformers].Nballs[i]-1)
	{
          rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].type = baltyp(rg, &apos;K&apos;, 5);
	  rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].radius = radius(rg, &apos;K&apos;, 5);
	  rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].vecres = vecres(rg, &apos;K&apos;, 5);
          rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].kenres = kenres(rg, &apos;K&apos;, 5);
          rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].hardness = hardrs(rg, &apos;K&apos;, 5);
	  rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].nnlenr = nnlenr(rg, &apos;K&apos;, 5); 
          rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].nplenr = nplenr(rg, &apos;K&apos;, 5);
	}
        /* C terminal ball */
        else if(end &amp;&amp; i == len-1 &amp;&amp; ii == rg-&gt;cnf[rg-&gt;Nconformers].Nballs[i]-1)
	{
          rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].type = baltyp(rg, &apos;D&apos;, 4);
	  rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].radius = radius(rg, &apos;D&apos;, 4);
	  rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].vecres = vecres(rg, &apos;D&apos;, 4);
          rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].kenres = kenres(rg, &apos;D&apos;, 4);
          rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].hardness = hardrs(rg, &apos;D&apos;, 4);
	  rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].nnlenr = nnlenr(rg, &apos;D&apos;, 4); 
          rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].nplenr = nplenr(rg, &apos;D&apos;, 4);
	}
        /* Normal ball */
        else
        { 
          rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].type = baltyp(rg, seq[i], ii);
	  rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].radius = radius(rg, seq[i], ii);
	  rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].vecres = vecres(rg, seq[i], ii);
          rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].kenres = kenres(rg, seq[i], ii);
          rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].hardness = hardrs(rg, seq[i], ii);
	  rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].nnlenr = nnlenr(rg, seq[i], ii); 
          rg-&gt;cnf[rg-&gt;Nconformers].balls[i][ii].nplenr = nplenr(rg, seq[i], ii);
	}
        id++;
      }
    rg-&gt;Nconformers++;

    return;
 error_exit:
    fprintf(stderr, &quot;rg_setconformer: Out of memory\n&quot;);
    exit(EXIT_FAILURE);
}

/*
  set a conformer to given RAFT angles
 */
void rg_setconformer(RAFTGEOMETRY *rg, int cnf, int *angles, double *trans, double *rot)
{
    static double phi[1024];
    static double psi[1024];
    static double omega[1024];
    static double vnh[1024*3];
    static double vn[1024 * 3];
    static double va[1024 * 3];
    static double vb[1024 * 3];
    static double vc[1024 * 3];
    static double vo[1024 * 3];
    int len;
    int i;
   
    len = rg-&gt;cnf[cnf].len;
    memcpy(rg-&gt;cnf[cnf].angs, angles, len * sizeof(int));
    rg_cnf2phipsiomega(rg, phi, psi, omega, rg-&gt;cnf[cnf].secondary, angles, cnf);
    bbone(vnh, vo, va, vb, vn, vc, phi, psi, omega, len);
    translatebb(vnh, vn, va, vb, vc, vo, len, trans, rot); 
    for(i=0;i&lt;len*3;i++)
    {
      rg-&gt;cnf[cnf].CA[i] = (float) va[i];
      rg-&gt;cnf[cnf].CB[i] = (float) vb[i];
    }
    rg_setballs(rg, cnf, vnh, vn, va, vb, vc, vo);
}

/*
  clear all the flagged hydrogen bonds 
 */
void rg_clearhbonds(RAFTGEOMETRY *rg)
{
    int i;
    for(i=0;i&lt;rg-&gt;Nballs;i++)
    {
	rg-&gt;balls[i].hbonded = 0;
        rg-&gt;balls[i].hbondpartner = -1;
    }
}

char rg_sectype(RAFTGEOMETRY *rg, int cnf, int res)
{
  return rg-&gt;cnf[cnf].secondary[res];
}

void rg_sethdonor(RAFTGEOMETRY *rg, int ballid) 
{
     rg-&gt;balls[ballid].hbonded = 1; 
} 

void rg_sethacceptor(RAFTGEOMETRY *rg, int ballid) 
{ 
     rg-&gt;balls[ballid].hbonded = 1; 
} 

int rg_gethdonor(RAFTGEOMETRY *rg, int ballid) 
{ 
     return rg-&gt;balls[ballid].hbonded; 
}
 
int rg_gethacceptor(RAFTGEOMETRY *rg, int ballid) 
{ 
     return rg-&gt;balls[ballid].hbonded; 
}


float rg_nnlenr(RAFTGEOMETRY *rg, int ballid)
{
    return rg-&gt;balls[ballid].nnlenr;
}

float rg_nplenr(RAFTGEOMETRY *rg, int ballid)
{
    return rg-&gt;balls[ballid].nplenr;
}

float rg_hardrs(RAFTGEOMETRY *rg, int ballid)
{
    return rg-&gt;balls[ballid].hardness;
}

/*
  Get the charge on a ball
  Params: rg - the geometry
          ball id - id of ball
  Returns: charge on ball (-1, 1, 0)
 */
int rg_charge(RAFTGEOMETRY *rg, int ballid)
{
    char aaid;
    char *seq;

    if(rg-&gt;balls[ballid].residue == 0)
	return 1;
    if(rg-&gt;balls[ballid].residue == rg-&gt;cnf[rg-&gt;balls[ballid].conformer].len-1)
	return -1;
   
    seq = rg-&gt;cnf[ rg-&gt;balls[ballid].conformer ].seq;
    aaid = seq[ rg-&gt;balls[ballid].residue ];
    if(aaid == &apos;D&apos; || aaid == &apos;E&apos;)
	return -1;
    if(aaid == &apos;K&apos; || aaid == &apos;R&apos;)
        return 1;

    return 0; 
}

/*
  convert RAFT conformers to phi / psi / omega angles
  Params: rg - the geometry
          phi - return for phi angles
          psi - return for psi angles
          omega - return for omega angles
          secondrary - return for seconrary type (H, B &apos; &apos; )
          conf - the reduced angles 
          cnf - index of conformer
 */
static void rg_cnf2phipsiomega(RAFTGEOMETRY *rg, double *phi, double *psi, double *omega, char *secondary, int *conf, int cnf)
{
    int i;
    int len;
    float fphi, fpsi, fomega;

    len = rg-&gt;cnf[cnf].len;
    for(i=0;i&lt;len;i++)
    {
	getconformeri(rg-&gt;cs, rg-&gt;cnf[cnf].seqi[i], conf[i]+1, &amp;fomega, &amp;fphi, &amp;fpsi, &amp;secondary[i]);
        phi[i] = degtorad(fphi);
        psi[i] = degtorad(fpsi);
        omega[i] = degtorad(fomega);
    }
}

static void translatebb(double *vnh, double *vn, double *va, double *vb, double *vc, double *vo, int len, double *trans, double *rot)
{
  double rotmtx[3][3];
  int i, ii;

  rotmat(rot[0], rot[1], rot[2], rotmtx);

  for(i=0;i&lt;len;i++)
  {
    mulpoint3(&amp;vnh[i*3], rotmtx);
    mulpoint3(&amp;vn[i*3], rotmtx);
    mulpoint3(&amp;va[i*3], rotmtx);
    mulpoint3(&amp;vb[i*3], rotmtx);
    mulpoint3(&amp;vc[i*3], rotmtx);
    mulpoint3(&amp;vo[i*3], rotmtx);
  }
  for(i=0;i&lt;len;i++)
  {
    for(ii=0;ii&lt;3;ii++)
    {
      vnh[i*3+ii] += trans[ii];
      vn[i*3+ii] += trans[ii];
      va[i*3+ii] += trans[ii];
      vb[i*3+ii] += trans[ii];
      vc[i*3+ii] += trans[ii];
      vo[i*3+ii] += trans[ii];
    }
  }
}

/*
  multiply a point by a 3x3 rotation matrix
  Params: pt - the point
  mtx - matrix, in Fortran order
 */
static void mulpoint3(double *pt, double mtx[3][3])
{
  int i;
  double temp[3];
  
  for(i=0;i&lt;3;i++)
  {
    temp[i] = pt[0] * mtx[0][i] + pt[1] * mtx[1][i] + pt[2] * mtx[2][i];
  }
  pt[0] = temp[0];
  pt[1] = temp[1];
  pt[2] = temp[2];
}

/*
  set the balls to their correct vlaues
  Parmas: rg - the geometry object
          cnf - the conformer
          vnh - nitogren hydrogen (ignore for proline)
          vn - nitrogen
          va - carbon alpha
          vb - carbon beta (ignore for glycine)
          vc - backbone carbon 
          vo - backbone oxygen
 */ 
void rg_setballs(RAFTGEOMETRY *rg, int cnf, double *vnh,  double *vn, double *va, double *vb, double *vc, double *vo )
{
    float procan =  0.823;
    int len;
    float *ptr;
    float vecres;
    int i;
    int ib;
    int N;

/*
  Output the appropriate coordinate arrays remembering to convert to real.
  The array seqb is used to identify the proline residue so that we can calculate
  its special geometry. The fraction of the CA-&gt;N vector to add to the CA-&gt;CB
  vector is given by procan
*/
    procan = 0.823;

    len = rg-&gt;cnf[cnf].len;


/*
  Output for xball. Do residue 1 and n separately as have to deal with the
   N- and C-terminal balls.

   N-terminal residue.
   Acceptor ball.
*/
   ptr = rg-&gt;cnf[cnf].balls[0][1].pos;
   vecres = rg-&gt;cnf[cnf].balls[0][1].vecres;
   interp(ptr, &amp;vo[0], &amp;vc[0], vecres);
   if(rg-&gt;cnf[cnf].Nballs[0] &gt;= 4)
   {
/*
  We have sidechain balls to compute using vecres(ib,1).
  Proline is the exception, so test for this.
*/
						    
	  if(rg-&gt;cnf[cnf].seq[0] == &apos;P&apos;)
          {
              ptr  = rg-&gt;cnf[cnf].balls[0][3].pos;
	      vecres = rg-&gt;cnf[cnf].balls[0][3].vecres;
              putproline(ptr, vn, va, vb, vecres,procan);   
	  }
          else
          {
	      for(ib = 3; ib &lt; rg-&gt;cnf[cnf].Nballs[0] -rg-&gt;cnf[cnf].start; ib++)
              {
		  ptr = rg-&gt;cnf[cnf].balls[0][ib].pos;
                  vecres = rg-&gt;cnf[cnf].balls[0][ib].vecres;
                  interp(ptr, vb, va, vecres);
              }
          }
      }

          N = rg-&gt;cnf[cnf].Nballs[0] - 1;
/* N-terminal ball. */
          if(rg-&gt;cnf[cnf].start)
          {
	    rg-&gt;cnf[cnf].balls[0][N].pos[0] = vn[0];
            rg-&gt;cnf[cnf].balls[0][N].pos[1] = vn[1];
            rg-&gt;cnf[cnf].balls[0][N].pos[2] = vn[2];
          }


/*
  C-terminal residue.
  Donor and backbone balls.
*/

	  ptr = rg-&gt;cnf[cnf].balls[len-1][0].pos;
          vecres = rg-&gt;cnf[cnf].balls[len-1][0].vecres;
          interp(ptr, &amp;vnh[(len-1)*3], &amp;vn[(len-1)*3], vecres);
   
          ptr = rg-&gt;cnf[cnf].balls[len-1][2].pos;
          interp(ptr, &amp;va[(len-1)*3], &amp;va[(len-2)*3], 0.5);
   
          if(rg-&gt;cnf[cnf].seq[len-1] == &apos;P&apos;)
         {
            ptr = rg-&gt;cnf[cnf].balls[len-1][3].pos;
            vecres = rg-&gt;cnf[cnf].balls[len-1][3].vecres;
	    putproline(ptr, &amp;vn[(len-1)*3], &amp;va[(len-1)*3], &amp;vb[(len-1)*3], vecres, procan);  
         }
    else
    {
	for(ib = 3; ib &lt; rg-&gt;cnf[cnf].Nballs[len-1] -rg-&gt;cnf[cnf].end;ib++)
        {
	    ptr = rg-&gt;cnf[cnf].balls[len-1][ib].pos;
            vecres = rg-&gt;cnf[cnf].balls[len-1][ib].vecres;
            interp(ptr, &amp;vb[(len-1)*3], &amp;va[(len-1)*3], vecres);
        }   
    }
	  N = rg-&gt;cnf[cnf].Nballs[len-1] - 1;
    /* c terminal ball */
          if(rg-&gt;cnf[cnf].end)
          {
	    rg-&gt;cnf[cnf].balls[len-1][N].pos[0] = vc[(len-1)*3];
            rg-&gt;cnf[cnf].balls[len-1][N].pos[1] = vc[(len-1)*3+1];
            rg-&gt;cnf[cnf].balls[len-1][N].pos[2] = vc[(len-1)*3+2];
          }

     for(i=1; i &lt; len -1; i++)
     {
         /* Donor, acceptor, and backbone balls */
         ptr = rg-&gt;cnf[cnf].balls[i][0].pos;
         vecres = rg-&gt;cnf[cnf].balls[i][0].vecres;
	 interp(ptr, &amp;vnh[i*3], &amp;vn[i*3], vecres);

         ptr = rg-&gt;cnf[cnf].balls[i][1].pos;
         vecres = rg-&gt;cnf[cnf].balls[i][1].vecres;
         interp(ptr, &amp;vo[i*3], &amp;vc[i*3], vecres);

         ptr = rg-&gt;cnf[cnf].balls[i][2].pos;
         interp(ptr, &amp;va[i*3], &amp;va[(i-1) * 3], 0.5);

         if(rg-&gt;cnf[cnf].seq[i] == &apos;P&apos;)
         {
             ptr = rg-&gt;cnf[cnf].balls[i][3].pos;
             vecres = rg-&gt;cnf[cnf].balls[i][3].vecres; 
             putproline(ptr, &amp;vn[i*3], &amp;va[i*3], &amp;vb[i*3], vecres, procan);
	 }
         else
	     for(ib=3;ib&lt;rg-&gt;cnf[cnf].Nballs[i]; ib++)
             {
		 ptr = rg-&gt;cnf[cnf].balls[i][ib].pos;
                 vecres = rg-&gt;cnf[cnf].balls[i][ib].vecres; 
	         interp(ptr, &amp;vb[i*3], &amp;va[i*3], vecres);
             }
     }
} 

/*
  interpolate an atom position
  Params: res - return 
          a - atom a coords
          base - atom b coords
          t - interpolation 0 = base, 1 = a
 */     
static void interp(float *res, double *a, double *base, float t)
{
    res[0] = lerp(base[0], a[0], t);
    res[1] = lerp(base[1], a[1], t);
    res[2] = lerp(base[2], a[2], t);
} 

/*
  Special routine to place proline sidechain ball
  Parmas: res - return for result
          vn - nitrogen
          va - carbon alpha
          vb - carbon beta
          vecres - Proline ball offset
          procan - fiddle factor
 */
static void putproline(float *res, double *vn, double *va, double *vb, float vecres, float procan)
{
  int i;
  float temp[3];

  for(i=0;i&lt;3;i++)
  {
    res[i] = vb[i] -  va[i];
    res[i] *=  vecres;
    temp[i] = vn[i] - va[i];
    temp[i] *=  procan;
    temp[i] +=  va[i];
    res[i] += temp[i];
  }   
}

/*
  List of fucntions to extract data from the ForcefieldParamters file

*/
static char baltyp(RAFTGEOMETRY *rg, char aa, int ballidx)
{
   int aaidx;
   static char *aaids = &quot;ACDEFGHIKLMNPQRSTVWY&quot;;
   aaidx = strchr(aaids, aa) - aaids;
   assert(ballidx &gt;= 0 &amp;&amp; ballidx &lt; rg-&gt;ffp-&gt;res[aaidx].Nballs);
   return rg-&gt;ffp-&gt;res[aaidx].ball[ballidx].type;
}

static float radius(RAFTGEOMETRY *rg, char aa, int ballidx)
{
   int aaidx;
   static char *aaids = &quot;ACDEFGHIKLMNPQRSTVWY&quot;;
   aaidx = strchr(aaids, aa) - aaids;
   assert(ballidx &gt;= 0 &amp;&amp; ballidx &lt; rg-&gt;ffp-&gt;res[aaidx].Nballs);
   return rg-&gt;ffp-&gt;res[aaidx].ball[ballidx].radius;
}

static float vecres(RAFTGEOMETRY *rg, char aa, int ballidx)
{
    int aaidx;
    static char *aaids = &quot;ACDEFGHIKLMNPQRSTVWY&quot;;
    aaidx = strchr(aaids, aa) - aaids;
    assert(ballidx &gt;= 0 &amp;&amp; ballidx &lt; rg-&gt;ffp-&gt;res[aaidx].Nballs);
    return rg-&gt;ffp-&gt;res[aaidx].ball[ballidx].vector_pos;
}

static float kenres(RAFTGEOMETRY *rg, char aa, int ballidx)
{
    int aaidx;
    static char *aaids = &quot;ACDEFGHIKLMNPQRSTVWY&quot;;
    aaidx = strchr(aaids, aa) - aaids;
    assert(ballidx &gt;= 0 &amp;&amp; ballidx &lt; rg-&gt;ffp-&gt;res[aaidx].Nballs);
    return rg-&gt;ffp-&gt;res[aaidx].ball[ballidx].potential;
}

static float hardrs(RAFTGEOMETRY *rg, char aa, int ballidx)
{
    int aaidx;
    static char *aaids = &quot;ACDEFGHIKLMNPQRSTVWY&quot;;
    aaidx = strchr(aaids, aa) - aaids;
    assert(ballidx &gt;= 0 &amp;&amp; ballidx &lt; rg-&gt;ffp-&gt;res[aaidx].Nballs);
    return rg-&gt;ffp-&gt;res[aaidx].ball[ballidx].hardness;
}

static float nnlenr(RAFTGEOMETRY *rg, char aa, int ballidx)
{
    int aaidx;
    static char *aaids = &quot;ACDEFGHIKLMNPQRSTVWY&quot;;
    aaidx = strchr(aaids, aa) - aaids;
    assert(ballidx &gt;= 0 &amp;&amp; ballidx &lt; rg-&gt;ffp-&gt;res[aaidx].Nballs);
    return rg-&gt;ffp-&gt;res[aaidx].ball[ballidx].NN_length;
}

static float nplenr(RAFTGEOMETRY *rg, char aa, int ballidx)
{
    int aaidx;
    static char *aaids = &quot;ACDEFGHIKLMNPQRSTVWY&quot;;
    aaidx = strchr(aaids, aa) - aaids;
    assert(ballidx &gt;= 0 &amp;&amp; ballidx &lt; rg-&gt;ffp-&gt;res[aaidx].Nballs);
    return rg-&gt;ffp-&gt;res[aaidx].ball[ballidx].NP_length;
}

static int nballs(RAFTGEOMETRY *rg, char aa)
{
    int index;
    static char *aaids = &quot;ACDEFGHIKLMNPQRSTVWY&quot;;
    index = strchr(aaids, aa) - aaids;
    return rg-&gt;ffp-&gt;res[index].Nballs;
}

/*
  convert a one letter amino acid code to an index
 */
static int aatoindex(char aa)
{
   static char *aaids = &quot;ACDEFGHIKLMNPQRSTVWY&quot;;
   char *ptr;

   ptr = strchr(aaids, aa);
   if(ptr)
       return ptr - aaids;
   else
       return -1;
}


/*
  strdup drop-in
 */
static char *mystrdup(const char *str)
{
    char *answer;

    answer = malloc(strlen(str) + 1);
    if(answer)
	strcpy(answer, str);

    return answer;
}

/*
  gets the distance between the N- and C- terminal CAs for a chain
 */
float rg_extension(RAFTGEOMETRY *rg, int cnf)
{
  float *NCA;
  float *CCA;
  int len;

  len = rg-&gt;cnf[cnf].len;
  NCA = &amp;rg-&gt;cnf[cnf].CA[0];
  CCA = &amp;rg-&gt;cnf[cnf].CA[(len-1)*3];

  return (float) sqrt( (NCA[0]-CCA[0]) * (NCA[0]-CCA[0]) + 
                       (NCA[1]-CCA[1]) * (NCA[1]-CCA[1]) +
                       (NCA[2]-CCA[2]) * (NCA[2]-CCA[2])  );
}

static void runfilter(char *str, char ch, char ch2, int minrun)
{
  int i = 0;
  int j;

  while(str[i])
  {
    if(str[i] == ch)
    {
      for(j=1;str[i+j] == ch;j++)
        ;
      if(j &lt; minrun)
      {
        while(j--)
          str[i++] = ch2;
      }
      else
        i += j;
    }
    else
      i++;
  }
}                

void rg_getsecondary(RAFTGEOMETRY *rg, int cnf, char *sec)
{
  int i;
  int partner;

  for(i=0;i&lt;rg-&gt;cnf[cnf].len;i++)
    sec[i] = (rg-&gt;cnf[cnf].secondary[i] == &apos;H&apos;) ? &apos;H&apos; : &apos;-&apos;;
  sec[i] = 0;

  runfilter(sec, &apos;H&apos;, &apos;-&apos;, 3);
  for(i=0;i&lt;rg-&gt;cnf[cnf].len;i++)
  {
    partner = rg-&gt;cnf[cnf].balls[i][0].hbondpartner;
    if(partner == -1)
      continue;
    else if(rg-&gt;cnf[cnf].secondary[i] == &apos;B&apos;)
    {
      sec[i] = &apos;B&apos;;
      sec[partner] = &apos;B&apos;;
    }
  }
  
}

void oldrg_getsecondary(RAFTGEOMETRY *rg, int cnf, char *sec)
{
  int i;
  int partner;
  int hack = 0;

  for(i=0;i&lt;rg-&gt;cnf[cnf].len;i++)
    sec[i] = &apos;-&apos;;
  sec[i] = 0;

  for(i=0;i&lt;rg-&gt;cnf[cnf].len;i++)
  {
    partner = rg-&gt;cnf[cnf].balls[i][0].hbondpartner;
    if(partner == -1)
      continue;
    if(partner == i - 4)
    {
      if(rg-&gt;cnf[cnf].secondary[i] == &apos;H&apos;)
      {
        sec[i-4] = &apos;H&apos;;
        sec[i-3] = &apos;H&apos;;
        sec[i-2] = &apos;H&apos;;
        sec[i-1] = &apos;H&apos;;
        sec[i] = &apos;H&apos;;
      }
    }
    else if(abs(i-partner) &gt; 4)
    {
      sec[i] = &apos;B&apos;;
      sec[partner] = &apos;B&apos;;
    }
  }
   

}

			</file>
			<file name="torsion.c" type="text">
/*
  torsion.c 
  C-language functions for applying and calculating  torsoin 
  angles
 */
#include &lt;math.h&gt;


float calctorsion(float *A, float *B, float *C, float *D);
void puttor(float *D, float *A, float *B, float *C, float len, float theta, float phi);

#define PI 3.14159265

static void crossproduct(float *ans, float *pt1, float *pt2);
static float dot(float *a, float *b);
static int normalize(float *v);
static void vsub(float *res, float *a, float *b);


/*
  calculate the torsion angle formed by four sets of co-ordinates
  Params: A , B, C, D - points in Cartesian space
  Returns: torsion angle between AB and CD
 */
float calctorsion(float *A, float *B, float *C, float *D)
{
  
  float BA[3];
  float BC[3];
  float DC[3];

  float di[3], gi[3]; 
  float bi, bk, ct;
  float z1, z2, s;
  float answer;

   /* Calculate the vectors BA,BC,DC */     
   vsub(BA, A, B);
   vsub(BC, C, B);
   vsub(DC, C, D);

   /* Calculate the normals to the two planes n1 and n2
      this is given as the cross products:
       AB x BC
      --------- = n1
      |AB x BC|

       BC x CD
      --------- = n2
      |BC x CD|
   */
   

   crossproduct(di, BA, BC);
   crossproduct(gi, BC, DC);  
   
   bi = dot(di, di);
   bk = dot(gi, gi);
   ct = dot(di, gi);

   bi   = (float)sqrt((double)bi);
   bk   = (float)sqrt((double)bk);

   z1   = 1.0f/bi;
   z2   = 1.0f/bk;
   ct   = ct * z1 * z2;
   if (ct &gt;  1.0f)   ct = 1.0f;
   if (ct &lt; (-1.0f)) ct = -1.0f;
   answer   = acos(ct);

   /* calculate side of plane we are on */
   s = BC[0] * (di[2] * gi[1] - di[1] * gi[2])
     + BC[1] * (di[0] * gi[2] - di[2] * gi[0])
     + BC[2] * (di[1] * gi[0] - di[0] * gi[1]);

   if (s &gt; 0.0f) answer = -answer;


   return answer;
}

/*
  natural extension reference put torsion

  Reference Parsons et al (2005) 
   Practical conversion from torsion space to Cartesian space for In Silico
   protein synthesis.

 Journal of Computational Chemistry 26: 1063 - 1068
 
  Places a point in position given length, angle and torsion 
  Params: D - output
          A, B, C - three points in space
          len - length of vector CD
          theta - angle BCD
          phi - torsion angle between AB and DC
  Notes: points in cis are considered to have 0 torsion, points in trans
     have a torsion of PI
   
 */
void puttor(float *D, float *A, float *B, float *C, float len, float theta, float phi)
{
  float n[3];      /* normal to plane ABC */
  float D1[3];     /* point as defined by torsion, length and angle */
  float D2[3];     /* point rotated into correct plane */
  float mtx[3][3]; /* rotation matrix */
  float nxBC[3];   /* normal crossed with BC */
  float AB[3];     /* vector A -&gt; B */
  float BC[3];     /* vector B -&gt; C */

  /* set up planes */
  vsub(AB, B, A);
  vsub(BC, C, B);

  crossproduct(n, AB, BC);
  normalize(n);
  normalize(BC);
  crossproduct(nxBC, n, BC);
 

  /* construct point along Y axis */ 
  theta = PI - theta;
  
  D1[0] = len * cos(theta);
  D1[1] = len * cos(phi) * sin(theta);
  D1[2] = len * sin(phi) * sin(theta);


  /* redundant - copy values to our matrix */
  mtx[0][0] = BC[0]; 
  mtx[1][0] = BC[1]; 
  mtx[2][0] = BC[2];

  mtx[0][1] = nxBC[0], 
  mtx[1][1] = nxBC[1]; 
  mtx[2][1] = nxBC[2];

  mtx[0][2] = n[0], 
  mtx[1][2] = n[1]; 
  mtx[2][2] = n[2];


  /* matrix multiply to put point in correct orientation */

  D2[0] = D1[0] * mtx[0][0] + D1[1] * mtx[0][1] + D1[2] * mtx[0][2];
  D2[1] = D1[0] * mtx[1][0] + D1[1] * mtx[1][1] + D1[2] * mtx[1][2];
  D2[2] = D1[0] * mtx[2][0] + D1[1] * mtx[2][1] + D1[2] * mtx[2][2];


  /* translate by point C */
  D[0] = D2[0] + C[0];
  D[1] = D2[1] + C[1];
  D[2] = D2[2] + C[2];
  
} 


/*
  get the crossproduct of two vectors.
  Params: ans - return pointer for answer.
          pt1 - first vector
		  pt2 - second vector.
  Notes: crossproduct is at right angles to the two vectors.
*/
static void crossproduct(float *ans, float *pt1, float *pt2)
{
  ans[0] = pt1[1] * pt2[2] - pt1[2] * pt2[1];
  ans[1] = pt1[2] * pt2[0] - pt1[0] * pt2[2];
  ans[2] = pt1[0] * pt2[1] - pt1[1] * pt2[0];
}

/*
  get the dotproduct of two vectors
  Params: a - vector 1
          b - vector 2
  Returns: dot product
  Notes = cosine of angle between if both vectors are normal 
 */

static float dot(float *a, float *b)
{
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/*
  normalize a vector
  Params: v - vector to normalize
  Returns: 0 on success, -1 on zero vector
 */
static int normalize(float *v)
{
  double len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
  if(len == 0)
    return -1;
  v[0] /= len;
  v[1] /= len;
  v[2] /= len;
  return 0;
}

/*
  subtrract two vectors
  Params: res - result
          a - vector 1
          b - vector to subtract
 */
static void vsub(float *res, float *a, float *b)
{
  res[0] = a[0] - b[0];
  res[1] = a[1] - b[1];
  res[2] = a[2] - b[2];
}

			</file>
			<file name="anneal.c" type="text">

#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;float.h&gt;

static int metrop(double current, double test, double temperature);
static double getdecrement(double start, double end, int Nsteps);
static double stdev(double *x, int N);

/*
  All function pointers take a arbitrary pointer ptr as a parameter.
  This can be NULL.

  Function to create a local copy of an object
void *clone(void *obj, void *ptr);
  Function to destroy an object
void kill(void *obj, void *ptr);
  Function to copy one object to another (more efficient than clone)
int copy(void *dest, void *src, void *ptr);

  The score function to minimise
double score(void *obj, void *ptr);
  The move function
void mutate(void *obj, void *ptr);

  For parallel programming

  We need to be able to represent objects as serial streams of bytes.

  Convert serial representation to object  
int deserialise(void *obj, unsigned char *buff, int len, void *ptr);
  Serialise when we know maximum size (for efficiency)
int serialise(void *obj, unsigned char *buff, int capacity, void *ptr);
  Serialise when we don&apos;t know maximum size
void *serialisev(void *obj, int *len, void *ptr); 
*/

/*
  Fairly standard simulate annealing schedule
  Params: obj - the object to minimise
          clone - clone function
          kill - destructor function
          copy - function to copy
          score - the score function
          mutate - move a step
          Nevaluations - number of times to evaluate score function
          ptr - pointer to pass to parameterised functions
 */
int anneal(void *obj, 
           void * (*clone)(void *obj, void *ptr),
           void (*kill)(void *obj, void *ptr), 
           int  (*copy)(void *dest, void *src, void *ptr),
           double (*score) (void *obj, void *ptr),
           void (*mutate) (void *obj, void *ptr),
           int Nevaluations, void *ptr)
{
  void *current = 0;
  void *test = 0;
  double mindiff = DBL_MAX;
  int i;
  double initial[1024];
  double temperature = 1.0;
  double endtemp;
  double curscore;
  double testscore;
  double bestscore;
  double dec;

  current = clone(obj, ptr);
  if(!current)
    goto error_exit;
  test = clone(obj, ptr);
  if(!test)
    goto error_exit;

  curscore = score(current, ptr);
  bestscore = curscore;

  for(i=0;i&lt;1024;i++)
  {
    copy(test, current, ptr);
    mutate(test, ptr);
    initial[i] = score(test,ptr);
    if( fabs(initial[i] - curscore) &lt; mindiff)
      if(initial[i] != curscore)
        mindiff = fabs(initial[i] - curscore);
    if(metrop(curscore, initial[i], temperature))
    {
      copy(current, test, ptr);
      curscore = initial[i];
      if(bestscore &gt; curscore)
      {
        bestscore = curscore;
        copy(obj, current, ptr);
      }
    }
  }   

 temperature = stdev(initial, 1024) * 2.0;

 endtemp = 1.0; //mindiff;// /3.0;
 dec = getdecrement(temperature, endtemp, Nevaluations);


 for(i=0;i&lt;Nevaluations;i++)
 {
    copy(test, current, ptr);
    mutate(test, ptr);
    testscore = score(test,ptr);
    // if(testscore != curscore &amp;&amp; fabs(testscore - curscore) &lt; mindiff)
    // {
    //  mindiff = fabs(testscore - curscore);
    //  endtemp = mindiff;  // 3.0;
    //  dec = getdecrement(temperature, endtemp, Nevaluations - i);
    // }
    if(metrop(curscore, testscore, temperature))
    {
      copy(current, test, ptr);
      curscore = testscore;
      if(bestscore &gt; curscore)
      {
        bestscore = curscore;
        copy(obj, current, ptr);
      }
    }

    temperature *= dec;
 }

 kill(test, ptr);
 kill(current, ptr);

 return 0;

error_exit:
 if(test)
   kill(test, ptr);
 if(current)
   kill(current, ptr);

 return -1;
}

static int metrop(double current, double test, double temperature)
{
  double p;

  if(test &lt;= current)
    return 1;
  else
  {
    p = rand() /(RAND_MAX + 1.0);
    if( p &lt; exp( (current - test) / temperature ) )
      return 1;
    else
      return 0;
  }
}

static double getdecrement(double start, double end, int Nsteps)
{
  /* start * answer^Nsteps = end */
  return  exp( (log(end) - log(start))/Nsteps);
}

static double stdev(double *x, int N)
{
  int i;
  double total = 0;
  double totalvar = 0;
  double mean;

  for(i=0;i&lt;N;i++)
    total += x[i];
  mean = total/N;

  for(i=0;i&lt;N;i++)
    totalvar += (x[i] - mean) * (x[i] - mean);

  return sqrt(totalvar/N);
}

			</file>
			<file name="raft.h" type="text">
#ifndef raft_h
#define raft_h

float raft(RAFTGEOMETRY *rg, INPUTPARAMS *ip);

#endif

			</file>
			<file name="main.c" type="text">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;readinputdata.h&quot;
#include &quot;writeoutput.h&quot;
#include &quot;raftgeometry.h&quot;
#include &quot;raft.h&quot;
#include &quot;rg_localpotential.h&quot;

#include &quot;localpotentialraft.h&quot;

void usage(void)
{
  printf(&quot;version 3.0 (cis pro)\n&quot;);
  printf(&quot;Does raft / localpotential balance\n&quot;);
  printf(&quot;Usage &lt;simanl.inp&gt; &lt;locpotp&gt;\n&quot;);
  printf(&quot;locpotp - weight to give to local potential\n&quot;);
  exit(EXIT_FAILURE);
}

int main(int argc, char **argv)
{
  char *inp = argv[1];
  INPUTDATA *id;
  int *N;
  double locpotp = 0;
  int i;
  int *cnf;
  int conf[256];
  double zero[3] = {0, 0, 0};
  char *seq = &quot;MTYKLILNGKTLKGETTTEAVDAATAEKVFKQYANDNGVDGEWTYDDATKTFTVT&quot;;
  char *out = &quot;5344444413520424435222255233444432220240522024435000220&quot;;
  double rafteg, localeg;
  RAFTGEOMETRY *rg;
 
  if(argc != 3)
    usage();

  locpotp = strtod(argv[2], 0);

  printf(&quot;%s %g\n&quot;, argv[1], locpotp);
  id = readinputdata(inp);
  if(!id)
  {
    fprintf(stderr, &quot;Can&apos;t read inputdata\n&quot;);
    exit(EXIT_FAILURE);
  }
  printf(&quot;Loaded OK\n&quot;);
  

  /*  
  for(i=0;i&lt;56;i++)
    conf[i] = out[i] - &apos;0&apos;;
  rg = raftgeometry(id-&gt;ffp, id-&gt;cfd);
  rg_addconformer(rg, seq);
  rg_setconformer(rg, 0, conf, 0, 0);
  id-&gt;ip-&gt;window = 0;
  printf(&quot;%g\n&quot;, raft(rg, id-&gt;ip));
  id-&gt;ip-&gt;window = 13;
  printf(&quot;%g\n&quot;, raft(rg, id-&gt;ip));
  printf(&quot;local potential %g\n&quot;, rg_localpotential(rg));
  exit(0);
  */

  id-&gt;ip-&gt;window = 0;
  cnf = localpotentialraft(id-&gt;seq-&gt;seq, locpotp,  id-&gt;cfd, id-&gt;ffp, id-&gt;ip, 10000000); 

  for(i=0;i&lt;strlen(id-&gt;seq-&gt;seq);i++)
    conf[i] = cnf[i] - 1;
  rg = raftgeometry(id-&gt;ffp, id-&gt;cfd);
  rg_addconformer(rg, id-&gt;seq-&gt;seq);
  rg_setconformer(rg, 0, conf, 0, 0);
  id-&gt;ip-&gt;window = 0;
  rafteg = raft(rg, id-&gt;ip);
  localeg = rg_localpotential(rg);
  killraftgeometry(rg);

  printf(&quot;%s tot %f raft %f local %f fmix %f\n&quot;, id-&gt;ip-&gt;seqbas, rafteg + localeg * locpotp, rafteg, localeg, locpotp); 
 
  writeoutput(id-&gt;ip-&gt;outfil, id-&gt;seq-&gt;seq, cnf, zero, zero, 1, rafteg); 
  killinputdata(id);
  
  return 0;  
 
}

			</file>
			<file name="potcispro.c" type="text">

float lpephi1[12][21] = {
  {1.330, 0.570, 0.650, 1.020, 0.480, -0.250, 0.300, 1.330, 1.040, 1.450, 1.280, 0.200, 1.460, 1.100, 0.990, 0.740, 0.600, 1.110, 0.850, 0.370, -1.452, },
  {-1.730, -1.270, -1.380, -1.730, -1.460, -0.870, -1.440, -1.460, -1.590, -1.700, -1.660, -1.400, -0.160, -1.700, -1.620, -1.220, -1.230, -1.310, -1.440, -1.430, -1.519, },
  {0.050, 0.150, -0.160, -0.030, 0.230, 0.200, 0.010, 0.550, 0.030, 0.260, 0.130, 0.010, 1.440, 0.010, 0.070, -0.230, 0.170, 0.600, 0.040, 0.240, 0.471, },
  {0.690, 0.430, 0.590, 0.930, 0.880, 0.640, 0.700, 0.790, 0.560, 0.700, 0.610, 0.710, 3.690, 0.630, 0.700, 0.370, 0.570, 0.750, 0.690, 0.820, 1.908, },
  {0.750, 0.420, 0.710, 1.050, 0.750, 0.770, 0.740, 0.900, 0.870, 0.960, 0.790, 0.850, 2.820, 0.870, 0.790, 0.470, 0.590, 0.960, 0.670, 0.770, 2.214, },
  {0.360, -0.060, 0.650, 0.720, 0.040, 0.530, 0.220, 0.150, 0.470, 0.460, 0.280, 0.510, 0.390, 0.480, 0.340, 0.100, -0.130, -0.030, 0.070, 0.030, 1.520, },
  {-0.170, -0.700, -0.090, -0.080, -0.800, 0.180, -0.540, -1.040, -0.280, -0.620, -0.530, -0.120, -0.430, -0.290, -0.360, -0.350, -0.750, -1.130, -0.640, -0.790, 1.419, },
  {0.090, -0.170, -0.380, -0.100, -0.070, -0.320, -0.120, -0.340, -0.290, -0.210, -0.110, -0.310, -0.990, -0.130, -0.190, -0.310, -0.400, -0.380, -0.130, -0.100, 0.535, },
  {0.240, 0.210, -0.140, 0.130, 0.460, -0.640, 0.250, 0.520, 0.090, 0.450, 0.520, 0.030, -1.270, 0.400, 0.260, -0.030, 0.210, 0.450, 0.160, 0.480, 1.215, },
  {1.210, 1.240, 0.790, 0.970, 1.460, 0.460, 1.220, 1.790, 1.170, 1.800, 1.640, 0.990, -0.360, 1.420, 1.290, 0.940, 1.350, 1.670, 1.280, 1.530, 2.455, },
  {2.240, 2.050, 1.610, 1.940, 2.210, 0.370, 2.010, 2.850, 2.130, 2.850, 2.750, 1.480, 1.480, 2.410, 2.250, 1.780, 2.190, 2.700, 2.020, 1.970, 2.773, },
  {1.730, 1.560, 0.900, 1.780, 1.900, 0.660, 1.420, 2.770, 1.750, 2.640, 1.880, 0.630, 1.850, 1.840, 1.720, 1.210, 1.920, 2.680, 1.790, 1.720, 0.238, },
};


float lpephi2[12][21] = {
  {1.760, 1.250, 1.240, 1.410, 1.120, 0.600, 1.010, 1.760, 1.520, 1.930, 1.790, 0.900, 1.250, 1.620, 1.480, 1.370, 1.270, 1.590, 1.320, 1.030, 1.139, },
  {-1.330, -0.720, -0.880, -1.360, -0.930, -0.420, -0.850, -1.060, -1.140, -1.240, -1.180, -0.860, -0.530, -1.220, -1.170, -0.690, -0.670, -0.890, -1.040, -0.900, -0.523, },
  {0.040, 0.040, -0.260, -0.080, -0.120, -0.150, -0.230, 0.320, -0.010, -0.060, -0.010, -0.390, 0.290, -0.070, -0.020, -0.100, 0.020, 0.370, -0.120, -0.120, -0.289, },
  {0.190, -0.010, -0.220, 0.120, -0.040, -0.160, -0.150, 0.270, 0.040, 0.080, 0.110, -0.340, 0.580, 0.030, 0.100, -0.060, 0.010, 0.280, 0.040, -0.060, 1.356, },
  {0.070, -0.170, -0.220, 0.120, -0.070, -0.090, -0.140, 0.110, 0.030, 0.060, 0.030, -0.240, 0.630, 0.040, 0.050, -0.150, -0.060, 0.120, -0.030, -0.070, 0.694, },
  {-0.210, -0.430, -0.270, -0.040, -0.320, -0.070, -0.280, -0.240, -0.140, -0.140, -0.210, -0.240, 0.380, -0.140, -0.170, -0.370, -0.330, -0.300, -0.310, -0.310, -0.204, },
  {-0.480, -0.750, -0.380, -0.330, -0.710, -0.210, -0.550, -0.920, -0.440, -0.610, -0.610, -0.330, -0.250, -0.450, -0.500, -0.600, -0.720, -0.980, -0.680, -0.710, -0.807, },
  {-0.210, -0.410, -0.170, -0.150, -0.330, -0.210, -0.290, -0.430, -0.340, -0.270, -0.330, -0.080, -0.770, -0.270, -0.310, -0.440, -0.550, -0.520, -0.250, -0.310, -0.964, },
  {0.260, 0.170, 0.170, 0.260, 0.390, -0.140, 0.280, 0.370, 0.100, 0.350, 0.230, 0.280, -0.930, 0.200, 0.150, -0.040, -0.080, 0.270, 0.450, 0.380, -0.165, },
  {1.280, 1.200, 0.890, 1.140, 1.480, 0.090, 1.160, 1.370, 1.030, 1.400, 1.370, 1.030, 0.040, 1.150, 1.110, 1.120, 1.230, 1.200, 1.340, 1.370, 1.269, },
  {2.030, 2.180, 1.680, 1.700, 2.130, 0.520, 1.840, 1.770, 1.620, 2.040, 2.230, 1.870, 1.170, 1.810, 1.830, 1.920, 2.130, 1.750, 1.870, 2.010, 1.269, },
  {2.480, 2.740, 2.150, 2.030, 2.590, 1.200, 2.330, 2.150, 1.970, 2.430, 2.640, 2.580, 1.390, 2.260, 2.250, 2.410, 2.550, 2.130, 2.230, 2.350, 1.908, },
};


float lpetheta[10][21] = {
  {6.990, 6.570, 6.090, 8.180, 7.000, 6.650, 7.110, 8.020, 7.340, 7.110, 6.920, 6.660, 6.420, 6.530, 7.920, 8.050, 6.600, 7.140, 5.960, 7.550, 0.000, },
  {4.450, 6.570, 4.740, 4.440, 5.740, 4.820, 5.720, 5.240, 4.370, 4.950, 4.970, 4.420, 3.710, 4.530, 5.520, 4.830, 4.410, 4.910, 4.460, 4.780, 0.000, },
  {-0.710, -0.070, -0.430, -0.630, -0.010, 0.150, -0.170, -0.150, -0.530, -0.450, -0.480, -0.310, -0.390, -0.560, -0.530, -0.340, 0.000, -0.050, -0.270, 0.080, 0.000, },
  {-1.460, -1.080, -1.410, -1.520, -1.250, -1.410, -1.280, -1.140, -1.420, -1.430, -1.400, -1.430, -1.070, -1.470, -1.400, -1.190, -1.090, -1.010, -1.290, -1.210, 0.000, },
  {0.490, -0.160, -0.420, 0.160, -0.100, 0.060, -0.300, -0.160, 0.020, 0.070, 0.270, -0.460, -0.030, 0.140, 0.100, 0.280, -0.080, -0.130, 0.000, -0.120, 0.000, },
  {-0.060, -0.470, -0.300, -0.070, -0.320, 0.360, -0.310, -0.690, -0.170, -0.330, -0.140, -0.190, -1.080, -0.040, -0.170, -0.270, -0.340, -0.660, -0.330, -0.300, 0.000, },
  {0.170, -0.290, 0.240, 0.150, -0.230, -0.080, -0.090, -0.490, -0.040, -0.190, -0.160, 0.190, -0.380, -0.010, -0.030, -0.330, -0.480, -0.610, -0.180, -0.310, 0.000, },
  {0.400, -0.130, 0.840, 0.560, -0.150, -0.140, 0.090, 0.260, 0.320, 0.520, 0.110, 0.620, 2.060, 0.300, 0.170, -0.100, -0.360, -0.070, 0.080, -0.230, 0.000, },
  {0.900, 0.380, 1.470, 1.660, 0.540, 0.010, 0.790, 2.120, 1.560, 2.240, 1.130, 1.280, 4.440, 1.430, 1.270, 0.340, 0.760, 1.620, 0.680, 0.540, 0.000, },
  {3.880, 3.240, 4.600, 4.780, 3.590, 1.830, 3.810, 5.530, 4.700, 6.100, 4.150, 4.320, 6.420, 4.530, 4.520, 3.380, 4.380, 5.760, 3.770, 3.580, 0.000, },
};


float lpephi12[12][12][21] = {
{
  {-0.840, -0.540, -0.770, -1.290, -0.490, 0.560, -0.630, -1.400, -1.410, -1.720, -1.200, -0.160, -0.600, -1.090, -1.160, -0.690, -1.030, -1.330, -0.990, -0.660, -0.411, },
  {-0.280, 0.420, -0.240, -0.500, 0.510, 0.530, 0.070, -0.300, -0.840, -0.490, -0.240, 0.180, 0.520, -0.540, -0.410, -0.340, -0.400, -0.350, 0.250, 0.320, 3.649, },
  {-1.560, -0.620, -0.670, -1.350, -0.480, 0.090, -0.470, -0.850, -1.410, -1.390, -1.390, -0.250, -1.100, -1.240, -1.150, -0.910, -0.830, -0.940, -0.650, -0.180, 2.499, },
  {-1.260, 0.450, -0.410, -1.360, -0.270, 0.530, -0.150, -0.730, -1.220, -0.900, -1.020, -0.270, -1.180, -1.220, -1.140, -0.580, -0.650, -0.920, -0.830, -0.390, 10.000, },
  {-1.420, -0.050, -0.540, -1.390, -0.610, 0.250, -0.190, -1.330, -1.620, -1.390, -1.260, -0.460, -1.320, -1.430, -1.400, -0.830, -0.710, -0.850, -0.750, -0.570, 10.000, },
  {-1.180, -0.360, -1.050, -1.510, -0.140, -0.160, -0.810, -1.800, -1.650, -1.820, -1.440, -0.510, -0.760, -1.410, -1.370, -0.940, -1.050, -1.410, -0.910, -0.400, 4.023, },
  {-0.850, 0.480, -1.370, -0.840, 0.500, -0.160, -0.070, 0.040, -1.150, -0.590, -0.170, -0.130, -0.770, -1.170, -0.720, -0.740, -0.460, 0.290, 0.030, 0.450, 3.933, },
  {-1.290, 0.060, -1.090, -1.110, -0.080, 0.210, -0.290, -0.260, -1.170, -0.760, -0.940, 0.070, -0.910, -0.900, -0.800, -0.780, -0.480, -0.080, -0.310, 0.030, 10.000, },
  {-1.340, 0.380, -0.650, -1.180, -0.320, 1.070, -0.360, -0.540, -1.230, -0.890, -0.940, 0.080, -0.810, -1.150, -0.810, -0.720, -0.540, -0.640, -0.810, -0.400, 10.000, },
  {-2.300, -0.180, -1.400, -2.040, -1.130, -0.060, -0.920, -1.570, -2.170, -1.630, -1.560, -0.880, -1.540, -1.740, -1.850, -1.430, -1.190, -1.750, -0.530, -0.960, 10.000, },
  {-2.150, -1.570, -0.870, -1.800, -0.710, 0.470, -0.770, -1.660, -1.850, -1.580, -1.660, -0.370, -1.450, -1.700, -1.240, -1.570, -0.970, -1.710, -0.430, -0.740, 2.550, },
  {-0.660, 0.010, 0.410, -0.450, -0.480, -0.200, -0.280, -0.970, -0.460, -1.210, -0.500, 0.930, -1.320, -0.430, -0.240, -0.440, -0.170, -0.640, -0.710, -0.250, -0.168, },
},
{
  {1.220, 0.200, 0.640, 0.610, 0.360, 1.170, 0.480, 0.040, 0.660, 0.560, 0.700, 0.950, -0.500, 0.610, 0.720, 0.440, 0.570, 0.100, 0.540, 0.320, -1.906, },
  {-0.990, -1.450, -1.220, -0.920, -1.220, -1.520, -1.210, -1.260, -1.100, -1.000, -1.080, -1.100, -1.610, -1.030, -1.080, -1.450, -1.470, -1.410, -1.180, -1.240, 0.384, },
  {-0.310, -0.450, -0.370, -0.280, -0.320, -0.630, -0.360, -0.260, -0.450, -0.120, -0.200, -0.260, -1.140, -0.290, -0.450, -0.680, -0.450, -0.520, -0.300, -0.430, 4.176, },
  {0.390, 0.750, 0.590, 0.510, 0.140, 0.130, 0.310, 0.600, 0.310, 0.520, 0.430, 0.760, 0.590, 0.490, 0.180, 0.080, 0.020, 0.460, -0.040, 0.000, 2.531, },
  {1.190, 1.520, 1.140, 1.070, 0.690, 0.670, 0.830, 1.050, 0.670, 1.220, 1.520, 1.100, -1.060, 0.980, 0.960, 0.670, 0.820, 0.930, 0.980, 0.860, 2.500, },
  {1.610, 1.440, 0.870, 1.120, 1.440, 0.900, 0.910, 1.420, 0.860, 1.350, 1.610, 1.050, -0.980, 1.040, 1.080, 0.870, 0.610, 1.330, 1.150, 1.010, 2.011, },
  {1.400, 2.250, 0.800, 1.160, 1.900, 0.820, 1.340, 2.210, 0.830, 1.700, 1.770, 0.920, -0.600, 1.360, 1.210, 0.820, 0.960, 2.010, 1.540, 1.760, 2.209, },
  {0.780, 1.250, 0.870, 0.880, 1.030, 0.860, 0.890, 1.530, 0.870, 1.370, 1.510, 1.330, -0.340, 1.240, 0.990, 0.440, 0.990, 1.240, 1.020, 0.980, 3.753, },
  {0.170, 0.600, 0.200, 0.110, 0.040, 0.970, 0.310, 0.400, 0.130, 0.370, 0.550, 0.590, -0.240, 0.230, 0.220, 0.070, 0.240, 0.070, 0.270, 0.170, 2.260, },
  {0.340, 0.510, 0.150, 0.140, 0.270, 0.760, 0.110, 0.310, 0.300, 0.550, 0.470, 0.420, 0.350, 0.300, 0.410, -0.090, 0.140, 0.320, 0.680, 0.390, 1.519, },
  {1.040, 0.990, 1.150, 1.200, 1.040, 1.610, 0.810, 0.920, 1.210, 1.100, 0.620, 1.220, -0.060, 0.940, 0.920, 0.860, 0.970, 0.590, 1.080, 0.650, 10.000, },
  {1.510, 0.680, 1.580, 1.450, 0.850, 1.510, 1.250, 0.940, 1.430, 1.730, 1.620, 1.990, -0.030, 1.400, 1.490, 1.540, 0.980, 0.530, 1.060, 0.940, -0.966, },
},
{
  {0.490, -0.210, 0.470, -0.020, 0.010, 0.160, 0.180, -0.260, 0.090, -0.020, 0.160, 0.760, -0.800, 0.120, -0.020, 0.370, -0.080, -0.530, -0.220, 0.100, -3.661, },
  {0.470, 0.150, 0.510, 0.590, 0.430, 0.450, 0.510, 0.340, 0.510, 0.180, 0.230, 0.450, -0.220, 0.440, 0.410, 0.270, 0.370, 0.260, 0.260, 0.480, -1.107, },
  {-1.100, -0.810, -0.660, -0.920, -0.640, -0.600, -0.900, -0.950, -0.900, -0.890, -0.980, -0.460, -1.250, -0.850, -0.890, -0.960, -0.890, -0.840, -0.880, -0.580, 2.186, },
  {-0.170, 0.620, 0.520, 0.080, 0.490, 0.550, 0.690, 0.230, 0.290, 0.300, 0.330, 1.040, 0.470, 0.500, 0.210, 0.020, 0.430, 0.310, 0.100, 0.210, 0.541, },
  {0.270, 0.470, 0.880, 0.350, 0.760, 0.690, 0.420, 0.040, 0.480, 0.250, 0.020, 0.810, -1.230, 0.470, 0.450, 0.330, 0.320, 0.410, 0.090, 0.320, 0.105, },
  {0.530, 0.850, 0.550, 0.340, 0.640, 0.840, 0.680, 0.470, 0.300, 0.450, 0.660, 0.490, -1.570, 0.830, 0.450, 0.440, 0.180, 0.460, 0.120, 0.590, -0.464, },
  {0.460, 1.490, 0.710, 0.310, 1.250, 0.680, 1.030, 1.180, 0.330, 0.870, 0.850, 0.880, -1.260, 0.440, 0.540, 0.470, 0.530, 1.210, 0.590, 1.450, 2.704, },
  {-0.210, 0.390, 0.530, 0.010, 0.720, 0.270, 0.620, 0.320, 0.210, 0.410, 0.240, 0.810, -0.820, 0.290, 0.250, 0.120, 0.480, 0.330, 0.270, 0.670, 0.222, },
  {-0.150, 0.340, 0.280, -0.070, 0.330, 0.880, 0.340, -0.260, 0.170, 0.090, -0.010, 0.620, -0.100, 0.200, 0.220, 0.290, 0.330, -0.170, -0.010, 0.240, 1.369, },
  {0.190, 0.240, 0.380, 0.290, 0.330, 0.580, 0.240, -0.160, 0.170, 0.330, 0.140, 0.860, 0.560, 0.390, 0.010, 0.130, 0.260, -0.050, 0.080, 0.540, -0.471, },
  {0.140, -0.110, 0.660, 0.190, 0.450, 0.770, 0.110, -0.590, 0.170, 0.340, 0.830, 0.960, -0.290, 0.140, 0.320, 0.060, 0.720, 0.110, -0.290, 0.410, 10.000, },
  {0.260, -0.240, 0.090, -0.280, 0.360, 0.300, -0.070, -0.990, -0.110, -0.110, 0.090, 0.590, -0.220, 0.060, 0.120, 0.370, -0.230, -0.690, 0.030, 0.080, -2.784, },
},
{
  {0.320, 0.530, 0.130, 0.330, 0.050, -0.880, -0.120, -0.190, 0.230, -0.020, -0.250, -0.100, -0.030, 0.090, 0.330, 0.570, 0.120, -0.040, -0.170, -0.090, -3.675, },
  {1.180, 0.690, 0.570, 1.000, 0.630, 0.120, 0.540, 1.390, 0.800, 0.880, 1.030, 0.340, 0.800, 0.820, 0.870, 0.630, 0.550, 1.330, 0.690, 0.620, -1.416, },
  {0.170, 0.450, 0.180, 0.200, 0.310, 0.460, 0.320, 0.770, 0.200, 0.140, -0.010, 0.010, 1.040, -0.070, 0.090, 0.130, 0.130, 1.050, 0.290, 0.290, 10.000, },
  {1.150, 1.110, 1.360, 1.090, 1.150, 1.270, 1.260, 1.080, 1.080, 1.140, 1.150, 1.060, 0.870, 1.040, 1.080, 1.210, 0.920, 1.600, 0.880, 1.360, 10.000, },
  {1.280, 1.440, 1.360, 0.870, 1.060, 1.370, 1.160, 1.200, 1.060, 0.750, 1.420, 1.000, -0.050, 0.840, 1.220, 1.190, 0.870, 1.040, 1.100, 1.470, 10.000, },
  {0.880, 0.780, 1.050, 1.060, 1.040, 1.250, 1.200, 0.990, 0.950, 0.650, 0.830, 0.700, 0.240, 1.150, 1.000, 1.030, 0.390, 0.950, 0.950, 1.280, 10.000, },
  {1.210, 1.420, 1.140, 1.270, 2.020, 0.960, 1.450, 1.850, 1.040, 1.340, 1.160, 1.090, 0.420, 1.020, 1.130, 0.970, 1.070, 1.930, 1.520, 1.870, 10.000, },
  {1.100, 0.970, 0.880, 0.930, 1.560, -0.180, 0.940, 1.790, 0.820, 1.490, 0.970, 0.590, 0.500, 0.840, 0.860, 1.150, 1.370, 1.760, 1.700, 1.360, 1.424, },
  {1.170, 1.530, 1.070, 1.350, 1.390, -0.270, 1.360, 2.010, 1.390, 1.930, 0.930, 0.800, 1.220, 1.160, 1.250, 1.400, 1.290, 1.380, 1.720, 1.910, 10.000, },
  {1.320, 0.620, 1.070, 1.480, 1.310, 0.000, 0.980, 1.220, 1.390, 1.310, 1.130, 0.450, 1.230, 0.950, 1.150, 0.990, 1.010, 1.540, 0.390, 1.020, 10.000, },
  {1.500, 0.510, -0.320, -0.240, 0.290, -1.170, 0.290, 0.850, 0.210, 0.340, 0.310, -0.180, 0.880, -0.520, -0.190, -0.090, 0.350, 0.200, -0.250, 0.790, -0.810, },
  {-0.070, -0.260, -0.130, -0.130, 0.230, -0.110, -0.040, -0.080, -0.340, 0.120, 0.340, -0.160, -0.550, 0.000, -0.060, 0.180, -0.440, 0.820, 0.230, 0.100, 10.000, },
},
{
  {0.600, 0.520, 0.030, 0.360, 0.390, -1.020, 0.370, 0.880, 0.220, 0.520, 0.180, -0.370, 0.490, 0.060, 0.230, 0.830, 0.590, 1.090, 0.190, 0.310, -3.470, },
  {2.350, 1.730, 1.090, 1.970, 1.230, 0.450, 1.090, 2.630, 1.780, 2.060, 1.740, 0.670, 1.170, 1.790, 1.950, 1.480, 1.340, 2.180, 1.640, 1.260, -2.820, },
  {1.600, 0.990, 0.990, 1.440, 1.250, 1.020, 1.240, 1.110, 1.260, 0.940, 1.010, 0.790, 0.770, 0.890, 1.300, 1.370, 1.460, 1.330, 1.050, 0.830, -0.943, },
  {1.200, 0.960, 1.340, 1.250, 1.040, 1.350, 0.900, 0.990, 1.410, 1.270, 0.980, 0.970, -0.970, 1.400, 1.000, 1.810, 1.360, 1.180, 1.040, 1.010, -2.301, },
  {1.050, 1.270, 1.390, 1.400, 1.250, 1.610, 1.770, 1.060, 1.340, 0.980, 0.960, 1.200, 1.690, 1.410, 1.320, 1.460, 1.540, 1.060, 1.170, 1.200, 10.000, },
  {0.810, 0.850, 1.040, 1.010, 1.020, 1.260, 1.280, 0.680, 1.020, 0.480, 1.010, 0.570, 1.480, 1.220, 0.950, 1.220, 1.010, 1.020, 1.570, 1.300, 10.000, },
  {0.980, 1.240, 1.240, 0.820, 1.070, 0.840, 0.810, 1.000, 1.000, 1.030, 1.290, 0.820, 0.790, 1.020, 0.940, 1.190, 1.240, 0.960, 1.270, 1.250, 10.000, },
  {0.840, 0.730, 0.830, 0.530, 0.940, -0.680, 0.420, 1.300, 0.420, 1.050, 0.760, 0.060, 1.030, 0.490, 0.430, 1.070, 1.430, 1.300, 0.700, 1.150, 0.425, },
  {0.960, 0.480, 0.470, 0.990, 0.760, -1.430, 0.450, 1.600, 0.430, 0.950, 0.410, -0.180, 0.920, 0.380, 0.610, 1.130, 1.370, 1.430, 1.100, 0.940, 0.319, },
  {1.180, 0.650, 0.960, 1.330, 0.420, -0.760, 1.060, 0.970, 1.340, 1.670, 0.290, 0.050, 1.200, 0.870, 0.580, 1.380, 0.900, 0.890, 0.560, 0.440, 10.000, },
  {0.460, 0.250, 0.590, 0.360, 0.480, -0.360, 0.180, 2.400, 0.440, 0.630, -0.120, 0.080, 0.390, 0.220, 0.660, 1.050, 0.490, 1.150, 0.400, 1.050, -1.115, },
  {0.740, 0.920, 0.400, 0.090, 0.800, -0.140, 0.280, 0.870, 0.410, 0.000, 0.560, -0.160, 0.360, -0.050, 0.710, 0.930, 0.570, 0.700, 0.450, 0.540, -3.834, },
},
{
  {-0.230, 0.170, -0.340, -0.150, -0.030, 0.170, -0.060, 0.490, -0.030, 0.150, 0.110, -0.400, 0.360, -0.200, -0.040, 0.470, 1.110, 0.640, 0.040, 0.030, -3.383, },
  {3.060, 2.190, 1.630, 2.670, 1.660, 1.490, 1.500, 2.660, 2.610, 2.710, 2.500, 1.260, 0.620, 2.490, 2.560, 2.580, 2.670, 2.510, 2.230, 1.730, -2.961, },
  {1.510, 1.160, 0.900, 1.400, 0.570, 1.570, 1.010, 0.250, 1.440, 0.760, 1.170, 0.630, 0.100, 1.450, 1.390, 1.670, 1.190, 0.480, 0.780, 0.770, -1.572, },
  {0.700, 0.210, 0.200, 0.710, -0.130, 1.530, 0.480, -0.060, 0.930, 0.130, 0.540, 0.270, -0.320, 0.640, 0.580, 0.990, 0.770, -0.040, 0.490, 0.340, -0.509, },
  {0.610, 0.670, 0.120, 0.510, 0.280, 1.280, 0.780, 0.110, 0.600, 0.090, 0.390, 0.240, 0.840, 1.050, 0.560, 0.890, 1.050, 0.190, -0.090, 0.200, 10.000, },
  {0.180, 0.110, 0.150, 0.120, 0.340, 0.580, 0.280, 0.230, 0.410, 0.160, 0.230, 0.040, 0.910, 0.270, 0.350, 0.400, 0.780, 0.360, 0.090, 0.140, 0.358, },
  {-0.180, -0.110, -0.120, -0.220, -0.250, 0.190, -0.120, -0.270, 0.090, -0.330, -0.230, -0.320, 0.110, -0.070, -0.090, 0.060, 0.210, -0.180, -0.240, -0.170, 1.654, },
  {0.040, -0.160, -0.200, -0.300, -0.290, -0.270, -0.140, -0.390, -0.230, -0.360, -0.150, -0.350, -0.250, -0.240, -0.210, 0.500, 0.370, -0.390, -0.160, -0.310, -0.134, },
  {0.400, -0.020, 0.210, 0.090, -0.060, -0.420, 0.300, -0.210, 0.150, -0.150, 0.100, -0.160, -0.060, -0.020, 0.180, 0.710, 0.660, -0.290, -0.040, 0.040, -2.124, },
  {0.660, 0.810, 0.530, 0.460, 0.130, 0.110, 0.420, 0.260, 0.510, 0.000, 0.000, 0.230, -0.100, 0.130, 0.640, 0.630, 0.930, 0.230, -0.090, 0.140, 10.000, },
  {0.430, 0.110, 0.420, 0.620, 0.500, 1.020, 0.650, 0.110, 0.550, 0.000, 0.120, 0.160, -0.270, 0.300, 0.410, 0.720, 0.980, 0.130, 0.350, 0.520, -0.422, },
  {0.210, 0.590, 0.310, 0.190, 0.230, 0.180, 0.060, 0.060, 0.390, -0.030, -0.340, 0.110, -0.230, 0.870, -0.030, 0.810, 0.600, 0.110, -0.250, 0.110, -2.670, },
},
{
  {-0.560, 0.250, -0.420, -0.360, 0.100, 1.050, 0.050, 0.010, -0.380, -0.210, -0.350, -0.180, 0.090, -0.410, -0.310, -0.210, 0.500, -0.040, -0.100, 0.190, -4.233, },
  {3.050, 2.000, 1.870, 2.770, 1.830, 2.240, 1.760, 2.440, 2.670, 2.650, 3.010, 1.470, 0.860, 2.770, 2.690, 2.040, 2.140, 2.550, 2.290, 1.720, -3.365, },
  {1.320, 0.550, 0.160, 1.150, 0.460, 1.410, 0.740, 0.300, 1.260, 0.720, 0.940, 0.120, 0.400, 1.030, 1.100, 0.920, 0.700, 0.520, 0.480, 0.480, -1.806, },
  {-0.060, -0.300, -0.720, -0.020, -0.140, 0.780, 0.030, -0.030, 0.240, -0.040, 0.210, -0.710, -0.690, 0.090, 0.230, 0.050, 0.160, 0.010, -0.270, -0.050, -2.353, },
  {-0.070, -0.010, -0.350, -0.030, 0.060, 0.180, 0.170, 0.220, 0.270, -0.070, 0.010, -0.290, 0.180, -0.270, 0.090, 0.020, 0.070, 0.280, -0.240, 0.020, -1.942, },
  {-0.500, -0.070, -0.400, -0.330, -0.080, -0.400, -0.050, -0.010, 0.070, -0.180, -0.320, -0.400, 1.090, -0.340, -0.170, -0.350, 0.090, 0.140, -0.180, -0.160, 0.459, },
  {-1.010, -0.860, -0.930, -0.990, -0.880, -0.840, -0.910, -0.810, -0.720, -1.040, -0.970, -1.050, 0.040, -0.850, -0.840, -0.750, -0.700, -0.720, -0.880, -0.910, -0.190, },
  {-0.580, -0.560, -0.720, -0.740, -0.710, 0.150, -0.660, -0.670, -0.590, -0.850, -0.680, -0.840, -0.060, -0.710, -0.660, -0.270, -0.530, -0.610, -0.730, -0.730, -1.613, },
  {0.020, -0.170, -0.280, -0.040, -0.180, 1.010, -0.180, -0.190, -0.020, -0.280, -0.080, -0.430, -0.090, -0.050, -0.240, 0.130, 0.010, 0.030, -0.500, -0.320, -0.496, },
  {0.250, 0.060, -0.220, 0.380, 0.010, 1.250, 0.310, 0.090, 0.210, -0.210, -0.060, -0.170, -0.100, 0.120, 0.000, 0.110, -0.050, 0.160, -0.230, 0.020, -1.013, },
  {-0.010, -0.080, -0.150, 0.370, -0.110, 1.560, 0.290, 0.130, -0.120, -0.390, -0.510, -0.080, -0.270, -0.040, 0.050, 0.440, -0.210, -0.190, -0.380, -0.060, 10.000, },
  {-0.130, -0.070, -0.140, -0.190, 0.060, 0.610, -0.080, -0.050, -0.080, -0.290, -0.180, 0.100, 0.150, -0.140, -0.270, 0.010, 0.360, -0.110, -0.480, -0.050, -3.598, },
},
{
  {-0.570, -0.480, 0.220, -0.220, -0.300, 1.170, -0.260, 0.050, -0.020, -0.420, -0.050, 0.020, -0.030, 0.020, -0.050, -0.280, -0.780, 0.050, -0.350, -0.260, -4.007, },
  {1.880, 1.520, 1.360, 2.000, 1.210, 1.590, 1.130, 2.150, 1.810, 1.450, 1.780, 1.160, 1.160, 2.000, 1.870, 1.190, 1.100, 2.040, 1.800, 1.230, -2.757, },
  {0.730, -0.090, 0.330, 0.710, 0.020, 0.660, 0.230, 0.100, 0.600, 0.210, 0.310, 0.200, 0.940, 0.480, 0.620, 0.370, 0.030, 0.090, 0.230, 0.130, -0.969, },
  {-0.540, -0.580, -0.800, -0.650, -0.350, 0.050, -0.960, -0.520, -0.620, -0.630, -0.530, -0.760, -0.340, -0.690, -0.620, -0.610, -0.490, -0.490, -0.190, -0.590, -0.910, },
  {-0.850, -0.770, -1.030, -0.860, -0.750, -0.440, -1.000, -0.810, -0.670, -0.820, -0.640, -0.960, 1.710, -0.660, -0.700, -0.670, -0.590, -0.750, -0.730, -0.750, 10.000, },
  {-0.790, -0.550, -0.480, -0.450, -0.880, -0.590, -0.620, -0.530, -0.470, -0.500, -0.660, -0.580, 1.180, -0.490, -0.500, -0.450, -0.230, -0.540, -0.550, -0.730, 2.036, },
  {-0.490, -0.390, -0.010, -0.530, -0.590, -0.090, -0.550, -0.410, -0.450, -0.380, -0.490, -0.290, 0.410, -0.580, -0.440, -0.260, -0.150, -0.400, -0.530, -0.620, 1.253, },
  {-0.250, -0.350, -0.010, -0.360, -0.390, 0.620, -0.420, -0.420, -0.290, -0.460, -0.440, -0.120, 0.240, -0.400, -0.350, -0.160, -0.070, -0.250, -0.440, -0.390, 0.399, },
  {-0.350, -0.440, -0.540, -0.270, -0.400, 1.150, -0.640, -0.460, -0.220, -0.490, -0.460, -0.390, -0.080, -0.350, -0.300, -0.330, -0.270, -0.270, -0.380, -0.470, 10.000, },
  {-0.350, -0.890, -0.550, -0.170, -0.440, 0.730, -0.500, -0.500, -0.240, -0.510, -0.270, -0.530, -0.240, -0.380, -0.240, -0.170, -0.170, -0.320, -0.450, -0.450, -0.130, },
  {-0.260, 0.090, -0.130, -0.430, -0.290, 0.920, -0.090, -0.680, -0.130, -0.180, 0.750, -0.040, 0.300, -0.010, -0.290, -0.360, -0.280, -0.070, -0.530, -0.550, -0.130, },
  {-0.810, -0.360, 0.250, -0.350, -0.700, 0.320, 0.110, -0.480, -0.240, -0.450, -0.280, 0.740, 0.020, -0.270, -0.320, -0.290, -0.090, -0.220, -0.420, -0.270, -2.474, },
},
{
  {-0.430, -0.370, -0.180, -0.270, -0.550, 0.870, -0.270, -0.560, -0.280, -0.250, -0.460, -0.250, 0.470, -0.100, -0.210, -0.750, -0.390, -0.370, 0.220, -0.480, -4.277, },
  {1.000, 0.810, 0.370, 0.950, 0.670, 1.190, 0.230, 1.260, 1.030, 0.790, 1.140, 0.080, 2.180, 0.820, 0.940, 0.810, 0.840, 1.190, 1.160, 0.310, -2.368, },
  {0.230, -0.200, 0.000, 0.250, -0.240, 0.300, -0.090, -0.040, 0.230, -0.190, 0.030, -0.110, 1.860, 0.150, 0.280, 0.180, -0.130, -0.120, 0.140, -0.330, -0.956, },
  {-0.910, -0.840, -0.500, -0.930, -0.740, -0.600, -0.800, -1.010, -0.960, -1.130, -1.090, -0.830, 0.300, -1.160, -0.650, -0.700, -0.710, -0.790, -0.540, -0.400, -0.897, },
  {-1.210, -1.150, -0.720, -1.200, -1.200, -0.930, -1.080, -1.020, -1.050, -1.120, -1.160, -0.910, 0.860, -1.110, -1.130, -0.860, -0.790, -0.940, -0.950, -0.990, 10.000, },
  {-0.880, -0.880, -0.350, -0.800, -1.150, -0.480, -0.900, -0.800, -0.690, -0.810, -0.960, -0.350, 1.260, -0.910, -0.880, -0.560, -0.730, -0.820, -1.050, -0.950, 10.000, },
  {-0.120, -0.210, 0.230, -0.160, -0.320, 0.160, -0.080, 0.050, -0.210, 0.050, -0.350, -0.050, 0.820, -0.150, -0.310, -0.040, -0.390, 0.030, -0.070, -0.210, 1.266, },
  {-0.460, -0.310, -0.140, -0.230, -0.400, 0.280, -0.290, -0.140, -0.260, -0.410, -0.590, -0.210, 0.400, -0.440, -0.320, -0.880, -0.940, -0.070, -0.230, -0.250, 2.117, },
  {-0.690, -0.770, -0.530, -0.530, -0.380, 0.620, -0.700, -0.550, -0.580, -0.670, -0.750, -0.400, -0.010, -0.500, -0.670, -1.030, -1.100, -0.350, -0.010, -0.470, 1.317, },
  {-0.830, -0.620, -0.490, -0.790, -0.580, -0.030, -0.940, -0.670, -0.660, -0.900, -1.040, -0.420, -0.070, -0.790, -0.760, -0.770, -0.840, -0.680, -0.770, -0.850, 10.000, },
  {-0.630, -0.770, 0.020, -0.550, -1.050, 0.300, -0.720, -0.910, -0.260, -0.830, -1.200, -0.030, 0.270, -0.040, -0.700, -0.510, -0.670, -0.520, 0.150, -1.020, 10.000, },
  {-0.550, -0.580, 0.120, 0.110, -0.670, 0.140, -0.460, -0.270, -0.200, -0.290, -0.740, 0.270, 0.370, -0.330, -0.220, -0.860, -0.580, -0.460, -0.030, -0.350, -1.854, },
},
{
  {-1.020, -0.550, -0.370, -0.840, -0.570, 0.220, -0.730, -0.110, -0.410, -0.310, -0.680, -0.370, 1.080, -0.790, -1.010, -0.580, -0.140, -0.350, -0.380, -0.760, -4.317, },
  {1.880, 1.230, 1.600, 1.820, 0.900, 0.800, 0.770, 1.660, 1.600, 1.960, 1.470, 0.860, 2.860, 1.660, 1.410, 1.160, 1.210, 1.360, 1.160, 1.020, -1.962, },
  {0.450, -0.260, 0.450, 0.530, -0.210, -0.420, 0.050, 0.220, 0.340, -0.070, -0.180, 0.420, 1.870, -0.010, 0.210, 0.470, 0.140, 0.130, 0.140, -0.220, 10.000, },
  {-0.720, -0.590, -0.170, -0.590, -0.630, -1.030, -0.450, -0.100, -0.640, -0.670, -1.240, -0.680, 0.720, -0.510, -0.490, -0.630, -0.660, -0.200, -0.660, -0.790, 10.000, },
  {-0.950, -1.130, -0.770, -0.510, -0.730, -0.900, -0.970, -0.340, -0.420, -0.550, -1.480, -1.200, 0.680, -0.820, -0.920, -0.890, -1.290, -0.780, 0.050, -0.800, 10.000, },
  {-0.610, -1.040, -1.090, -0.730, -0.660, -0.530, -1.060, -0.200, -0.450, -0.680, -0.940, -1.160, 1.030, -0.600, -0.820, -0.690, -1.030, -0.610, -0.620, -0.670, 0.117, },
  {0.240, -0.130, -0.480, 0.040, 0.170, -0.170, -0.010, 0.560, -0.020, -0.040, 0.430, -0.370, 0.910, -0.100, -0.050, -0.140, -0.240, 0.640, 0.260, 0.290, 10.000, },
  {-0.610, -0.480, -0.870, -0.060, 0.070, -0.130, 0.080, 0.960, -0.020, -0.130, 0.170, -0.860, 0.320, -0.290, -0.130, -0.300, -0.230, 0.690, 0.320, 0.060, 10.000, },
  {-0.560, -0.480, -0.270, -0.190, -0.280, 0.280, -0.250, 0.640, -0.320, -0.360, -0.850, -0.530, 0.310, -0.480, -0.210, -0.490, -0.090, 0.190, 0.420, -0.180, 10.000, },
  {-0.790, -0.600, -0.130, -0.100, -0.740, -0.270, -0.640, -0.440, -0.320, -0.700, -0.130, -0.580, 0.220, -0.550, -0.030, -0.300, -0.260, -0.520, -0.400, -0.500, 10.000, },
  {-1.160, -1.270, -0.760, -0.830, -1.230, 0.160, -0.920, -0.660, -0.780, -1.050, 0.150, -1.120, 0.290, -0.900, -0.580, -0.840, -0.580, -0.400, -0.040, -0.650, -1.356, },
  {-0.970, -0.630, -1.180, -0.970, -1.390, -0.300, -1.070, 0.120, -0.710, -1.090, -1.750, -1.160, 0.550, -1.240, -0.710, -1.380, -1.360, -0.870, -1.200, -1.200, -1.995, },
},
{
  {-0.640, -0.620, -0.570, 0.720, 0.020, -0.110, 0.010, 0.640, -0.190, -0.050, 0.060, -0.670, 0.440, -0.250, -0.340, -0.680, -0.170, 0.320, 0.590, 0.720, -4.184, },
  {2.240, 1.410, 2.300, 2.710, 1.410, 0.320, 1.220, 2.330, 2.080, 2.280, 2.600, 1.260, 3.030, 2.460, 1.870, 1.740, 1.430, 3.060, 2.180, 1.830, -2.281, },
  {0.500, -0.200, 0.710, 1.140, 0.100, -0.800, 0.400, 1.420, 1.080, 0.830, -0.170, 0.170, 1.840, 0.580, 1.050, 0.560, 0.720, 0.740, 0.990, 0.700, 10.000, },
  {0.170, -0.070, 0.460, 0.400, 0.410, -1.110, 0.310, 0.590, 0.480, 0.460, -0.180, -0.120, 0.280, 0.730, -0.110, 0.460, -0.080, 0.440, 0.750, -0.010, 10.000, },
  {-0.150, -0.870, -0.450, -0.010, -0.340, -0.560, 0.490, 0.290, 0.580, 0.200, 0.150, -0.190, 0.460, -0.200, 0.430, -0.190, -0.340, 0.300, -0.150, -0.180, 10.000, },
  {-0.600, -0.680, -0.650, -0.620, -0.430, -0.160, -0.380, -0.690, -0.380, -0.820, -0.190, -0.750, 1.100, -0.910, -0.280, -0.470, -0.510, -0.650, -0.240, 0.020, 10.000, },
  {-0.180, -0.330, -0.310, 0.000, 0.030, -0.440, -0.350, 0.290, 0.220, -0.010, 0.260, -0.420, 1.630, -0.360, -0.280, -0.160, 0.070, 0.340, 0.470, 0.090, 10.000, },
  {0.080, 0.810, 0.240, 0.170, 0.200, -0.140, -0.300, 0.700, 0.370, 0.370, -0.420, -0.210, 1.490, -0.080, 0.520, 0.060, 0.420, 0.950, -0.130, 0.270, -0.134, },
  {0.740, -0.550, 0.740, 0.740, -0.130, 0.150, 0.290, 0.980, 0.610, 0.710, 0.120, -0.300, 1.710, 0.360, 0.220, 0.360, 0.590, 1.180, 0.580, 0.210, 10.000, },
  {0.290, 0.500, 0.270, 0.440, -0.170, -0.690, -0.550, 0.410, 0.500, -0.200, -0.300, -0.330, 2.030, 1.040, 0.060, 0.580, 0.750, 2.160, -0.530, -0.250, -1.675, },
  {-1.440, -1.400, -1.630, -0.960, -1.260, -0.520, -1.880, 0.040, -1.510, -0.990, -2.320, -2.150, 1.390, -1.450, -1.220, -1.210, -1.190, -0.660, -1.270, -1.380, -1.675, },
  {-2.010, -1.610, -2.450, -2.250, -1.200, -0.930, -2.060, -0.280, -2.170, -1.840, -2.040, -2.910, -0.180, -2.420, -2.350, -1.570, -0.920, -0.460, -1.050, -2.130, -4.260, },
},
{
  {-0.390, -0.770, 0.090, -0.480, -0.350, -0.890, -0.580, 0.090, -0.540, -0.250, -1.600, -0.570, -0.270, -0.340, -0.760, -0.470, -0.020, -0.060, -0.680, 0.100, -0.955, },
  {1.440, 1.360, 0.940, 1.130, 0.850, -0.150, 0.560, 0.980, 1.300, 1.210, 0.640, 0.700, 1.830, 1.320, 1.070, 0.700, 0.600, 1.240, 1.130, 1.090, 2.653, },
  {-0.280, -0.580, 0.170, 0.180, -0.280, -0.790, -0.730, -0.180, 0.230, -0.110, -0.300, -0.320, 0.930, -0.140, 0.160, 0.120, -0.580, -0.450, -0.350, -0.260, 10.000, },
  {-0.590, -1.320, -0.410, -1.090, -1.150, -0.780, -0.970, -0.290, -0.460, -0.590, -1.180, -1.080, -1.730, -0.920, -0.920, -0.910, -0.840, -0.240, -0.710, -0.980, 10.000, },
  {-0.650, -0.330, -0.260, -0.830, -1.150, 0.040, -1.450, -0.400, -0.930, -0.610, -1.360, -0.900, -0.160, -1.050, -0.620, -0.750, -0.590, -0.340, -0.510, -1.590, 10.000, },
  {-1.420, -1.470, -1.610, -1.890, -1.660, -1.000, -1.910, -1.840, -1.950, -2.210, -1.650, -1.800, 0.230, -2.010, -1.740, -1.440, -1.380, -1.820, -1.560, -1.780, 10.000, },
  {-1.160, -1.000, -1.230, -1.040, -0.730, -1.300, -0.810, -0.870, -1.100, -1.160, -0.800, -1.100, 0.270, -1.090, -1.130, -1.130, -1.050, -0.740, -0.960, -0.850, 2.244, },
  {-1.110, -0.950, -1.260, -0.640, -1.100, -0.880, -0.750, -0.120, -0.760, -0.320, -1.040, -0.810, 0.060, -0.880, -0.710, -1.120, -0.780, -0.160, -0.660, -0.940, 10.000, },
  {-0.890, -0.820, -0.530, -0.700, -0.910, -0.100, -0.830, -0.200, -0.540, -0.140, -0.290, -1.010, 0.330, -0.910, -0.520, -0.460, -0.430, -0.430, -0.470, -0.570, 10.000, },
  {-1.140, -2.000, -1.220, -1.130, -1.320, -1.310, -1.180, -0.660, -1.100, -1.040, -1.120, -1.510, 0.020, -1.350, -1.280, -0.670, -1.350, -0.990, -1.110, -1.620, 10.000, },
  {-2.430, -1.550, -2.270, -2.120, -2.340, -1.740, -2.520, -1.030, -1.900, -2.010, -2.220, -2.100, -1.020, -2.180, -2.290, -1.690, -2.250, -1.040, -2.330, -1.910, 10.000, },
  {-1.050, -2.170, -0.230, -0.500, -1.250, -1.530, -0.390, -1.170, -0.550, -0.840, -0.250, -0.820, -0.660, -0.740, -0.660, -0.790, -1.720, 0.080, -0.020, -0.970, -1.975, },
},
};

float lpethph1[12][10][21] = {
{
  {-3.120, -3.040, -1.180, -3.500, -2.960, -1.320, -2.780, -3.810, -2.830, -2.550, -3.750, -1.580, -2.550, -2.480, -3.470, -3.220, -1.690, -2.490, -2.620, -2.850, 10.000, },
  {-0.580, -3.040, 0.170, -0.860, -1.710, 0.510, -1.390, -1.030, -1.250, -0.380, -1.800, -0.040, -1.920, -0.490, -1.070, -0.700, -1.100, -0.950, -1.120, -0.080, 0.028, },
  {1.520, 1.410, 0.780, 1.230, 1.210, 0.570, 1.010, 1.970, 1.210, 1.300, 1.090, 0.570, -0.380, 1.230, 1.610, 1.300, 1.770, 2.060, 0.970, 1.100, 0.330, },
  {1.030, 0.450, 0.350, 0.870, 0.730, -0.380, 0.670, 1.020, 0.960, 0.790, 0.590, 0.160, -0.500, 0.810, 0.890, 0.840, 0.580, 1.070, 0.640, 0.800, -0.195, },
  {-0.990, -1.080, -0.540, -1.060, -1.260, 0.330, -0.850, -1.030, -1.080, -1.250, -1.050, -0.470, -0.600, -1.110, -1.030, -0.900, -1.210, -0.970, -1.140, -1.270, -0.052, },
  {0.040, -0.040, -0.140, -0.050, 0.060, 0.430, -0.150, 0.100, 0.000, 0.220, 0.210, -0.150, 1.240, -0.160, -0.110, 0.370, 0.120, 0.110, -0.270, -0.040, -0.047, },
  {0.390, 1.040, 0.140, -0.120, 0.650, 0.390, 0.440, 0.200, 0.160, 0.140, 0.440, 0.620, 2.160, 0.160, 0.260, 0.470, 0.970, 0.300, 0.340, 0.810, 1.334, },
  {-1.160, 0.200, -0.560, -1.200, -0.160, 0.150, -0.460, -0.850, -1.020, -1.120, -0.730, -0.080, 1.110, -1.000, -0.960, -0.570, -0.160, -0.720, -0.370, -0.090, 0.507, },
  {-1.780, -0.560, -1.200, -1.700, -0.230, 0.570, -0.520, -1.440, -1.490, -1.460, -1.520, -0.820, -0.570, -1.320, -1.410, -1.290, -0.690, -1.180, 0.020, -0.290, 10.000, },
  {-2.360, -1.500, -0.790, -1.890, -0.810, 0.820, -0.870, -2.020, -0.890, -1.540, -2.590, -1.550, -2.550, -1.180, -1.160, -0.950, -0.560, -1.110, -1.120, 0.430, -0.117, },
},
{
  {0.630, -1.200, 0.840, -0.760, -0.330, 0.000, -1.040, -1.020, -0.200, 0.600, -0.810, -0.670, -1.630, 0.320, -0.860, -1.260, 0.140, -0.070, -0.340, -1.050, -0.561, },
  {1.100, -1.200, 0.000, 1.880, 0.230, -0.120, 0.350, 0.140, 0.980, 0.820, 1.130, 0.650, -1.450, 0.520, 0.440, 1.960, 0.250, -0.140, 0.060, 0.630, -0.059, },
  {-0.330, -0.660, -0.340, -0.240, -0.510, -0.500, -0.350, -0.680, -0.340, -0.440, -0.420, -0.270, -1.010, -0.330, -0.400, -0.420, -0.650, -0.780, -0.480, -0.540, -0.258, },
  {-0.440, -0.810, -0.500, -0.420, -0.690, -0.460, -0.600, -0.770, -0.480, -0.500, -0.520, -0.470, -0.590, -0.460, -0.500, -0.710, -0.790, -0.870, -0.640, -0.710, 0.234, },
  {0.920, 0.600, 0.950, 0.670, 0.470, 0.440, 0.350, 0.920, 0.610, 0.780, 0.720, 0.470, 1.030, 0.790, 0.670, 0.350, 0.340, 0.740, 0.740, 0.400, -0.063, },
  {3.430, 2.350, 1.910, 2.860, 2.310, 1.570, 2.010, 2.730, 2.650, 3.190, 3.060, 1.740, 3.130, 2.890, 2.700, 2.510, 2.490, 2.570, 2.620, 2.320, 0.714, },
  {3.190, 2.570, 1.900, 2.490, 2.210, 1.240, 2.090, 2.430, 2.700, 2.760, 2.970, 1.910, 4.060, 2.770, 2.590, 2.490, 2.390, 2.400, 2.620, 2.220, -0.208, },
  {2.460, 1.770, 1.450, 1.820, 1.410, 0.580, 1.150, 1.970, 1.810, 2.060, 2.260, 1.390, 2.030, 2.010, 1.940, 1.410, 1.410, 1.710, 1.830, 1.330, 10.000, },
  {2.570, 1.960, 2.030, 2.020, 1.690, 1.050, 1.220, 1.540, 1.710, 2.340, 2.410, 1.550, -0.060, 1.860, 1.890, 1.480, 1.290, 1.820, 2.000, 1.500, 10.000, },
  {1.960, 1.440, 0.950, 1.950, 1.980, 1.770, 1.560, 0.360, 1.750, 1.610, 1.960, 2.360, -0.940, 1.210, 1.440, 1.110, 1.260, 1.320, 1.160, 1.310, 0.643, },
},
{
  {-1.150, -2.620, -0.380, -2.450, -2.020, -1.080, -2.490, -3.030, -1.820, -2.050, -2.600, -1.390, -2.530, -2.490, -2.550, -2.250, -2.360, -1.990, -2.520, -2.720, 10.000, },
  {-1.170, -2.620, -1.230, -1.010, -2.150, -1.450, -1.800, -1.870, -1.340, -1.670, -2.270, -1.350, -0.520, -1.350, -1.540, -1.230, -0.450, -2.150, -1.700, -1.890, -0.103, },
  {-0.830, -1.050, -0.840, -0.830, -0.940, -0.910, -1.010, -0.840, -0.870, -0.760, -0.750, -0.830, -1.200, -0.830, -0.890, -1.100, -1.090, -0.900, -0.970, -1.020, 0.287, },
  {0.170, 0.070, 0.080, 0.170, 0.070, 0.320, 0.020, 0.210, 0.160, 0.140, 0.080, 0.150, -0.180, 0.220, 0.150, 0.000, 0.010, 0.070, 0.160, 0.040, -0.103, },
  {0.520, 0.320, 0.460, 0.730, 0.400, 0.530, 0.530, 0.070, 0.430, 0.430, 0.120, 0.290, 0.390, 0.340, 0.360, 0.580, 0.390, 0.130, 0.380, 0.290, -0.098, },
  {1.070, 0.890, 0.530, 0.980, 0.730, 0.810, 0.820, 0.250, 1.020, 0.920, 0.990, 0.400, 1.670, 1.010, 1.070, 1.150, 0.780, 0.400, 0.710, 0.860, 1.122, },
  {0.590, 0.110, 0.590, 0.520, 0.050, 0.420, 0.410, 0.260, 0.560, 0.160, 0.530, 0.300, 1.550, 0.510, 0.600, 0.820, 0.440, 0.250, 0.290, 0.230, -0.876, },
  {0.850, 0.130, 0.600, 0.340, -0.040, -0.210, 0.160, 0.100, 0.340, -0.170, 0.200, 0.090, 0.210, 0.200, 0.480, 0.440, 0.170, 0.140, 0.110, -0.060, -0.317, },
  {0.850, 0.480, 0.510, 0.700, 0.590, -0.530, 0.570, -0.080, 0.240, 0.570, 0.350, 0.990, -0.550, 0.120, 0.220, 0.840, 0.130, 0.400, 0.630, 0.610, 10.000, },
  {1.960, 0.020, 0.420, -0.660, 0.690, -0.050, 0.110, -0.550, -0.570, -1.040, -0.520, -0.150, -2.530, 0.600, -0.250, 1.730, -0.140, -0.600, 0.380, 0.560, 10.000, },
},
{
  {-2.480, -2.900, -2.230, -3.410, -2.660, -1.510, -3.170, -3.270, -2.350, -1.800, -3.080, -2.090, -4.780, -2.020, -3.180, -2.850, -2.350, -2.130, -2.470, -3.300, 10.000, },
  {-1.320, -2.900, -0.880, -1.620, -1.410, -0.380, -1.790, -1.890, -1.170, -1.830, -1.140, -0.950, -2.070, -0.720, -1.480, -1.240, -1.410, -0.590, -0.960, -1.220, -0.442, },
  {1.180, 1.180, 1.080, 1.040, 0.820, 1.020, 0.850, 1.090, 1.180, 1.220, 1.270, 1.190, 0.230, 1.540, 1.170, 0.750, 0.990, 1.100, 0.820, 0.630, 1.047, },
  {0.400, 0.830, 0.610, 0.560, 0.380, 0.990, 0.660, 0.690, 0.550, 0.520, 0.440, 0.720, -0.240, 0.610, 0.370, 0.350, 0.340, 0.530, 0.120, 0.320, -0.355, },
  {-0.460, -0.150, -0.500, -0.270, -0.220, 0.570, -0.130, -0.590, -0.090, -0.210, -0.210, -0.350, -0.540, -0.140, -0.300, -0.030, -0.170, -0.360, -0.360, -0.250, 0.604, },
  {-0.700, -0.510, -0.630, -0.610, -0.550, 0.070, -0.630, -0.510, -0.400, -0.690, -0.730, -0.600, 0.150, -0.710, -0.480, -0.470, -0.470, -0.500, -0.440, -0.320, -0.316, },
  {-0.850, -0.690, -0.490, -0.880, -0.470, -0.450, -0.570, -0.090, -0.800, -0.580, -0.680, -0.580, 0.060, -0.910, -0.600, -0.570, -0.160, -0.100, -0.470, -0.440, 10.000, },
  {-0.220, 0.090, -0.270, -0.740, 0.160, -0.510, -0.230, 0.090, -0.830, -0.380, -0.040, -0.670, -0.430, -0.600, -0.400, 0.110, -0.070, 0.140, 0.590, 0.000, -1.754, },
  {-0.110, 0.080, -0.290, -0.560, 0.270, -1.050, 0.060, 0.060, -0.150, 0.780, -0.130, -0.720, -2.800, -0.210, -0.350, 0.150, -0.050, -0.190, 0.740, 0.460, -3.700, },
  {-0.750, -0.260, -1.030, -0.700, 0.040, -1.200, -0.970, -0.790, 0.290, -0.790, -0.310, -1.140, -4.780, -0.720, -1.170, -0.570, -0.530, -1.440, -0.270, -0.710, 10.000, },
},
{
  {-1.850, -2.890, -2.630, -3.530, -2.540, -1.640, -3.210, -3.380, -3.350, -2.750, -3.260, -2.230, -3.910, -2.250, -3.270, -2.950, -1.690, -2.350, -2.450, -3.250, 10.000, },
  {-1.380, -2.890, -1.000, -0.490, -1.980, -0.920, -1.830, -1.300, -0.780, -0.580, -1.320, -0.690, -1.200, -0.950, -1.570, -0.830, -0.590, -0.110, -0.940, -1.170, 10.000, },
  {1.600, 2.660, 1.610, 1.280, 0.880, 1.220, 1.070, 0.900, 1.270, 1.240, 1.250, 1.370, -0.330, 1.540, 1.490, 1.180, 1.130, 1.240, 1.220, 0.670, 0.336, },
  {1.110, 1.000, 1.130, 1.080, 0.910, 1.490, 0.880, 0.940, 0.830, 0.840, 1.140, 1.170, -0.530, 0.910, 0.980, 0.890, 0.910, 0.860, 0.840, 0.940, -0.565, },
  {-0.550, -0.150, -0.470, -0.470, -0.080, 0.830, 0.010, -0.450, -0.270, -0.390, -0.420, -0.310, -0.300, -0.210, -0.420, -0.040, -0.150, -0.370, -0.330, -0.310, 10.000, },
  {-1.070, -0.270, -0.830, -1.010, -0.610, -0.380, -0.510, -0.550, -0.730, -0.710, -0.930, -0.750, 1.640, -0.960, -0.900, -0.680, -0.460, -0.500, -0.590, -0.500, 10.000, },
  {-0.710, -0.320, -0.430, -0.930, -0.210, -0.470, -0.450, -0.130, -0.720, -0.580, -0.320, -0.700, 0.480, -0.760, -0.610, -0.380, -0.060, -0.040, -0.430, -0.230, 10.000, },
  {-0.420, -0.380, -0.580, -0.510, 0.160, -0.160, -0.220, -0.120, -0.510, -0.500, -0.320, -0.570, -0.650, -0.610, -0.360, -0.150, -0.110, -0.250, -0.020, 0.250, -2.059, },
  {-1.030, -0.910, -1.210, -0.930, -1.120, -1.250, -1.200, -0.850, -1.020, -1.250, -1.450, -1.250, -3.320, -0.870, -0.860, -0.670, -1.230, -0.730, -0.920, -0.990, 10.000, },
  {-1.370, -1.640, -1.370, -1.930, -1.630, -1.670, -2.000, -2.280, -1.810, -2.440, -0.490, -1.840, -3.910, -1.650, -1.260, -1.230, -1.860, -1.650, -1.860, -2.050, 10.000, },
},
{
  {-1.450, -2.410, -1.180, -3.200, -1.820, -1.410, -2.700, -2.630, -2.260, -1.550, -2.750, -1.890, -1.480, -1.860, -2.820, -2.580, -0.970, -1.350, -1.850, -2.510, -2.907, },
  {-0.520, -2.410, -0.530, -0.160, -0.570, -0.270, -2.000, 0.140, 0.710, 0.620, -0.810, -1.040, -0.570, -0.970, -1.110, -0.460, 1.230, 0.190, -0.340, -0.430, -0.054, },
  {2.270, 1.840, 1.970, 2.020, 1.820, 2.000, 1.690, 2.020, 2.010, 1.930, 2.250, 2.080, 0.040, 2.580, 2.370, 2.320, 2.100, 1.860, 1.440, 1.750, -0.816, },
  {1.330, 1.110, 0.910, 1.030, 1.090, 1.610, 1.000, 0.760, 0.780, 0.670, 1.200, 0.880, -0.750, 1.210, 1.150, 1.200, 0.620, 0.780, 0.840, 1.040, 1.332, },
  {-0.460, 0.040, -0.370, -0.640, 0.230, 0.300, -0.090, -0.370, -0.420, -0.500, -0.510, -0.160, 0.570, -0.530, -0.510, -0.280, -0.310, -0.240, -0.150, 0.280, 0.586, },
  {-0.200, 0.090, -0.280, -0.140, 0.250, -0.450, 0.150, 0.160, -0.110, -0.020, 0.080, -0.260, 1.530, -0.210, 0.130, 0.340, 0.610, 0.370, 0.530, 0.350, 10.000, },
  {-0.370, 0.130, -0.450, -0.610, 0.120, -0.120, -0.280, -0.180, -0.430, -0.380, -0.300, -0.590, 0.400, -0.440, -0.350, 0.060, 0.270, 0.030, 0.030, 0.000, 10.000, },
  {-1.490, -0.830, -1.550, -1.530, -0.940, -0.780, -0.990, -1.140, -1.270, -1.320, -1.250, -1.370, -0.340, -1.380, -1.360, -1.090, -0.870, -1.020, -0.930, -0.890, -1.366, },
  {-1.640, -1.220, -1.280, -1.660, -1.450, -1.120, -1.400, -1.640, -1.410, -1.860, -1.540, -1.320, -0.190, -1.630, -1.490, -1.150, -1.080, -1.610, -1.600, -1.390, 10.000, },
  {-1.050, -1.160, -1.310, -1.750, -1.640, -1.150, -0.790, -0.840, -0.720, -1.640, -1.590, -1.160, -1.480, -1.950, -1.210, -1.170, -0.820, -2.040, -1.600, -1.180, 10.000, },
},
{
  {-1.620, -1.770, -0.440, -2.400, -0.990, -1.050, -1.940, -1.440, -1.510, -0.480, -1.950, -1.260, -1.360, -1.090, -2.120, -2.130, -0.350, -0.260, -1.140, -1.690, 10.000, },
  {0.520, -1.770, 0.910, 0.640, 0.270, 0.080, -1.250, 0.640, 1.460, 1.690, 0.000, 0.280, 1.350, 0.210, 0.280, 1.080, 0.460, 1.980, 0.370, 1.090, 10.000, },
  {1.700, 2.390, 1.000, 1.460, 1.780, 1.300, 1.630, 2.380, 1.460, 1.870, 2.020, 1.110, 0.070, 1.620, 1.680, 1.520, 1.370, 2.220, 1.760, 2.320, 0.284, },
  {1.110, 1.370, 0.540, 0.990, 1.650, 1.160, 1.120, 1.760, 0.760, 1.240, 1.390, 0.760, -0.350, 1.020, 1.070, 0.710, 0.950, 1.710, 1.180, 1.690, -0.107, },
  {-0.310, 0.390, -0.350, -0.120, 0.160, 0.180, 0.100, 0.170, 0.020, -0.140, -0.100, -0.220, 0.420, -0.250, -0.020, -0.050, 0.420, 0.300, 0.290, 0.390, 0.177, },
  {-0.510, -0.310, -0.410, -0.600, -0.570, -0.880, -0.540, -0.510, -0.400, -0.720, -0.510, -0.570, 0.400, -0.510, -0.470, -0.070, -0.210, -0.440, -0.440, -0.510, -1.212, },
  {-1.170, -0.770, -0.720, -1.210, -0.840, -0.910, -0.940, -0.780, -0.980, -0.960, -1.010, -0.870, -0.080, -1.050, -1.040, -0.630, -0.670, -0.710, -0.850, -0.840, -0.438, },
  {-1.200, -0.780, -0.780, -1.130, -0.680, -0.700, -0.650, -0.570, -0.950, -0.780, -0.990, -0.810, -0.500, -0.990, -0.970, -0.800, -0.590, -0.430, -0.900, -0.680, 10.000, },
  {-0.430, -0.040, 0.020, -0.440, 0.060, 0.040, 0.080, 0.240, -0.250, -0.280, 0.030, 0.020, 0.220, -0.440, -0.030, -0.060, 0.220, 0.340, -0.130, -0.050, 10.000, },
  {0.580, 0.470, -0.340, -0.100, 0.220, 0.870, 0.260, -0.340, -0.480, -0.160, 0.130, 1.080, -0.660, -0.190, 0.180, 0.240, 0.490, 1.130, -0.330, 0.670, 10.000, },
},
{
  {-1.180, -2.300, -0.850, -2.380, -1.710, -1.650, -2.350, -2.140, -1.500, -0.880, -2.370, -1.080, -0.100, -1.250, -2.300, -2.180, -0.700, -1.700, -1.640, -2.380, 10.000, },
  {-0.020, -2.300, 0.090, -0.730, -0.460, 0.170, -0.970, 0.630, -0.480, -0.510, -1.110, -0.230, 0.520, -0.650, -0.590, -0.750, -0.110, -0.560, -1.530, -0.710, 0.238, },
  {0.530, 0.260, 0.440, 0.480, 0.530, -0.560, 0.240, 0.750, 0.380, 0.840, 0.560, 0.190, 0.040, 0.550, 0.640, 0.400, 0.580, 0.650, 0.810, 0.550, -0.022, },
  {0.640, 0.810, 0.350, 0.670, 0.920, 0.190, 0.540, 1.320, 0.570, 1.060, 1.090, 0.410, 0.020, 0.730, 0.610, 0.580, 0.960, 1.250, 0.810, 0.960, -0.368, },
  {-0.570, -0.350, -0.350, -0.430, -0.160, 0.360, -0.180, -0.470, -0.320, -0.530, -0.470, -0.240, 0.210, -0.480, -0.340, -0.120, 0.150, -0.400, -0.440, -0.130, 2.670, },
  {-0.860, -0.570, -0.320, -0.890, -0.750, -0.370, -0.600, -0.610, -0.710, -0.850, -0.920, -0.450, 0.070, -0.890, -0.850, -0.580, -0.640, -0.580, -0.740, -0.760, 0.364, },
  {-0.860, -0.460, -0.710, -0.760, -0.660, -0.650, -0.500, -0.380, -0.680, -0.670, -0.750, -0.650, -0.280, -0.790, -0.710, -0.730, -0.720, -0.360, -0.580, -0.620, -0.653, },
  {-0.080, 0.210, 0.130, -0.020, 0.100, 0.020, 0.100, 0.230, 0.260, -0.010, 0.010, 0.110, -0.230, 0.170, 0.260, 0.210, 0.190, 0.340, 0.130, 0.080, 10.000, },
  {0.880, 1.060, 1.370, 0.470, 0.610, 1.610, 0.790, 0.920, 0.880, 0.590, 0.710, 1.210, 0.270, 0.960, 0.850, 1.210, 1.000, 1.150, 0.550, 0.680, 10.000, },
  {0.320, 0.340, 0.230, 1.020, 1.690, 1.770, 0.940, -0.350, -0.250, -0.560, -0.690, 1.260, -0.100, 0.050, 1.110, 1.110, 0.140, 0.380, 0.550, -0.020, 10.000, },
},
{
  {-1.340, -2.680, -0.400, -2.620, -2.250, -0.930, -2.720, -3.000, -1.880, -1.550, -3.000, -1.410, 0.170, -1.780, -2.740, -2.450, -1.310, -2.520, -1.940, -2.960, 10.000, },
  {-0.580, -2.680, 0.260, -0.820, -0.990, 0.200, -1.340, -0.920, 0.400, -0.480, -1.050, 0.130, 1.090, 0.210, -0.340, 0.070, -0.490, 0.400, -0.440, -0.180, 0.251, },
  {0.220, 0.250, 0.130, 0.110, -0.070, 0.490, 0.060, 0.030, 0.250, 0.250, 0.340, 0.180, 0.400, 0.240, 0.230, 0.450, 0.140, -0.190, 0.320, 0.040, 1.047, },
  {0.540, 0.740, 0.350, 0.530, 0.470, -0.240, 0.510, 0.720, 0.500, 0.720, 0.640, 0.190, 0.510, 0.520, 0.570, 0.520, 0.810, 0.570, 0.600, 0.580, -0.483, },
  {-0.550, -0.310, -0.290, -0.500, -0.390, -0.600, -0.320, -0.630, -0.420, -0.590, -0.530, -0.220, -0.090, -0.610, -0.360, -0.060, -0.120, -0.750, -0.460, -0.270, 0.381, },
  {-1.100, -0.930, -0.570, -0.990, -0.760, 0.140, -0.800, -0.600, -1.010, -0.880, -1.030, -0.570, -0.360, -1.010, -1.010, -0.990, -0.930, -0.460, -0.900, -0.920, -0.316, },
  {-0.420, -0.110, -0.300, -0.180, -0.010, 0.210, -0.120, 0.340, -0.060, -0.070, -0.390, -0.200, -0.190, -0.180, -0.320, -0.460, -0.310, 0.420, -0.200, -0.160, -0.234, },
  {1.220, 1.250, 0.830, 0.920, 0.580, 0.360, 0.800, 0.960, 1.180, 0.610, 0.870, 0.940, 0.250, 0.920, 1.010, 0.980, 0.770, 1.080, 0.850, 0.850, 10.000, },
  {1.490, 1.030, 1.330, 0.910, 0.810, 1.390, 1.200, 1.110, 0.950, 0.490, 1.180, 1.400, 1.060, 1.010, 1.130, 1.430, 1.200, 0.600, 0.940, 0.840, 10.000, },
  {1.080, -0.040, 1.090, 0.790, 1.150, 2.630, -0.120, -0.510, 0.060, -1.640, -0.220, 0.930, -0.920, 0.210, -0.030, 1.120, 0.230, -0.440, 0.260, 0.320, 10.000, },
},
{
  {-2.300, -3.710, -1.320, -3.450, -3.240, -1.330, -3.700, -4.270, -2.960, -3.590, -4.120, -3.060, -1.430, -2.800, -3.770, -3.420, -2.450, -3.060, -3.050, -4.010, 10.000, },
  {0.240, -3.710, 0.030, -0.410, -1.990, -0.890, -2.310, -2.190, -1.380, -0.730, -2.860, -0.830, 0.030, -1.910, -1.370, -0.200, -1.350, -0.820, -1.550, -2.340, -2.375, },
  {0.820, 0.850, 0.480, 0.540, 0.180, 0.210, 0.360, 0.650, 0.570, 0.980, 0.450, 0.160, 1.520, 0.850, 0.810, 0.400, 0.600, 0.640, 0.240, 0.580, -0.598, },
  {0.680, 0.540, 0.480, 0.540, 0.400, 0.510, 0.470, 0.460, 0.650, 0.760, 0.700, 0.430, 1.190, 0.740, 0.560, 0.340, 0.650, 0.600, 0.770, 0.480, 10.000, },
  {-0.890, -0.830, -0.390, -0.730, -0.590, -0.880, -0.510, -0.670, -0.670, -0.850, -0.680, -0.390, -0.670, -0.780, -0.740, -0.460, -0.510, -0.690, -0.670, -0.600, 10.000, },
  {-1.300, -0.750, -0.800, -1.110, -0.580, -0.370, -0.770, -0.460, -1.120, -0.950, -1.100, -0.600, -0.580, -1.260, -1.060, -0.850, -0.850, -0.520, -0.690, -0.780, 10.000, },
  {-0.330, 0.260, -0.140, 0.040, -0.080, 0.380, 0.090, 0.250, 0.130, 0.090, 0.130, -0.040, 0.090, 0.040, 0.020, -0.030, 0.000, 0.290, -0.050, 0.240, 10.000, },
  {1.080, 0.590, 0.500, 0.580, 0.600, -0.140, 0.830, 0.400, 0.840, 0.170, 0.130, 0.230, 0.160, 0.380, 0.610, 0.530, 0.400, 0.110, -0.110, 0.240, -2.301, },
  {1.590, 0.880, 0.900, 0.500, 0.270, -0.310, 0.060, -0.770, 0.620, 0.030, -0.120, 0.110, -0.700, 0.100, 0.680, 0.630, 0.620, 0.270, 0.280, 0.300, 10.000, },
  {-0.580, -0.380, -0.530, -0.740, -0.530, 0.150, -1.100, -1.780, -0.320, -1.890, -1.340, -0.730, -0.730, -0.810, -1.470, 1.260, -0.220, -1.670, -1.550, -0.040, 10.000, },
},
{
  {-3.330, -4.520, -2.140, -4.420, -4.000, -1.240, -4.480, -5.330, -3.910, -3.940, -5.220, -2.860, -2.570, -3.790, -4.730, -4.260, -3.280, -4.080, -3.800, -4.450, 10.000, },
  {-1.890, -4.520, -1.490, -1.380, -2.750, 0.590, -3.100, -2.560, -2.040, -2.470, -3.280, -0.630, -0.560, -1.790, -2.330, -1.740, -1.780, -1.850, -2.290, -1.670, 10.000, },
  {1.480, 1.030, 0.950, 1.170, 0.520, 1.060, 0.600, 0.350, 0.660, 1.060, 0.570, 0.710, 1.280, 0.530, 1.240, 0.800, 1.370, 1.170, 0.130, 0.390, 10.000, },
  {0.730, 0.190, 0.310, 0.480, 0.530, -0.100, 0.120, 0.610, 0.720, 0.870, 0.530, -0.030, 0.570, 0.470, 0.520, 0.360, 0.620, 0.270, 0.750, 0.710, -0.431, },
  {-0.870, -0.090, -0.380, -0.640, -0.340, -0.560, -0.160, -0.680, -0.750, -0.610, -0.360, -0.040, -0.530, -0.740, -0.710, -0.410, -0.030, -0.030, -0.730, 0.090, 0.432, },
  {-0.830, -0.110, -0.300, -0.830, -0.540, -0.250, -0.280, -0.090, -0.660, -0.620, -0.810, -0.060, -0.150, -0.660, -0.650, -0.300, -0.700, -0.540, -0.550, -0.450, 10.000, },
  {-0.640, 0.400, -0.230, -0.500, 0.000, 0.650, 0.000, -0.200, -0.320, -0.590, -0.340, 0.170, -0.450, -0.300, -0.360, -0.020, -0.250, -0.060, 0.150, -0.270, -1.792, },
  {-0.320, -0.300, -0.410, 0.060, 0.200, 0.800, 0.050, -0.400, 0.160, -0.440, -0.200, -0.190, -1.050, -0.050, 0.310, -0.050, 0.270, -0.090, -0.110, 0.070, -2.619, },
  {-0.910, -1.150, -1.160, -1.120, -0.910, -0.190, -0.930, -0.530, -1.270, -1.470, -1.230, -1.070, -2.380, -0.770, -1.220, -0.810, -0.940, 0.050, -0.820, -1.090, 10.000, },
  {-1.830, -1.880, -0.660, -2.120, -1.290, -0.810, -1.190, -2.850, -2.370, -2.930, -3.140, -1.620, -3.270, -2.890, -2.930, -1.200, -1.060, -2.700, -1.600, -1.580, 10.000, },
},
{
  {-2.820, -4.030, -1.430, -4.260, -3.680, -1.540, -3.890, -5.250, -3.540, -3.730, -4.350, -2.010, -2.940, -3.220, -4.200, -3.690, -3.020, -4.060, -3.570, -4.200, 10.000, },
  {-0.280, -4.030, -0.770, -2.140, -2.430, -0.810, -2.510, -2.470, -0.570, -1.570, -2.400, -0.880, -1.330, -1.230, -2.490, -0.470, -0.820, -1.830, -2.070, -1.420, 10.000, },
  {0.820, 0.220, 0.130, 0.500, 0.280, 0.320, -0.220, 0.530, 0.310, 0.190, -0.080, -0.460, 0.280, 0.400, 0.690, 0.900, 0.750, 0.300, 0.580, 0.140, -0.086, },
  {0.750, 0.360, -0.020, 0.300, 0.630, 0.290, 0.170, 0.690, 0.300, 0.320, 0.750, -0.100, 0.330, 0.300, 0.320, 0.560, 0.100, 0.450, 0.640, 0.290, 1.149, },
  {0.050, -0.070, 0.600, 0.010, 0.080, 0.460, 0.570, -0.370, 0.120, -0.090, 0.000, 0.750, -0.350, 0.270, 0.260, 0.420, -0.120, 0.170, 0.310, 0.390, -0.433, },
  {0.180, 0.810, 0.410, -0.010, 0.500, -0.440, 0.350, -0.180, 0.250, -0.290, -0.240, 0.590, -0.070, 0.010, 0.100, 0.610, 0.400, -0.090, 0.010, -0.160, -1.418, },
  {0.310, 0.340, 0.340, 0.100, 0.360, -0.240, 0.470, 0.170, 0.310, 0.070, 0.170, 0.470, -0.230, 0.270, 0.610, 0.510, 0.350, 0.260, -0.320, 0.300, -0.643, },
  {-0.820, -0.270, -0.600, -0.740, -0.370, 0.110, -0.460, -0.890, -0.700, -0.320, -0.250, 0.130, -0.670, -0.600, -0.700, -0.380, -0.250, -0.700, -0.320, -0.030, -1.470, },
  {-2.090, -1.470, -1.750, -2.100, -1.630, -0.540, -1.240, -1.830, -2.070, -2.260, -1.900, -1.060, -2.350, -2.070, -2.050, -1.660, -1.300, -1.580, -1.650, -1.260, 10.000, },
  {-2.420, -0.700, -2.020, -1.960, -1.890, -1.070, -2.390, -2.760, -2.700, -2.720, -2.680, -1.060, -2.940, -2.320, -2.180, -1.790, -2.400, -3.780, -2.070, -1.840, -1.113, },
},
};

float lpethph2[12][10][21] = {
{
  {-2.860, -3.720, -2.470, -3.890, -2.910, -1.470, -3.490, -4.250, -3.300, -3.020, -4.260, -2.280, -2.340, -3.000, -3.960, -3.850, -2.360, -2.980, -3.090, -3.510, 10.000, },
  {-1.700, -3.720, -0.420, -1.250, -2.350, -0.750, -2.800, -1.470, -1.720, -1.550, -2.320, -0.040, -1.020, -2.390, -1.560, -1.320, -1.550, -1.440, -1.590, -0.730, -0.366, },
  {-0.400, 0.030, -0.460, -0.330, 0.290, 0.900, 0.240, -0.280, -0.500, -0.280, -0.230, 0.310, -0.370, -0.380, -0.190, -0.470, -0.290, -0.220, -0.160, 0.280, 0.430, },
  {-0.920, 0.080, -0.820, -0.810, 0.080, 0.960, -0.140, -0.760, -1.080, -0.920, -0.650, 0.160, -0.810, -0.880, -0.710, -0.830, -0.800, -0.710, 0.000, 0.140, 0.866, },
  {-2.040, -0.800, -1.160, -2.110, -1.000, -0.220, -1.060, -1.730, -2.290, -2.030, -1.810, -0.730, -1.440, -2.030, -1.950, -1.800, -1.610, -1.740, -1.320, -1.010, -0.878, },
  {-1.530, 0.140, -0.710, -1.420, 0.170, -0.870, -0.240, -0.120, -1.420, -0.590, -0.920, -0.210, -1.120, -1.120, -1.000, -0.770, -0.520, -0.170, -0.490, -0.310, -0.933, },
  {-0.490, 0.650, 0.010, -0.420, 0.510, -0.120, 0.090, 0.470, -0.390, 0.250, -0.360, 0.000, -0.470, -0.290, -0.150, -0.070, 0.210, 0.910, -0.210, 0.440, -0.158, },
  {-0.520, 0.680, -0.150, -0.620, 0.450, 0.250, 0.090, 0.340, -0.530, -0.090, -0.400, 0.290, -1.120, -0.490, -0.570, -0.070, 0.160, 0.430, 0.150, 0.560, 10.000, },
  {0.010, 0.530, 0.280, -0.420, 0.990, 1.090, 0.350, -0.650, -0.300, -0.630, -0.270, 0.790, -1.050, -0.670, -0.360, -0.070, 0.390, 0.060, -0.110, 0.520, 10.000, },
  {0.260, -0.390, -0.980, -1.180, -0.200, 1.950, -0.190, -2.860, -2.050, -2.010, -2.180, 0.060, -3.030, -1.000, -1.940, 0.130, -0.830, -1.590, -0.900, -0.230, 10.000, },
},
{
  {0.230, -1.750, 0.350, -1.120, -0.850, -1.140, -1.620, -1.420, -0.650, 0.150, -1.290, -0.520, -1.260, -0.860, -1.310, -1.790, -0.430, -1.190, -0.740, -1.580, 10.000, },
  {0.070, -1.750, -0.500, -0.020, -0.700, -0.230, -0.240, -0.850, 0.240, 0.370, -0.440, -0.240, -0.260, 0.040, -0.010, -0.180, -0.020, -0.560, -0.620, -0.600, 0.379, },
  {-0.860, -1.350, -1.050, -0.800, -1.160, -1.150, -1.130, -1.180, -0.990, -0.910, -0.950, -0.950, -1.280, -0.940, -0.990, -1.270, -1.390, -1.350, -1.010, -1.230, -0.223, },
  {-0.870, -1.290, -0.920, -0.820, -1.160, -0.830, -1.080, -1.190, -0.960, -0.890, -0.960, -0.760, -1.330, -0.900, -0.960, -1.270, -1.340, -1.350, -1.060, -1.190, -0.121, },
  {0.680, 0.500, 0.950, 0.630, 0.370, 0.440, 0.440, 0.770, 0.450, 0.800, 0.630, 0.880, 0.360, 0.590, 0.480, 0.080, 0.160, 0.490, 0.510, 0.220, 0.550, },
  {2.810, 2.250, 2.270, 2.540, 2.140, 1.730, 1.810, 2.630, 2.520, 3.040, 2.540, 2.030, 1.930, 2.510, 2.420, 1.910, 1.990, 2.460, 2.510, 2.190, 0.323, },
  {3.010, 3.170, 2.280, 2.850, 2.790, 1.750, 2.480, 3.500, 3.120, 3.840, 4.180, 2.650, 1.880, 2.900, 3.000, 2.420, 2.820, 3.430, 3.210, 2.780, 10.000, },
  {2.750, 2.390, 2.380, 2.540, 2.820, 1.890, 3.000, 2.970, 2.520, 3.030, 3.120, 2.420, 0.530, 2.560, 2.700, 1.940, 2.030, 3.220, 2.510, 2.530, 10.000, },
  {2.490, 2.250, 1.970, 1.870, 2.470, 2.380, 1.990, 1.770, 2.140, 1.730, 2.700, 2.290, -0.780, 1.720, 1.930, 1.950, 1.720, 2.320, 2.750, 2.070, -1.269, },
  {1.730, 0.890, 1.140, 1.180, 1.160, 1.970, 1.670, 1.060, 0.890, 0.060, 0.380, 1.810, -0.570, 0.730, 0.710, 1.270, 0.700, 0.890, 1.460, 1.000, 10.000, },
},
{
  {-1.830, -2.510, -1.370, -2.400, -1.670, -0.720, -2.250, -2.800, -1.770, -2.130, -2.470, -0.990, -1.390, -1.310, -2.460, -2.390, -1.810, -1.760, -2.350, -2.360, 10.000, },
  {-1.300, -2.510, -1.220, -1.230, -1.110, -0.690, -1.550, -1.130, -1.200, -1.430, -1.220, -0.550, -1.620, -1.400, -1.450, -1.560, -0.870, -2.010, -1.540, -0.680, 1.062, },
  {-0.620, -0.720, -0.480, -0.600, -0.690, -0.580, -0.590, -0.900, -0.600, -0.630, -0.700, -0.210, -1.660, -0.450, -0.590, -0.930, -0.900, -0.930, -0.830, -0.590, -0.637, },
  {-0.070, -0.260, 0.050, 0.040, 0.040, 0.030, 0.000, -0.100, -0.010, -0.100, -0.090, 0.240, -1.260, 0.020, -0.020, -0.340, -0.230, -0.160, -0.310, -0.030, 0.270, },
  {0.190, 0.200, 0.900, 0.430, 0.410, 0.360, 0.190, 0.180, 0.280, 0.300, 0.030, 0.630, 0.680, 0.310, 0.120, -0.110, -0.260, 0.100, 0.180, 0.260, 0.722, },
  {2.210, 1.440, 2.080, 1.860, 1.570, 1.300, 1.560, 2.120, 1.930, 2.560, 2.190, 1.790, 2.330, 1.880, 1.820, 1.900, 1.640, 1.750, 1.690, 1.400, 1.188, },
  {2.510, 2.560, 3.090, 2.340, 3.760, 1.870, 2.380, 2.990, 2.610, 3.130, 2.820, 2.640, 2.460, 2.820, 2.540, 2.500, 2.830, 2.950, 2.400, 3.710, 1.270, },
  {2.410, 2.250, 2.500, 2.510, 2.590, 1.980, 2.470, 2.760, 2.250, 3.250, 2.730, 2.560, 0.410, 2.610, 2.510, 2.470, 2.230, 2.510, 2.840, 2.940, 10.000, },
  {1.960, 1.610, 1.790, 1.550, 2.600, 2.200, 2.470, 1.490, 1.700, 2.050, 1.530, 2.180, -1.350, 1.480, 2.240, 2.190, 2.020, 1.460, 3.630, 2.580, 10.000, },
  {0.870, 0.820, -0.390, 1.000, 1.730, 2.140, 0.360, -0.320, 0.870, -0.020, 0.300, 1.340, -2.080, -0.020, 0.250, 1.190, 0.410, -0.370, -0.150, 1.610, 10.000, },
},
{
  {-1.290, -2.460, -0.320, -2.600, -1.750, -0.710, -2.330, -2.750, -1.830, -1.180, -2.580, -1.740, -2.370, -1.410, -2.590, -2.420, -1.110, -2.360, -1.820, -2.420, 10.000, },
  {-0.350, -2.460, 0.340, -0.470, -1.190, -0.680, -0.940, -1.070, -0.810, -0.110, -0.630, -0.420, 0.340, -0.520, -1.290, 0.110, -0.300, -0.530, -0.310, -1.030, 10.000, },
  {1.450, 1.300, 0.990, 1.500, 1.430, -0.080, 1.150, 1.790, 1.140, 1.640, 1.180, 0.720, 0.630, 1.130, 1.230, 0.970, 1.100, 1.840, 1.420, 1.560, -0.106, },
  {0.610, 0.260, 0.100, 0.500, 0.340, -0.740, 0.190, 0.980, 0.360, 0.430, 0.410, -0.080, -0.040, 0.290, 0.350, 0.080, 0.080, 0.780, 0.340, 0.330, -0.401, },
  {0.180, 0.100, 0.700, 0.270, 0.080, -0.450, 0.130, 0.320, 0.170, 0.240, 0.100, 0.220, 0.550, 0.170, 0.160, -0.030, -0.350, 0.510, 0.070, 0.050, 1.156, },
  {1.840, 1.450, 2.210, 1.790, 1.620, 0.990, 1.380, 2.150, 2.120, 2.320, 2.080, 1.710, 2.530, 1.780, 1.740, 2.060, 1.760, 2.130, 1.530, 1.420, 10.000, },
  {2.130, 2.610, 2.820, 2.480, 2.990, 1.850, 3.070, 2.760, 2.370, 3.030, 2.300, 2.780, 2.280, 2.550, 2.420, 2.710, 3.260, 2.760, 2.940, 3.040, 10.000, },
  {2.370, 2.640, 2.640, 2.020, 2.830, 2.100, 2.740, 2.930, 2.620, 2.470, 2.620, 3.890, 1.070, 2.170, 2.760, 2.780, 2.550, 2.330, 2.130, 2.650, 10.000, },
  {2.320, 3.050, 1.910, 2.120, 3.110, 2.460, 3.990, 3.150, 2.850, 2.310, 2.510, 2.720, -1.080, 2.990, 3.370, 2.460, 2.250, 2.470, 2.080, 3.210, 10.000, },
  {1.830, 0.880, 0.480, 0.800, 0.960, 2.020, 0.970, -0.260, 0.120, -0.860, 0.190, 0.600, -1.680, -0.110, 0.120, 1.160, 1.120, -0.280, 0.380, 1.550, 10.000, },
},
{
  {-1.170, -2.300, -0.310, -2.600, -1.720, -1.480, -2.340, -2.590, -1.820, -1.160, -2.510, -1.830, -1.730, -1.420, -2.530, -2.330, -1.030, -1.510, -1.750, -2.410, 10.000, },
  {0.280, -2.300, 0.340, 1.140, -0.470, -0.750, -0.950, 0.180, 1.150, -0.370, -1.250, -0.290, 0.980, -0.120, -0.130, 0.190, -0.220, 0.030, -0.250, -0.330, 0.773, },
  {2.530, 1.350, 1.360, 1.990, 1.670, -0.550, 1.160, 2.940, 1.420, 2.050, 1.760, 0.560, 1.390, 1.510, 1.840, 1.830, 1.880, 2.600, 1.710, 1.810, 0.064, },
  {1.360, 0.810, 0.480, 1.190, 0.780, -1.010, 0.550, 1.860, 0.920, 1.270, 1.000, -0.050, 0.550, 0.910, 0.910, 0.960, 0.860, 1.620, 1.050, 0.830, 0.262, },
  {0.230, 0.370, 0.670, 0.430, 0.280, -1.090, 0.470, 0.650, 0.340, 0.520, 0.180, 0.220, 0.180, 0.470, 0.330, 0.450, 0.400, 0.600, 0.410, 0.340, -0.533, },
  {1.290, 1.180, 1.710, 1.200, 1.200, 0.590, 1.210, 1.220, 1.480, 1.220, 1.550, 1.060, 1.470, 1.340, 1.380, 1.380, 1.630, 1.020, 1.320, 1.300, 0.206, },
  {1.730, 1.340, 1.900, 1.390, 1.360, 1.770, 1.300, 1.100, 1.710, 1.460, 1.530, 1.640, 2.070, 1.590, 1.430, 1.720, 1.800, 1.290, 1.210, 1.250, 10.000, },
  {1.720, 2.320, 2.540, 1.580, 1.920, 2.060, 1.590, 1.480, 1.700, 2.040, 1.600, 2.500, 2.630, 1.810, 1.880, 1.920, 2.170, 1.790, 2.060, 2.080, -1.233, },
  {2.030, 2.510, 3.210, 2.130, 2.660, 2.760, 2.880, 1.920, 1.760, 1.770, 2.590, 2.850, 0.250, 1.600, 2.500, 2.600, 2.320, 2.920, 2.150, 2.310, 10.000, },
  {1.950, 1.030, 1.170, 0.800, 1.680, 1.950, 0.960, -0.100, 0.820, -0.140, 0.270, 1.200, -1.730, 0.570, 0.870, 2.340, 1.190, -0.120, 0.450, 0.870, 10.000, },
},
{
  {-0.890, -2.040, -0.960, -2.440, -1.470, -0.800, -2.190, -2.240, -2.340, -0.950, -2.260, -1.140, -1.480, -1.240, -2.310, -2.110, -0.770, -1.090, -1.470, -2.170, 10.000, },
  {0.270, -2.040, 1.080, 0.200, -0.910, -0.360, -1.500, 0.540, 1.320, 0.120, -1.010, -0.300, -0.150, 0.750, 0.090, 1.110, 1.430, 1.150, 0.040, -0.500, 0.977, },
  {2.600, 2.210, 1.430, 2.500, 1.830, 0.530, 1.240, 3.860, 2.020, 2.290, 2.100, 0.790, 1.500, 2.060, 2.360, 2.480, 3.350, 2.930, 2.280, 2.010, 0.717, },
  {2.260, 1.720, 0.870, 2.060, 1.680, 0.080, 1.220, 2.590, 1.720, 1.940, 1.750, 0.580, 0.660, 1.790, 1.650, 2.040, 2.640, 2.370, 2.000, 1.870, -0.122, },
  {-0.080, -0.170, -0.310, -0.120, -0.290, -0.330, -0.010, -0.360, 0.090, -0.350, -0.050, -0.410, -0.750, -0.230, -0.010, 0.230, 0.620, -0.330, -0.120, -0.150, -0.280, },
  {-0.120, -0.170, -0.220, -0.270, -0.420, 0.220, -0.070, -0.360, -0.130, -0.420, -0.250, -0.300, -0.420, -0.230, -0.190, 0.220, 0.220, -0.340, -0.450, -0.370, 0.410, },
  {-0.040, -0.030, 0.380, -0.230, -0.260, 0.600, 0.090, -0.250, 0.040, -0.250, -0.130, 0.040, 0.060, 0.240, -0.070, 0.400, 0.250, -0.210, -0.290, -0.240, -0.895, },
  {-0.030, 0.260, 0.950, -0.160, 0.100, 0.960, 0.240, 0.070, 0.250, 0.090, 0.140, 0.570, 0.400, 0.130, 0.320, 0.390, 0.600, 0.330, -0.050, 0.120, -1.722, },
  {0.770, 1.060, 1.410, 0.410, 0.950, 1.500, 0.570, 0.660, 0.670, 0.490, 0.690, 1.520, -0.190, 0.810, 1.080, 0.940, 1.030, 0.570, 0.380, 0.770, 10.000, },
  {1.120, 0.600, 0.530, 0.270, 0.140, 1.710, 0.000, 0.250, -0.110, 0.060, 0.510, 0.500, -1.480, 0.750, 0.400, 1.180, 0.070, 0.300, -0.370, 0.700, 10.000, },
},
{
  {-0.610, -1.720, -0.160, -2.150, -1.080, -0.670, -1.930, -1.560, -1.350, -0.490, -1.860, -1.060, -0.840, -0.930, -1.980, -1.890, -0.380, -0.410, -1.100, -1.770, -0.579, },
  {0.830, -1.720, 0.090, 1.580, 0.180, -0.230, -0.540, 0.520, 0.930, 0.580, 0.080, 1.180, 0.080, 1.060, -0.680, 0.640, 0.030, 1.130, 0.400, 1.000, -0.671, },
  {3.020, 2.620, 2.210, 3.160, 2.840, 2.150, 2.260, 3.390, 2.820, 3.070, 3.340, 1.470, 1.660, 2.690, 2.970, 2.950, 2.960, 3.850, 2.490, 3.060, 0.001, },
  {2.690, 1.870, 1.200, 2.650, 2.500, 2.100, 1.830, 2.490, 2.290, 2.440, 2.600, 1.050, 1.400, 2.290, 2.550, 2.540, 2.740, 2.790, 2.820, 2.490, 0.049, },
  {-0.300, -0.250, -0.910, -0.240, -0.190, 0.890, -0.130, -0.190, -0.140, -0.400, -0.220, -0.740, -0.350, -0.300, -0.260, 0.000, 0.400, -0.050, -0.290, -0.040, 0.141, },
  {-0.760, -0.710, -0.990, -0.850, -0.830, -0.490, -0.760, -0.700, -0.700, -0.990, -0.800, -1.110, -0.490, -0.750, -0.810, -0.550, -0.610, -0.640, -0.890, -0.850, -0.309, },
  {-0.870, -0.660, -0.690, -0.890, -0.790, -0.240, -0.810, -0.790, -0.670, -0.900, -0.800, -0.910, -0.340, -0.830, -0.770, -0.530, -0.650, -0.710, -0.900, -0.810, 0.178, },
  {-0.870, -0.460, -0.340, -0.830, -0.540, 0.010, -0.460, -0.490, -0.520, -0.830, -0.720, -0.410, -0.240, -0.680, -0.550, -0.590, -0.400, -0.320, -0.680, -0.600, 0.961, },
  {-0.540, -0.040, -0.170, -0.610, -0.340, 0.110, -0.190, -0.130, -0.370, -0.500, -0.590, 0.070, 0.040, -0.540, -0.400, -0.350, -0.240, 0.030, -0.720, -0.400, -0.985, },
  {-0.210, 0.000, -0.460, -0.700, -0.070, 0.120, -0.240, 0.230, 1.290, -0.580, -0.190, 0.180, -0.840, -0.730, 1.420, -0.160, 0.750, 0.290, 0.400, 0.000, 10.000, },
},
{
  {-0.880, -2.050, -0.370, -2.330, -1.460, -1.350, -2.180, -2.050, -1.450, -0.830, -2.150, -1.300, -0.330, -1.110, -2.170, -2.040, -1.640, -0.860, -1.520, -2.160, 10.000, },
  {0.970, -2.050, -0.120, 0.310, -0.210, 1.160, -0.790, 0.030, 1.520, 0.240, -0.890, 0.930, -0.100, 0.880, 0.230, 0.490, 0.040, 1.370, -0.020, -0.090, -0.208, },
  {2.000, 1.410, 1.660, 2.240, 2.050, 2.180, 1.920, 3.130, 2.420, 1.760, 1.730, 1.640, 1.860, 2.310, 2.200, 1.660, 1.650, 3.240, 2.070, 2.270, 0.159, },
  {1.970, 1.200, 1.570, 2.190, 1.580, 2.540, 1.470, 2.460, 1.980, 1.430, 1.840, 1.310, 2.040, 2.190, 2.200, 1.420, 1.200, 2.640, 1.840, 1.760, 0.056, },
  {-0.220, -0.200, -0.440, -0.220, 0.040, 1.130, -0.240, -0.190, 0.170, -0.180, -0.140, -0.220, -0.310, -0.090, 0.090, 0.150, -0.200, -0.020, -0.110, 0.010, -0.284, },
  {-0.760, -0.510, -0.860, -0.850, -0.520, -0.090, -0.780, -0.620, -0.720, -0.630, -0.700, -0.780, -0.390, -0.830, -0.700, -0.660, -0.510, -0.460, -0.570, -0.450, -0.276, },
  {-0.810, -0.660, -0.700, -0.850, -0.750, -0.010, -0.840, -0.560, -0.850, -0.790, -0.750, -0.760, -0.230, -0.860, -0.790, -0.530, -0.340, -0.500, -0.710, -0.730, 0.847, },
  {-0.840, -0.740, -0.800, -0.740, -0.970, -0.180, -0.920, -0.750, -0.800, -0.860, -0.730, -0.890, -0.100, -0.770, -0.810, -0.690, -0.430, -0.780, -0.900, -0.920, 10.000, },
  {-1.180, -0.700, -0.520, -0.820, -1.100, -0.310, -0.990, -0.940, -0.920, -1.030, -0.700, -0.870, 0.560, -0.820, -0.740, -0.690, -0.710, -0.890, -0.900, -1.130, 10.000, },
  {-1.200, -1.120, -0.670, -1.130, -1.350, -0.710, -1.280, -0.660, -1.210, -0.510, -0.760, -1.270, -0.330, -0.510, -0.960, -0.890, -0.520, -1.420, -1.720, -1.330, 0.089, },
},
{
  {-1.360, -2.630, -1.400, -2.740, -2.180, -0.730, -2.750, -2.850, -1.890, -2.140, -2.710, -1.660, -0.860, -2.280, -2.630, -2.440, -1.010, -1.650, -2.230, -2.860, -1.222, },
  {-0.200, -2.630, -0.050, -0.390, -0.930, 0.400, -1.370, -0.770, -0.870, 0.030, -0.760, -0.810, 1.160, -0.280, -0.230, 0.080, 0.080, -0.510, -1.830, -0.090, 0.021, },
  {0.970, 1.450, 0.540, 1.260, 1.690, 1.820, 1.130, 2.100, 1.400, 0.920, 1.440, 0.780, 2.850, 1.230, 1.490, 1.220, 1.800, 2.080, 1.520, 1.430, 0.517, },
  {1.300, 0.940, 0.620, 1.420, 0.920, 2.280, 0.620, 1.310, 1.430, 1.020, 1.210, 0.370, 2.790, 1.110, 1.260, 1.250, 1.320, 1.710, 1.360, 0.750, -0.459, },
  {0.150, 0.290, 0.620, 0.170, 0.030, 1.550, -0.080, -0.060, 0.290, 0.100, 0.070, 0.590, 0.400, 0.390, 0.370, 0.730, 0.290, 0.100, 0.360, -0.010, 0.597, },
  {-1.020, -0.480, -0.590, -0.910, -0.380, -0.050, -0.620, -0.330, -0.840, -0.680, -0.830, -0.400, -0.230, -0.850, -0.780, -0.880, -0.790, -0.160, -0.350, -0.240, 1.757, },
  {-1.080, -0.760, -1.100, -1.070, -0.770, -0.610, -0.820, -0.490, -1.030, -0.990, -1.010, -1.090, -0.400, -1.080, -0.950, -1.200, -1.080, -0.410, -0.500, -0.640, 1.145, },
  {-0.980, -1.040, -1.130, -1.190, -1.160, -0.400, -1.160, -1.080, -1.140, -1.100, -1.170, -1.370, -0.240, -1.200, -1.170, -0.910, -1.150, -1.040, -1.080, -1.120, 10.000, },
  {-1.160, -1.380, -1.130, -1.210, -1.460, -0.750, -1.310, -1.310, -1.090, -1.190, -1.250, -1.480, 1.120, -1.130, -1.210, -1.120, -0.950, -1.290, -1.230, -1.280, 10.000, },
  {-1.380, -1.500, -0.820, -1.130, -1.080, -1.040, -1.250, -2.160, -0.860, -2.050, -1.730, -1.270, -0.170, -1.380, -1.530, -1.170, -1.190, -1.650, -0.730, -1.460, -1.809, },
},
{
  {-3.470, -3.670, -1.430, -3.630, -3.960, -1.660, -3.640, -3.850, -2.820, -2.500, -3.840, -2.410, -1.130, -2.530, -3.590, -3.600, -2.330, -2.590, -3.120, -3.850, -2.655, },
  {-0.520, -3.670, -0.080, -0.580, -2.010, 0.170, -2.250, -1.080, -1.450, -1.020, -1.900, -1.270, 0.880, -1.230, -1.880, -0.380, -0.130, -0.350, -1.610, -1.080, 10.000, },
  {1.720, 0.680, 0.970, 1.890, 0.790, 1.090, 0.930, 2.380, 1.800, 1.350, 0.850, 0.200, 3.270, 1.910, 1.870, 1.300, 1.710, 2.210, 0.920, 0.680, 0.588, },
  {1.880, 1.680, 1.390, 2.060, 1.060, 2.010, 1.090, 1.700, 1.940, 1.770, 1.250, 0.880, 3.220, 1.660, 1.610, 1.420, 1.650, 1.640, 1.430, 1.270, 1.296, },
  {0.450, 0.870, 1.050, 0.800, 0.650, 1.560, 0.080, 1.000, 1.140, 0.630, 0.320, 0.650, 1.910, 0.850, 0.830, 0.680, 1.140, 0.740, 0.650, 0.450, -0.703, },
  {-0.650, -0.060, 0.120, -0.180, 0.010, 0.360, 0.200, 0.960, -0.210, -0.250, -0.160, -0.060, 0.170, -0.300, 0.100, -0.130, 0.140, 0.800, 0.470, 0.150, -1.286, },
  {-1.000, -0.540, -1.560, -0.910, -0.310, -0.860, -0.510, 0.340, -0.760, -0.700, -0.610, -1.420, -0.670, -0.930, -0.720, -0.790, -0.560, 0.190, -0.530, -0.390, -1.387, },
  {-0.970, -1.110, -1.950, -1.210, -0.930, -1.060, -1.330, -0.960, -1.200, -1.100, -1.150, -1.830, -0.410, -1.220, -1.220, -0.940, -1.290, -1.020, -0.630, -0.920, -1.808, },
  {-1.380, -1.790, -2.150, -1.600, -1.270, -1.120, -1.610, -1.130, -1.420, -1.430, -1.840, -2.240, 0.160, -1.510, -1.830, -1.440, -1.540, -1.160, -1.010, -1.150, 10.000, },
  {-1.660, -1.720, -1.890, -1.320, -0.960, -1.030, -1.440, -2.060, -1.790, -1.490, -1.760, -2.270, -1.830, -2.150, -1.280, -1.410, -2.050, -1.200, -1.610, -0.980, -2.145, },
},
{
  {-3.120, -4.650, -2.910, -4.180, -3.920, -1.390, -4.310, -4.260, -3.410, -3.130, -4.700, -3.250, -2.270, -3.190, -4.310, -4.410, -3.220, -3.130, -3.650, -4.490, 10.000, },
  {-0.580, -4.650, -1.560, -1.140, -2.670, 0.430, -2.930, -1.480, -1.130, -1.660, -2.760, -1.020, 0.440, -1.200, -1.910, -1.880, -1.720, -0.900, -2.150, -1.710, -0.496, },
  {1.120, 0.390, -0.100, 1.070, 0.090, 0.870, 0.020, 1.610, 0.680, 1.290, 0.620, -1.260, 1.650, 0.760, 0.700, 0.730, 1.180, 1.980, 0.970, 0.280, -0.019, },
  {0.780, 0.440, 0.010, 0.950, 0.690, 1.560, 0.370, 0.940, 0.750, 0.830, 0.900, -0.620, 2.180, 0.600, 0.640, 0.660, 0.780, 0.820, 1.040, 0.720, 0.603, },
  {-0.220, -0.220, 0.060, 0.090, -0.120, 0.600, -0.160, -0.120, -0.020, -0.270, 0.340, 0.020, 1.880, -0.440, -0.270, -0.220, 0.060, -0.080, -0.180, -0.030, 0.327, },
  {0.300, -0.170, 0.330, 0.630, -0.040, -0.100, 0.280, 0.520, 0.840, 0.400, -0.130, -0.210, 2.100, 0.240, 0.280, -0.090, 0.390, 0.340, 0.690, 0.000, 10.000, },
  {0.120, -0.190, -0.260, -0.020, 0.170, -0.940, -0.160, 1.110, 0.330, 0.480, -0.110, 0.080, 0.720, 0.010, 0.240, 0.320, 0.190, 1.330, 0.880, 0.160, -2.486, },
  {-0.670, -0.250, -0.430, 0.000, 0.390, -1.310, -0.390, 0.560, 0.080, 0.240, 0.030, -1.070, -0.110, -0.050, -0.280, -0.370, -0.120, 0.420, 0.040, 0.110, -1.115, },
  {-0.590, -0.940, -1.490, -1.000, -0.020, -1.310, -0.760, -0.300, -0.720, -0.200, -0.710, -1.060, -0.980, -1.080, -0.560, -0.650, -0.750, 0.600, -0.160, 1.150, 10.000, },
  {-1.110, -1.320, -1.830, -1.880, -1.620, -0.890, -1.710, -1.770, -1.470, -2.120, -1.930, -2.300, -2.270, -1.200, -1.600, -1.120, -2.100, -2.440, -2.150, -0.520, 10.000, },
},
{
  {-3.570, -5.210, -2.680, -4.520, -4.380, -2.070, -4.810, -4.630, -3.760, -3.530, -5.120, -3.960, -2.480, -3.640, -4.730, -4.890, -3.650, -3.510, -4.010, -4.830, 10.000, },
  {-2.410, -5.210, -2.030, -1.470, -3.130, -0.940, -3.420, -1.860, -0.790, -2.050, -3.170, -2.420, -1.380, -2.340, -2.340, -3.060, -2.840, -1.280, -2.510, -2.750, 10.000, },
  {0.550, -0.350, -0.270, 0.530, 0.230, 1.600, -0.090, 0.600, 0.560, 0.600, 0.340, 0.060, 0.710, 0.450, 0.620, -0.080, -0.510, 0.080, 0.280, 0.250, -0.206, },
  {-0.080, -0.260, -0.350, 0.410, 0.080, 1.350, 0.030, -0.070, 0.020, -0.220, -0.270, -0.230, 0.240, 0.030, 0.200, -0.550, -0.520, -0.150, 0.060, 0.220, 0.657, },
  {-1.820, -1.420, -1.010, -1.530, -1.380, -1.440, -1.200, -1.070, -1.400, -1.520, -1.900, -1.390, -0.410, -1.540, -1.570, -1.560, -1.430, -1.190, -1.270, -1.300, -0.089, },
  {-1.000, -0.870, -0.890, -1.080, -1.170, -2.050, -1.350, -0.780, -0.960, -0.680, -0.630, -1.170, 0.020, -1.100, -1.030, -0.800, -0.820, -0.780, -0.810, -1.270, -1.414, },
  {-0.560, -0.830, -0.730, -0.990, -1.130, -1.500, -1.220, -0.570, -0.890, -0.480, -0.340, -0.860, 1.180, -0.910, -0.900, -0.720, -0.420, -0.550, -0.760, -1.240, -0.927, },
  {-0.440, -0.900, -0.690, -0.620, -0.370, -1.410, -0.500, -0.160, -0.530, -0.520, -0.250, -0.810, -0.070, -0.810, -0.700, -0.330, -0.330, 0.410, -0.830, -0.380, 10.000, },
  {0.440, -0.400, -0.260, -0.300, -0.400, -1.090, -0.560, -0.120, -0.060, 0.250, -0.720, -0.190, -1.600, 0.080, -0.290, 0.110, -0.520, -0.380, -0.520, -0.010, 10.000, },
  {-1.850, -1.880, -1.200, -2.210, -0.980, -0.200, -2.200, -2.140, -1.120, -2.520, -3.040, -1.620, -2.480, -1.640, -1.330, -0.220, -2.120, -2.120, -1.810, -1.550, 10.000, },
},
};


			</file>
			<file name="localpotentialraft.h" type="text">

#ifndef localpotentialraft_h
#define localpotentialraft_h

int *localpotentialraft(char *seq, double locpotp, CONFORMERSET *cs, FORCEFIELDPARAMS *ffp, INPUTPARAMS *ip, int iterations);

#endif

			</file>
			<file name="readsequence.h" type="text">
#ifndef readsequence_h
#define readsequence_h

typedef struct
{
    int len;         /* length of sequence */
    char *seq;        /* sequnece (NUL-terminated) */
} SEQUENCE;

SEQUENCE *readsequence(char *fname);
void killsequence(SEQUENCE *seq);

#endif

			</file>
			<file name="readinputdata.c" type="text">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;readinputdata.h&quot;

/*
  master routine - read all the input file
  Parmas: fname - path to main input file
  Returns: input data, 0 on fail
 */
INPUTDATA *readinputdata(char *fname)
{
    INPUTDATA *id;

    printf(&quot;Called with %s\n&quot;, fname);
    id = malloc(sizeof(INPUTDATA));
    if(!id)
	return 0;
    id-&gt;ip = 0;
    id-&gt;cfd = 0;
    id-&gt;ffp = 0;
    id-&gt;seq = 0;
    id-&gt;ip = readinputparams(fname);
    printf(&quot;loaded input\n&quot;);
    if(!id-&gt;ip)
	goto error_exit;
    id-&gt;cfd = readconformerset(id-&gt;ip-&gt;oppang);
    if(!id-&gt;cfd)
        goto error_exit;
    printf(&quot;Loaded conformer set\n&quot;);
    id-&gt;ffp = readforcefieldparams(id-&gt;ip-&gt;ffffil);
    if(!id-&gt;ffp)
	goto error_exit;
    printf(&quot;loaded forcefield\n&quot;);
    id-&gt;seq = readsequence(id-&gt;ip-&gt;seqbas);
    if(!id-&gt;seq)
	goto error_exit;
    printf(&quot;loaded sequence\n&quot;);

    id-&gt;conf = 0;

    return id;
 error_exit:
    killinputdata(id);
    return 0;
}

/*
  input data destructor
 */
void killinputdata(INPUTDATA *id)
{
    if(id)
    {
        killforcefieldparams(id-&gt;ffp);
        killconformerset(id-&gt;cfd);
        killsequence(id-&gt;seq);
        killinputparams(id-&gt;ip);
        killconformers(id-&gt;conf);
	free(id);
    }
}

			</file>
			<file name="readconformerset.c" type="text">
/*
  load a backbone torsion file
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;math.h&gt;
#include &lt;assert.h&gt;

typedef struct
{
    double omega;            /* omega angle */
    double phi;              /* phi (degrees) */
    double psi;               /* psi (degrees) */
    int id;                  /* identifier (1 based) */
    char secondary;          /* secondary structure type */
} CONFORMERDESC;

typedef struct
{
    char id;                /* Amino acid 1-letter code */
    int Nconformers;        /* number of conformers in angle set */ 
    CONFORMERDESC *conf;        /* the conformers */ 
} AA_CONFSET;

typedef struct 
{
    AA_CONFSET aa_conf[20];     /* 20 conformer sets */
} CONFORMERSET;


CONFORMERSET *readconformerset(char *path);
void killconformerset(CONFORMERSET *cs);
int getNconformers(CONFORMERSET *cs, char aa);
int getconformer(CONFORMERSET *cs, char aa, int id, float *omega, float *phi, float *psi, char *secondary);
int getconformeri(CONFORMERSET *cs, int aaidx, int id, float *omega, float *phi, float *psi, char *secondary);


static CONFORMERSET *createconformerset(void);
static int versionok(FILE *fp);
static int parseacid(FILE *fp, CONFORMERSET *cs);
static int nextline(char *buff, int N, FILE *fp);
static void singlespace(char *str);
static void trim(char *str);

/*
  read a backbone torsion angle conformer file
  Params: path - path to file
  Returns: conformer information, 0 on fail 
 */
CONFORMERSET *readconformerset(char *path)
{
    FILE *fp;
    CONFORMERSET *answer;
    int res;

    fp = fopen(path, &quot;r&quot;);
    if(!fp)
	return 0;

    if(!versionok(fp))
    {
        fclose(fp);
	return 0;
    }

    answer = createconformerset();
    if(!answer)
	return 0;

    while( (res = parseacid(fp, answer)) )
    {
	if(res &lt; 0)
        {
	    fclose(fp);
            killconformerset(answer);
            return 0;
	}
    }

    fclose(fp);

    return answer;
}

CONFORMERSET *cset_clone(CONFORMERSET *cs)
{
    CONFORMERSET *answer;
    int i;

    answer = createconformerset();
    if(!answer)
	goto error_exit;
    for(i=0;i&lt;20;i++)
    {
	answer-&gt;aa_conf[i].conf = malloc(cs-&gt;aa_conf[i].Nconformers * sizeof(CONFORMERDESC));
        if(!answer-&gt;aa_conf[i].conf)
	    goto error_exit;
        answer-&gt;aa_conf[i].Nconformers = cs-&gt;aa_conf[i].Nconformers;
        memcpy(answer-&gt;aa_conf[i].conf, cs-&gt;aa_conf[i].conf, cs-&gt;aa_conf[i].Nconformers * sizeof(CONFORMERDESC));
    }
    return answer;

 error_exit:
    killconformerset(answer);
    return 0;
}
/*
  conformer set destructor
  Params: cs - object to destroy
 */
void killconformerset(CONFORMERSET *cs)
{
    int i;

    if(cs)
    {
      for(i=0;i&lt;20;i++)
	free(cs-&gt;aa_conf[i].conf);
      free(cs);
    }
}

/*
  get number of angle in angle set for an amino acid
  Params: cs - the conformerset object
         aa - id of amino acid
  Returns: number of conformers, -1 on fail
 */
int getNconformers(CONFORMERSET *cs, char aa)
{
    int i;

    for(i=0;i&lt;20;i++)
	if(cs-&gt;aa_conf[i].id == aa)
	    return cs-&gt;aa_conf[i].Nconformers;

    return -1;
}

/*
  get the conformer
  Params: cs - the conformerset object
          aa - 1 letter id of amino acid type
          id - index of conformer (1-based)
          omega - return pointer for omega (cis/trans)
          phi - return pointer for phi
          psi - return pointer for psi
          secondary - return pointer for secondary structure
  Returns: 0 on success, -1 on fail
  Notes:
    secondary structure &apos; &apos; = coil, &apos;H&apos; = helix, &apos;B&apos; = sheet
    angles are returned in degrees
 */
int getconformer(CONFORMERSET *cs, char aa, int id, float *omega, float *phi, float *psi, char *secondary)
{
    int i;
    int ii;

    for(i=0;i&lt;20;i++)
	if(cs-&gt;aa_conf[i].id == aa)
        {
	    for(ii=0;ii&lt;cs-&gt;aa_conf[i].Nconformers;ii++)
		if(cs-&gt;aa_conf[i].conf[ii].id == id)
                {
		    *omega = (float) cs-&gt;aa_conf[i].conf[ii].omega;
                    *phi = (float) cs-&gt;aa_conf[i].conf[ii].phi;
                    *psi = (float) cs-&gt;aa_conf[i].conf[ii].psi;
                    *secondary = cs-&gt;aa_conf[i].conf[ii].secondary;
                    return 0;    
                }
	}
    return -1;
}

/*
  get the conformer
  Params: cs - the conformerset object
          aaidx - alpahbetical 1 letter index  amino acid type
          id - index of conformer (1-based)
          omega - return pointer for omega (cis/trans)
          phi - return pointer for phi
          psi - return pointer for psi
          secondary - return pointer for secondary structure
  Returns: 0 on success, -1 on fail
  Notes:
    secondary structure &apos; &apos; = coil, &apos;H&apos; = helix, &apos;B&apos; = sheet
    angles are returned in degrees
 */
int getconformeri(CONFORMERSET *cs, int aaidx, int id, float *omega, float *phi, float *psi, char *secondary)
{
  assert(id &gt;= 1 &amp;&amp; id &lt;= 6);
  *omega = (float) cs-&gt;aa_conf[aaidx].conf[id-1].omega;
  *phi = (float) cs-&gt;aa_conf[aaidx].conf[id-1].phi;
  *psi = (float) cs-&gt;aa_conf[aaidx].conf[id-1].psi;
  *secondary = cs-&gt;aa_conf[aaidx].conf[id-1].secondary;
  return 0;                 
}

/*
  create an empty conformer set
  Returns: constructed object
  Notes: currently hardcode the twenty amino acids
 */
static CONFORMERSET *createconformerset(void)
{
    CONFORMERSET *answer;
    static char *aacids = &quot;ACDEFGHIKLMNPQRSTVWY&quot;;
    int i;

    answer = malloc(sizeof(CONFORMERSET));
    if(!answer)
	return 0;
    for(i=0;i&lt;20;i++)
    {
	answer-&gt;aa_conf[i].id = aacids[i];
        answer-&gt;aa_conf[i].Nconformers = 0;
        answer-&gt;aa_conf[i].conf = 0;
    }

    return answer;
}

/*
  is the version of the conformer file OK ?
  Parmas: fp - pointer to an open file
  Returns: 1 if version information read correctly, 0 if unrecognised
 */
static int versionok(FILE *fp)
{
    char buff[1024];
    char tag[32];
    float version;

    if(fgets(buff, 1024, fp) == 0)
	return 0;
    trim(buff);
    singlespace(buff);
    if(strcmp(buff, &quot;%BACKBONE TORSION LIBRARY&quot;))
	return 0;
    if(fgets(buff, 1024, fp) == 0)
	return 0;
    sscanf(buff, &quot;%32s %f&quot;, tag, &amp;version);
    trim(buff);
    if(strcmp(tag, &quot;%VERSION&quot;))
	return 0;
    if(floor( (double) version) == 2.0)
	return 1;
    return 0; 
}

/*
  parse an acid record
  Parmas: fp - pointer to an open file
          cs - structure to hold data
  Returns: 1 on success, 0 on EOF, -1 on error 
 */
static int parseacid(FILE *fp, CONFORMERSET *cs)
{
    char buff[1024];
    int i;
    char aa;
    int N;
    int res;
    char sec;
    float omega;
    float phi;
    float psi;
    int aaindex;

    res = nextline(buff, 1024, fp);
    if(res == 0)
	return 0;
    if(sscanf(buff, &quot;%c %d&quot;, &amp;aa, &amp;N) != 2)
       return -1;
    for(aaindex=0;aaindex&lt;20;aaindex++)
	if(cs-&gt;aa_conf[aaindex].id == aa)
	    break;
    if(aaindex == 20)
	return -1;
    if(cs-&gt;aa_conf[aaindex].conf != 0)
	return -1;
    cs-&gt;aa_conf[aaindex].conf = malloc(N * sizeof(CONFORMERDESC));
    if(!cs-&gt;aa_conf[aaindex].conf)
	return -1;
    cs-&gt;aa_conf[aaindex].Nconformers = N;
    for(i=0;i&lt;N;i++)
    {
	res = nextline(buff, 1024, fp);
        if(res == 0)
	    return -1;
        res = sscanf(buff, &quot; %f %f %f %c\n&quot;, &amp;omega, &amp;phi, &amp;psi, &amp;sec);
        if(res != 3 &amp;&amp; res != 4)
          return -1;
        if(res == 3)
          sec = &apos; &apos;;
        cs-&gt;aa_conf[aaindex].conf[i].id = i+1;
        cs-&gt;aa_conf[aaindex].conf[i].omega = omega;
        cs-&gt;aa_conf[aaindex].conf[i].phi = phi;
        cs-&gt;aa_conf[aaindex].conf[i].psi = psi;
        cs-&gt;aa_conf[aaindex].conf[i].secondary = sec;
    } 
    return 1;
}

/*
  get the next line  
  Params: buff - return pointer for line
          N - buffer capacity
          fp - pointer to an open file
  Returns: 1 on success, 0 on EOF
  Notes: mainly a filter to ignore comments   
*/
static int nextline(char *buff, int N, FILE *fp)
{
  char *res;

  do
  {
      res = fgets(buff, N, fp);
      if(res == 0)
	  return 0;
  } while(buff[0] == &apos;#&apos;);

  return 1;
} 

/*
  replace all runs of whitespace in a string by single space characters.
  Parmas: str - the string to treat.
*/
static void singlespace(char *str)
{
    char *ptr;
    
    ptr = str;

    do
    {
      if(isspace(*ptr))
      {
	 *str++ = &apos; &apos;;
         while(isspace(*ptr))
	    ptr++;
      }
      else
	  *str++ = *ptr++;
    }
    while(*ptr);
} 

/*
  trim leading and trailing whitespace from a string
  Params: str - the string to trim
 */
static void trim(char *str)
{
    char *ptr;
    char *ptr2;

    ptr = str;
    while(isspace(*ptr))
	ptr++;
    ptr2 = str;
    while(*ptr)
	*ptr2++ = *ptr++;
    *ptr2 = 0;
    
    while(ptr2-- &gt; str)
    {
	if(isspace(*ptr2))
	    *ptr2 = 0;
        else
	    break;
    }
}


int torsionmain(int argc, char **argv)
{
    CONFORMERSET *cs;
    int i;
    int ii;
    char *aacids = &quot;ACDEFGHIKLMNPQRSTVWY&quot;;
    float omega, phi, psi;
    char sec;
    int N;

    cs = readconformerset(argv[1]);
    if(!cs)
    {
	printf(&quot;Failed\n&quot;);
        exit(EXIT_FAILURE);
    }

    for(i=0;i&lt;20;i++)
    {
	N = getNconformers(cs, aacids[i]);
      printf(&quot;residue %c: %d\n&quot;,aacids[i],  N);
      for(ii=0;ii&lt;N;ii++)
      {
	  getconformer(cs, aacids[i], ii+1, &amp;omega, &amp;phi, &amp;psi, &amp;sec);
          printf(&quot;%f %f %f [%c]\n&quot;, omega, phi, psi, sec);
      }
      printf(&quot;\n&quot;);
    }
   
    return 0;
}

			</file>
			<file name="rotmtx.h" type="text">
#ifndef rotmtx_h
#define rotmtx_h

void rotmat(double eua, double eub, double eug, double rot[3][3]);

#endif

			</file>
			<file name="readfff.c" type="text">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;readfff.h&quot;

static int  rearrange(FORCEFIELDPARAMS *ffp);

/* reads in force field file using path to the file. returns force field parameters */

FORCEFIELDPARAMS *readforcefieldparams(char *fname)
{
FILE *fp; 
FORCEFIELDPARAMS *ffp;
char buff[1024];
int N;
int i,j;
char aaid;
int nbalrs;
char type;
float rad,pos,pot,hard,nnlen,nplen,radf;
fp=fopen(fname,&quot;r&quot;);
if(fp==0)
   return 0;
ffp=malloc(sizeof(FORCEFIELDPARAMS));
if(ffp==0)
   return 0;

fgets(buff,1024,fp);
fgets(buff,1024,fp);
while(fgets(buff,1024,fp)!=0)
   if(buff[0]!=&apos;#&apos;)
      break;
if(sscanf(buff,&quot;%d&quot;,&amp;N)!=1)goto error_exit;
if(N&lt;1)goto error_exit;
ffp-&gt;N=N;
ffp-&gt;res=malloc(sizeof(FFFRES)*N);

if(ffp-&gt;res==0)goto error_exit;
for(i=0;i&lt;N;i++)
{
   if(fscanf(fp,&quot;%c %d\n&quot;,&amp;aaid,&amp;nbalrs)!=2)
   goto error_exit;
   if(nbalrs&lt;1)goto error_exit;
   ffp-&gt;res[i].aaid=aaid;
   ffp-&gt;res[i].Nballs=nbalrs;
   ffp-&gt;res[i].ball=malloc(sizeof(FFFBALL)*nbalrs);
   if(ffp-&gt;res[i].ball==0)goto error_exit;
   for(j=0;j&lt;nbalrs;j++)
   {
    if(fscanf(fp,&quot; %c %f %f %f %f %f %f %f \n&quot;,&amp;type,&amp;rad,&amp;pos,&amp;pot,&amp;hard,&amp;nnlen,&amp;nplen,&amp;radf)!=8)
    goto error_exit;
    ffp-&gt;res[i].ball[j].type=type;
    ffp-&gt;res[i].ball[j].radius=rad;
    ffp-&gt;res[i].ball[j].vector_pos=pos;
    ffp-&gt;res[i].ball[j].potential=pot;
    ffp-&gt;res[i].ball[j].hardness=hard;
    ffp-&gt;res[i].ball[j].NN_length=nnlen;
    ffp-&gt;res[i].ball[j].NP_length=nplen;
    ffp-&gt;res[i].ball[j].Rad_factor=radf;
    }
}
fclose(fp);
 fp = 0;
 if(rearrange(ffp) == -1)
   goto error_exit;

return ffp;

error_exit:
if(fp!=0)fclose(fp);
killforcefieldparams(ffp);
return 0;

}

FORCEFIELDPARAMS *ffp_clone(FORCEFIELDPARAMS *ffp)
{
    FORCEFIELDPARAMS *answer;
    int i;

    answer = malloc(sizeof(FORCEFIELDPARAMS));
    if(!answer)
	goto error_exit;
    answer-&gt;res = malloc(sizeof(FFFRES) * ffp-&gt;N);
    if(!answer-&gt;res)
	goto error_exit;
    for(i=0;i&lt;ffp-&gt;N;i++)
	answer-&gt;res[i].ball = 0;
    for(i=0;i&lt;ffp-&gt;N;i++)
    {
	answer-&gt;res[i].ball = malloc(sizeof(FFFBALL) * ffp-&gt;res[i].Nballs);
        if(!answer-&gt;res[i].ball)
	    goto error_exit;
        memcpy(answer-&gt;res[i].ball, ffp-&gt;res[i].ball, ffp-&gt;res[i].Nballs * sizeof(FFFBALL));
        answer-&gt;res[i].Nballs = ffp-&gt;res[i].Nballs;
        answer-&gt;res[i].aaid = ffp-&gt;res[i].aaid; 
    }
    answer-&gt;N = ffp-&gt;N;
    return answer;

 error_exit:
    killforcefieldparams(answer);
    return 0;
}

/* kills force field reader */

void killforcefieldparams(FORCEFIELDPARAMS *ffp)
{
int i;
if(ffp!=0)
   {
    if(ffp-&gt;res!=0)
       {
       for(i=0;i&lt;ffp-&gt;N;i++)
          free(ffp-&gt;res[i].ball);
       }
    free(ffp-&gt;res); 
   }
free(ffp);
}

/*
  rearrange balls in order D A B X X [ X = N or P ]
  Returns: 0 on success, -1 on fail
 */
static int  rearrange(FORCEFIELDPARAMS *ffp)
{
    int i;
    int j;
    FFFBALL ffftemp;
    for(i=0;i&lt;ffp-&gt;N;i++)
    {
	for(j=0;j&lt;ffp-&gt;res[i].Nballs;j++)
	    if(ffp-&gt;res[i].ball[j].type == &apos;D&apos;)
		break;
        if(j == ffp-&gt;res[i].Nballs)
	    return -1;
       ffftemp = ffp-&gt;res[i].ball[j];
       ffp-&gt;res[i].ball[j] = ffp-&gt;res[i].ball[0];
       ffp-&gt;res[i].ball[0] = ffftemp;

       for(j=0;j&lt;ffp-&gt;res[i].Nballs;j++)
	    if(ffp-&gt;res[i].ball[j].type == &apos;A&apos;)
		break;
        if(j == ffp-&gt;res[i].Nballs)
	    return -1;
       ffftemp = ffp-&gt;res[i].ball[j];
       ffp-&gt;res[i].ball[j] = ffp-&gt;res[i].ball[1];
       ffp-&gt;res[i].ball[1] = ffftemp;

      for(j=0;j&lt;ffp-&gt;res[i].Nballs;j++)
	    if(ffp-&gt;res[i].ball[j].type == &apos;B&apos;)
		break;
        if(j == ffp-&gt;res[i].Nballs)
	    return -1;
       ffftemp = ffp-&gt;res[i].ball[j];
       ffp-&gt;res[i].ball[j] = ffp-&gt;res[i].ball[2];
       ffp-&gt;res[i].ball[2] = ffftemp;

   
    }
    return 0;
}









			</file>
			<file name="readconformer.h" type="text">
#ifndef readconformer_h
#define readconformer_h

typedef struct
{
    int *angs;
    int len;
    double rot[3];
    double trans[3];
} CONFORMER;

typedef struct
{
    int N;
    CONFORMER *conf;
} CONFORMERS;

CONFORMERS *readconformers(char *fname);
void killconformers(CONFORMERS *cs);

#endif

			</file>
			<file name="angpot.h" type="text">
#ifndef angpot_h
#define angpot_h

extern float ephi1[12][20];
extern float ephi2[12][20];
extern float etheta[10][20];
extern float ephi12[12][12][20];
extern float ethph1[12][10][20];
extern float ethph2[12][10][20];
extern float phi1rg[12][2];
extern float phi2rg[12][2];
extern float thetrg[10][2];

#endif

			</file>
			<file name="bbone.h" type="text">
#ifndef bbone_h
#define bbone_h

void bbone(double vnh[][3], double vo[][3], double va[][3], double vb[][3], double vn[][3], double vc[][3], double *phi, double *psi, double *omega, int N);

#endif

			</file>
			<file name="readinput.c" type="text">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
 
#include &quot;readinput.h&quot;

static char *getpath(char *line, char *name);
static void trim(char *str);
static char *mystrdup(const char *str);

/*
  read the input parameters file
  Params: fname - path to input parameters file
  Returns: input parameters, 0 on fail
 */
INPUTPARAMS *readinputparams(char *fname)
{
  FILE *fp;
  INPUTPARAMS *ip;
  char buff[1024];

  fp = fopen(fname, &quot;r&quot;);
  if(!fp)
    return 0;
  ip = malloc(sizeof(INPUTPARAMS));
  if(!ip)
    goto error_exit;


  while(fgets(buff, 1024, fp) != 0)
  {
    if(buff[0] == &apos;#&apos;)
      continue;
    else if(!strncmp(buff,&quot;grddim&quot;, 6))
    {
      if(sscanf(buff, &quot;grddim %d\n&quot;, &amp;ip-&gt;grddim) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;cellen&quot;, 6))
    {
      if(sscanf(buff, &quot;cellen %f\n&quot;, &amp;ip-&gt;cellen) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;delang&quot;, 6))
    {
      if(sscanf(buff, &quot;delang %f\n&quot;, &amp;ip-&gt;delang) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;numcnf&quot;, 6))
    {
      if(sscanf(buff, &quot;numcnf %d\n&quot;, &amp;ip-&gt;numcnf) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;numsim&quot;, 6))
    {
      if(sscanf(buff, &quot;numsim %d\n&quot;, &amp;ip-&gt;numsim) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;initmp&quot;, 6))
    {
      if(sscanf(buff, &quot;initmp %f\n&quot;, &amp;ip-&gt;initmp) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;tsteps&quot;, 6))
    {
      if(sscanf(buff, &quot;tsteps %d\n&quot;, &amp;ip-&gt;tsteps) != 1)
        goto error_exit;
      printf(&quot;Tsteps %d\n&quot;, ip-&gt;tsteps);
    }
    else if(!strncmp(buff,&quot;tmpfac&quot;, 6))
    {
      if(sscanf(buff, &quot;tmpfac %f\n&quot;, &amp;ip-&gt;tmpfac) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;seed&quot;, 4))
    {
      if(sscanf(buff, &quot;seed %d\n&quot;, &amp;ip-&gt;seed) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;mutlim&quot;, 6))
    {
      if(sscanf(buff, &quot;mutlim %d\n&quot;, &amp;ip-&gt;mutlim) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;maxmut&quot;, 6))
    {
      if(sscanf(buff, &quot;maxmut %f\n&quot;, &amp;ip-&gt;maxmut) != 1)
        goto error_exit;
      printf(&quot;Max mut %f\n&quot;, ip-&gt;maxmut);
    }
    else if(!strncmp(buff,&quot;nlimit&quot;, 6))
    {
      if(sscanf(buff, &quot;nlimit %d\n&quot;, &amp;ip-&gt;nlimit) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;krdang&quot;, 6))
    {
      if(sscanf(buff, &quot;krdang %d\n&quot;, &amp;ip-&gt;krdang) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;oppang&quot;, 6))
    {
      ip-&gt;oppang = getpath(buff, &quot;oppang&quot;);
      if(!ip-&gt;oppang)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;krdbsq&quot;, 6))
    {
      if(sscanf(buff, &quot;krdbsq %d\n&quot;, &amp;ip-&gt;krdbsq) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;seqbas&quot;, 6))
    {
      ip-&gt;seqbas = getpath(buff, &quot;seqbas&quot;);
      if(!ip-&gt;seqbas)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;krdfff&quot;, 6))
    {
      if(sscanf(buff, &quot;krdfff %d\n&quot;, &amp;ip-&gt;krdfff) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;ffffil&quot;, 6))
    {
      ip-&gt;ffffil = getpath(buff, &quot;ffffil&quot;);
      if(!ip-&gt;ffffil)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;outfil&quot;, 6))
    {
      ip-&gt;outfil = getpath(buff, &quot;outfil&quot;);
      if(!ip-&gt;outfil)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;iexseq&quot;, 6))
    {
      if(sscanf(buff, &quot;iexseq %d\n&quot;, &amp;ip-&gt;iexseq) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;hsecel&quot;, 6))
    {
      if(sscanf(buff, &quot;hsecel %d\n&quot;, &amp;ip-&gt;hsecel) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;khonly&quot;, 6))
    {
      if(sscanf(buff, &quot;khonly %d\n&quot;, &amp;ip-&gt;khonly) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;exhben&quot;, 6))
    {
      if(sscanf(buff, &quot;exhben %f\n&quot;, &amp;ip-&gt;exhben) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;pinten&quot;, 6))
    {
      if(sscanf(buff, &quot;pinten %f\n&quot;, &amp;ip-&gt;pinten) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;aascal&quot;, 6))
    {
      if(sscanf(buff, &quot;aascal %f\n&quot;, &amp;ip-&gt;aascal) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;abscal&quot;, 6))
    {
      if(sscanf(buff, &quot;abscal %f\n&quot;, &amp;ip-&gt;abscal) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;bbscal&quot;, 6))
    {
      if(sscanf(buff, &quot;bbscal %f\n&quot;, &amp;ip-&gt;bbscal) != 1)
        goto error_exit;
    }
    else if(!strncmp(buff,&quot;oscal&quot;, 5))
    {
      if(sscanf(buff, &quot;oscal %f\n&quot;, &amp;ip-&gt;oscal) != 1)
        goto error_exit;
    }
    else
    {
      printf(&quot;bad line: %s\n&quot;, buff);
      goto error_exit;
    }
   
  }
  fclose(fp);
  return ip;

 error_exit:
  if(fp)
    fclose(fp);
  printf(&quot;line %s\n&quot;, buff);  
  return 0;
}

/*
  inputparams destructor
 */
void killinputparams(INPUTPARAMS *ip)
{
  if(ip)
  {
    free(ip-&gt;oppang);
    free(ip-&gt;seqbas);
    free(ip-&gt;ffffil);
    free(ip-&gt;outfil);
    free(ip);
  }
}

/*
  extract the path filed form an input file
  Parmas: line - the line of input
          name - name of field
  Returns: the apth, allocated with malloc
 */
static char *getpath(char *line, char *name)
{
  char *ptr;
  char *answer;

  ptr = line + strlen(name);
  answer = mystrdup(ptr);
  if(answer)
    trim(answer);
  return answer;
}

/*
  trim leading and trailing whitespace from a string
  Params: str - the string to trim
 */
static void trim(char *str)
{
    char *ptr;
    char *ptr2;

    ptr = str;
    while(isspace(*ptr))
	ptr++;
    ptr2 = str;
    while(*ptr)
	*ptr2++ = *ptr++;
    *ptr2 = 0;
    
    while(ptr2-- &gt; str)
    {
	if(isspace(*ptr2))
	    *ptr2 = 0;
        else
	    break;
    }
}

/*
  duplicate a string
  Parmas: str - string to dupicate
  Returns: duplicated string allocated with malloc.
 */
static char *mystrdup(const char *str)
{
  char *answer;
  answer = malloc(strlen(str) +1);
  if(answer)
    strcpy(answer, str);
  return answer;
}


int readinputmain(int argc, char **argv)
{
  INPUTPARAMS *ip;

  ip = readinputparams(argv[1]);
  if(!ip)
    printf(&quot;Failed\n&quot;);
  else
  {
    printf(&quot;LOaded\n&quot;);
    printf(&quot;%s\n%s\n%s\n%s\n&quot;, ip-&gt;oppang, 
      ip-&gt;seqbas, ip-&gt;ffffil, ip-&gt;outfil);
  }
  killinputparams(ip);
  return 0;
}

			</file>
			<file name="newpot.c" type="text">
/*
  new potentials.
  Derived from cullpdb_pc20_res3.0_R1.0_d071130_chains4076
  PISCES (Dunbrack) website.
  Column 21 is cis-Proline
 */

float npephi1[12][21] = {
  {0.999, 0.438, 0.619, 0.805, 0.608, 0.257, 0.661, 0.996, 0.777, 1.055, 0.995, 0.482, 0.972, 0.941, 0.756, 0.768, 0.772, 0.964, 0.906, 0.523, -1.452, },
  {-1.687, -1.316, -1.418, -1.673, -1.505, -1.140, -1.473, -1.512, -1.526, -1.656, -1.635, -1.386, -1.000, -1.629, -1.547, -1.380, -1.362, -1.401, -1.553, -1.466, -1.519, },
  {0.057, 0.232, -0.071, 0.018, 0.123, 0.156, 0.066, 0.290, 0.081, 0.172, 0.098, -0.006, 0.193, 0.114, 0.111, -0.068, 0.202, 0.431, -0.081, 0.205, 0.471, },
  {0.735, 0.734, 0.555, 0.916, 0.759, 0.432, 0.805, 0.851, 0.675, 0.790, 0.842, 0.663, 1.208, 0.678, 0.698, 0.550, 0.659, 0.953, 0.800, 0.877, 1.908, },
  {0.949, 0.666, 0.713, 1.013, 0.884, 0.344, 0.809, 1.019, 0.904, 1.016, 0.879, 0.654, 1.371, 0.939, 0.889, 0.728, 0.768, 0.945, 1.029, 0.879, 2.214, },
  {0.418, 0.134, 0.488, 0.569, 0.211, 0.353, 0.248, 0.223, 0.428, 0.423, 0.378, 0.336, 0.364, 0.474, 0.355, 0.256, 0.089, 0.031, 0.248, 0.183, 1.520, },
  {-0.215, -0.633, -0.289, -0.221, -0.603, -0.191, -0.496, -0.762, -0.369, -0.497, -0.404, -0.367, -0.425, -0.357, -0.389, -0.404, -0.604, -0.865, -0.470, -0.656, 1.419, },
  {-0.045, -0.362, -0.300, -0.119, -0.129, -0.196, -0.231, -0.314, -0.325, -0.162, -0.154, -0.269, -0.676, -0.154, -0.266, -0.262, -0.366, -0.351, -0.126, -0.199, 0.535, },
  {0.121, -0.012, -0.025, 0.108, 0.196, -0.277, 0.064, 0.280, 0.042, 0.225, 0.157, -0.003, -0.778, 0.100, 0.075, -0.084, -0.026, 0.211, 0.133, 0.175, 1.215, },
  {1.209, 1.233, 0.892, 1.117, 1.212, 0.569, 1.141, 1.388, 1.151, 1.381, 1.252, 0.985, 0.187, 1.179, 1.213, 0.937, 1.099, 1.245, 1.240, 1.224, 2.455, },
  {2.186, 1.884, 1.725, 1.952, 2.091, 0.721, 1.928, 2.315, 1.871, 2.349, 2.214, 1.693, 1.746, 2.094, 2.013, 1.838, 2.005, 2.150, 2.070, 1.993, 2.773, },
  {1.739, 1.657, 1.259, 1.757, 1.788, 0.948, 1.579, 1.932, 1.636, 2.002, 1.928, 1.158, 1.856, 1.794, 1.672, 1.524, 1.862, 1.842, 1.761, 1.712, 0.238, },
};

float npephi2[12][21] = {
  {0.800, 0.832, 0.696, 0.658, 0.914, 0.783, 0.855, 0.867, 0.566, 0.852, 0.796, 0.861, 0.506, 0.743, 0.758, 0.708, 0.744, 0.774, 0.766, 0.749, 1.139, },
  {-1.682, -1.328, -1.442, -1.662, -1.492, -1.165, -1.447, -1.518, -1.518, -1.612, -1.601, -1.343, -1.271, -1.604, -1.527, -1.434, -1.370, -1.395, -1.556, -1.406, -0.523, },
  {0.090, 0.214, -0.004, 0.080, 0.182, 0.169, 0.067, 0.316, 0.187, 0.101, 0.135, 0.062, -0.207, 0.195, 0.120, -0.024, 0.195, 0.345, 0.040, 0.170, -0.289, },
  {0.938, 0.852, 0.546, 0.829, 0.868, 0.181, 0.588, 1.153, 0.758, 0.843, 0.861, 0.373, 0.790, 0.746, 0.803, 0.609, 0.755, 1.142, 0.937, 0.771, 1.356, },
  {1.039, 0.894, 0.631, 0.983, 0.954, 0.071, 0.829, 1.159, 0.993, 1.086, 0.971, 0.467, 0.970, 0.946, 0.925, 0.870, 0.976, 1.182, 1.045, 0.978, 0.694, },
  {0.488, 0.191, 0.276, 0.433, 0.231, 0.268, 0.306, 0.182, 0.383, 0.353, 0.430, 0.156, 0.392, 0.416, 0.374, 0.402, 0.353, 0.131, 0.319, 0.195, -0.204, },
  {-0.311, -0.654, -0.416, -0.238, -0.559, -0.251, -0.532, -0.676, -0.388, -0.441, -0.416, -0.480, -0.369, -0.342, -0.461, -0.435, -0.571, -0.758, -0.474, -0.618, -0.807, },
  {-0.087, -0.461, -0.175, -0.105, -0.290, -0.188, -0.319, -0.314, -0.250, -0.150, -0.204, -0.198, -0.411, -0.191, -0.212, -0.308, -0.419, -0.430, -0.186, -0.360, -0.964, },
  {0.111, -0.047, 0.062, 0.161, 0.039, -0.071, -0.027, 0.160, -0.034, 0.144, 0.031, -0.025, -0.308, 0.057, -0.006, -0.158, -0.246, 0.109, 0.118, 0.072, -0.165, },
  {1.191, 1.008, 0.946, 1.214, 1.210, 0.449, 1.112, 1.327, 1.043, 1.317, 1.147, 0.921, 0.811, 1.132, 1.087, 0.992, 0.947, 1.155, 1.212, 1.123, 1.269, },
  {2.008, 2.143, 1.737, 2.030, 2.018, 0.921, 2.101, 2.117, 1.843, 2.075, 2.233, 1.567, 1.964, 2.002, 2.012, 1.868, 2.016, 1.906, 2.483, 1.889, 1.269, },
  {1.800, 1.654, 1.686, 1.770, 1.679, 0.956, 1.728, 1.540, 1.587, 1.847, 1.914, 1.788, 1.579, 1.652, 1.769, 1.746, 1.723, 1.496, 1.544, 1.662, 1.908, },
};

float npetheta[10][21] = {
  {6.704, 7.653, 7.354, 6.042, 7.215, 6.778, 7.232, 7.547, 7.772, 6.866, 10.0, 7.735, 7.557, 7.135, 7.310, 6.558, 6.745, 7.787, 10.0, 7.559, 3.936, },
  {4.077, 5.088, 4.540, 3.995, 4.548, 4.361, 4.305, 4.522, 3.788, 4.418, 4.659, 4.426, 3.974, 4.169, 3.914, 4.067, 4.600, 4.705, 4.138, 4.707, 1.084, },
  {-0.590, -0.232, -0.441, -0.559, -0.335, -0.142, -0.371, -0.398, -0.430, -0.534, -0.553, -0.376, -0.376, -0.508, -0.445, -0.493, -0.309, -0.246, -0.496, -0.249, -1.098, },
  {-1.441, -1.228, -1.403, -1.451, -1.307, -1.307, -1.309, -1.245, -1.339, -1.391, -1.363, -1.360, -1.213, -1.396, -1.334, -1.283, -1.200, -1.158, -1.320, -1.256, -1.401, },
  {0.143, -0.166, -0.176, 0.106, -0.086, 0.001, -0.126, -0.095, -0.021, 0.029, 0.069, -0.234, -0.046, 0.006, -0.042, 0.059, -0.034, -0.108, -0.033, -0.090, -0.655, },
  {-0.158, -0.409, -0.264, -0.181, -0.237, -0.169, -0.348, -0.463, -0.321, -0.260, -0.207, -0.273, -0.715, -0.205, -0.311, -0.278, -0.372, -0.513, -0.275, -0.322, 0.957, },
  {0.003, -0.232, 0.012, 0.010, -0.174, -0.254, -0.156, -0.276, -0.157, -0.083, -0.131, -0.033, -0.274, -0.079, -0.122, -0.196, -0.340, -0.390, -0.047, -0.213, 1.569, },
  {0.398, 0.070, 0.457, 0.419, 0.099, -0.040, 0.172, 0.233, 0.213, 0.410, 0.251, 0.304, 0.542, 0.299, 0.210, 0.075, -0.091, 0.041, 0.168, -0.038, 2.396, },
  {1.093, 0.809, 1.236, 1.293, 0.804, 0.494, 0.947, 1.350, 1.191, 1.353, 1.164, 1.083, 1.417, 1.236, 1.195, 0.757, 0.914, 1.127, 1.083, 0.804, 4.342, },
  {3.847, 3.646, 4.342, 3.981, 3.659, 2.385, 3.936, 4.044, 3.870, 4.025, 3.936, 3.836, 3.906, 4.325, 3.769, 3.308, 3.865, 3.758, 3.539, 3.570, 3.426, },
};


			</file>
			<file name="vector.h" type="text">

#ifndef vector_h
#define vector_h

float vang(float *a, float *b, float *c);
void crossproduct(float *ans, float *pt1, float *pt2);
float dot(float *a, float *b);
int normalize(float *v);
void vsub(float *res, float *a, float *b);
float vlen(float *v);
float vdist(float *a, float *b);
float vdist2(float *a, float *b);

#endif

			</file>
			<file name="writeoutput.h" type="text">
#ifndef writeoutput_h
#define writeoutput_h

int writeoutput(char *fname, char *seq, int *cnf, double *rot, double *pos, int Ncnf, float score);

#endif

			</file>
			<file name="rg_localpotential.c" type="text">
/*
  local potential C version.
  Note: essentially a wrapper for locptx() fucntion
  
  arrays are hardcoded in angpot.c giving statistical potentials
  for CA torsion and angle values, per residue type.

 */
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

#include &quot;raftgeometry.h&quot;
#include &quot;angpot.h&quot;
#include &quot;locptx.h&quot;

#define radtodeg(theta) (theta/3.141592653589793 * 180.0)
#include &quot;torsion.h&quot;
#include &quot;vector.h&quot;

/* new potential derived from different dataset */
extern float npephi1[12][21];
extern float npephi2[12][21];
extern float npetheta[10][21];

/* old potential with hacked in cis Proline */
extern float lpephi1[12][21];
extern float lpephi2[12][21];
extern float lpetheta[10][21];
extern float lpephi12[12][12][21];
extern float lpethph1[12][10][21];
extern float lpethph2[12][10][21];


static float localpotential2(char *seq, float *va, float *vb, int N);

static float locptx2(int nres, float *ca, int *apindx, float ephi1[12][21],
	    float ephi2[12][21], float etheta[10][21], float phi1rg[12][2],
		     float phi2rg[12][2], float thetrg[10][2]);

static float locptx3(int nres, float *ca, int *apindx, float ephi1[12][21],
		     float ephi2[12][21], float etheta[10][21],
                     float ephi12[12][12][21], float ethph1[12][10][21],
                     float ethph2[12][10][21],
                     float phi1rg[12][2],
                     float phi2rg[12][2], float thetrg[10][2]);

/*
  apply local to rafgeoemtry item
  Params: rg - the RAFT geometry
  Returns: local potential 
 */
float rg_localpotential(RAFTGEOMETRY *rg)
{
  float answer = 0;
  float hack =0;
  int Nres;
  int i;

  for(i=0;i&lt;rg_getNconformers(rg);i++)
  {
    Nres = rg_getcnflen(rg, i);
    //    hack += localpotential2(rg-&gt;cnf[i].seq, rg-&gt;cnf[i].CA, rg-&gt;cnf[i].CB, Nres); 
    answer += locptx(Nres, rg-&gt;cnf[i].CA, rg-&gt;cnf[i].seqi, ephi1, ephi2, etheta,               ephi12,ethph1, ethph2, phi1rg, phi2rg, thetrg); 
  } 
  //  printf(&quot;%g %g\n&quot;, answer, hack);
 
  return answer;
}

float rg_localpotential2(RAFTGEOMETRY *rg)
{
  float answer = 0;
  int aaidx[1024];
  int Nres;
  int i, ii;
  for(i=0;i&lt;rg_getNconformers(rg);i++)
  {
    Nres = rg_getcnflen(rg, i);
    for(ii=0;ii&lt;Nres;ii++)
    {
      aaidx[ii] = rg-&gt;cnf[i].seqi[ii];
      if(rg-&gt;cnf[i].seq[ii] == &apos;P&apos;)
      {
        if(rg-&gt;cnf[i].angs[ii] &gt; 2)
	  aaidx[ii] = 20;
      }
    }
    answer += locptx2(Nres, rg-&gt;cnf[i].CA, aaidx, npephi1, npephi2, npetheta, phi1rg, phi2rg, thetrg);  
  }
  return answer;
}

float rg_localpotential3(RAFTGEOMETRY *rg)
{
  float answer = 0;
  int aaidx[1024];
  int Nres;
  int i, ii;

  for(i=0;i&lt;rg_getNconformers(rg);i++)
  {
    Nres = rg_getcnflen(rg, i);
    for(ii=0;ii&lt;Nres;ii++)
    {
      aaidx[ii] = rg-&gt;cnf[i].seqi[ii];
      if(rg-&gt;cnf[i].seq[ii] == &apos;P&apos;)
      {
        if(rg-&gt;cnf[i].angs[ii] &gt; 2)
	  aaidx[ii] = 20;
      }
    }
    answer += locptx3(Nres, rg-&gt;cnf[i].CA, aaidx, lpephi1, lpephi2, lpetheta, lpephi12, lpethph1, lpethph2, phi1rg, phi2rg, thetrg);  
  }
  return answer;
}


static float locptx2(int nres, float *ca, int *apindx, float ephi1[12][21],
	    float ephi2[12][21], float etheta[10][21], float phi1rg[12][2],
            float phi2rg[12][2], float thetrg[10][2])
{
  int ires;
  int irnge;
  static float phi[1024];
  static float theta[1024];
  float tenr = 0;
  float p1enr = 0;
  float p2enr = 0;
  float tp1enr = 0;
  float tp2enr = 0;
  float p12enr = 0;
  float totpot; 

  int itheta = 0;
  int iphi1 = 0;
  int  iphi2 = 0;
  int litheta, liphi1, liphi2 = 0;

  assert(nres &lt; 1024);
  
  for(ires = 1; ires &lt; nres-2; ires++)
  {
    assert(apindx[ires] &gt;= 0 &amp;&amp; apindx[ires] &lt; 21);

    phi[ires] = calctorsion( &amp;ca[ires*3-3], &amp;ca[ires*3 ], &amp;ca[ires *3 + 3], &amp;ca[ires*3+6]);
    theta[ires] = vang(&amp;ca[ires*3-3], &amp;ca[ires*3], &amp;ca[ires*3+3]);     
  }
  theta[ires] = vang(&amp;ca[ires*3-3], &amp;ca[ires*3], &amp;ca[ires*3+3]);
  /* dummy torsion) */
  phi[ires] = 3.14/2;
  
  for(ires=1;ires&lt;nres;ires++)
    theta[ires] = radtodeg(theta[ires]);
  for(ires=1;ires&lt;nres-1;ires++)
  {
    phi[ires] = radtodeg(phi[ires]);
    if(phi[ires] &lt; 0)
      phi[ires] += 360.0f;
  }
   
  for(ires=1;ires&lt;nres-1;ires++)
  {
    litheta = itheta;
    liphi1 = iphi1;
    liphi2 = iphi2;

    for(irnge=0;irnge&lt;10;irnge++)
      if(theta[ires] &gt; thetrg[irnge][0] &amp;&amp; theta[ires] &lt;= thetrg[irnge][1])
        break;
    itheta = irnge;

    for(irnge=0;irnge&lt;12;irnge++)
      if(phi[ires] &gt; phi1rg[irnge][0] &amp;&amp; phi[ires] &lt;= phi1rg[irnge][1])
        break;
    iphi1 = irnge;

    for(irnge=0;irnge&lt;12;irnge++)
      if(phi[ires] &gt; phi2rg[irnge][0] &amp;&amp; phi[ires] &lt;= phi2rg[irnge][1])
	 break;
    iphi2 = irnge;

    /* hack - some thetas out of range */
    if(itheta == 10)
    {
      itheta = 9;
    }
    assert(itheta &gt;=0 &amp;&amp; itheta &lt; 10);
    assert(iphi1 &gt;= 0 &amp;&amp; iphi1 &lt; 12);
    assert(iphi2 &gt;= 0 &amp;&amp; iphi2 &lt; 12);

    tenr += etheta[itheta][ apindx[ires] ];
    if(ires &gt; 1)
      p1enr += ephi1[liphi1][ apindx[ires] ]  / 2.0;
    if(ires &gt; 1)
      p2enr += ephi2[liphi2][ apindx[ires-1]] / 2.0;

    /*
    if(ires &gt; 1)
      tp1enr += ethph1[liphi1][itheta][apindx[ires]];
    if(ires &gt; 1) 
      tp2enr += ethph2[liphi2][litheta] [apindx[ires-1]];
    if(ires &gt; 1 &amp;&amp; ires &lt; nres - 2)
      p12enr += ephi12[iphi2][liphi1][apindx[ires]];
    */
  }
  
  totpot = tenr + p1enr + p2enr;
  /* Scale by RT=0.5896. */
  totpot *=  0.5896;
  
  return totpot;
}  

static float locptx3(int nres, float *ca, int *apindx, float ephi1[12][21],
		     float ephi2[12][21], float etheta[10][21],
                     float ephi12[12][12][21], float ethph1[12][10][21],
                     float ethph2[12][10][21],
                     float phi1rg[12][2],
                     float phi2rg[12][2], float thetrg[10][2])
{
  int ires;
  int irnge;
  static float phi[1024];
  static float theta[1024];
  float tenr = 0;
  float p1enr = 0;
  float p2enr = 0;
  float tp1enr = 0;
  float tp2enr = 0;
  float p12enr = 0;
  float totpot; 

  int itheta = 0;
  int iphi1 = 0;
  int  iphi2 = 0;
  int litheta, liphi1, liphi2 = 0;

  assert(nres &lt; 1024);
  
  for(ires = 1; ires &lt; nres-2; ires++)
  {
    assert(apindx[ires] &gt;= 0 &amp;&amp; apindx[ires] &lt; 21);

    phi[ires] = calctorsion( &amp;ca[ires*3-3], &amp;ca[ires*3 ], &amp;ca[ires *3 + 3], &amp;ca[ires*3+6]);
    theta[ires] = vang(&amp;ca[ires*3-3], &amp;ca[ires*3], &amp;ca[ires*3+3]);     
  }
  theta[ires] = vang(&amp;ca[ires*3-3], &amp;ca[ires*3], &amp;ca[ires*3+3]);
  /* dummy torsion) */
  phi[ires] = 3.14/2;
  
  for(ires=1;ires&lt;nres;ires++)
    theta[ires] = radtodeg(theta[ires]);
  for(ires=1;ires&lt;nres-1;ires++)
  {
    phi[ires] = radtodeg(phi[ires]);
    if(phi[ires] &lt; 0)
      phi[ires] += 360.0f;
  }
   
  for(ires=1;ires&lt;nres-1;ires++)
  {
    litheta = itheta;
    liphi1 = iphi1;
    liphi2 = iphi2;

    for(irnge=0;irnge&lt;10;irnge++)
      if(theta[ires] &gt; thetrg[irnge][0] &amp;&amp; theta[ires] &lt;= thetrg[irnge][1])
        break;
    itheta = irnge;

    for(irnge=0;irnge&lt;12;irnge++)
      if(phi[ires] &gt; phi1rg[irnge][0] &amp;&amp; phi[ires] &lt;= phi1rg[irnge][1])
        break;
    iphi1 = irnge;

    for(irnge=0;irnge&lt;12;irnge++)
      if(phi[ires] &gt; phi2rg[irnge][0] &amp;&amp; phi[ires] &lt;= phi2rg[irnge][1])
	 break;
    iphi2 = irnge;

    /* hack - some thetas out of range */
    if(itheta == 10)
    {
      itheta = 9;
    }
    assert(itheta &gt;=0 &amp;&amp; itheta &lt; 10);
    assert(iphi1 &gt;= 0 &amp;&amp; iphi1 &lt; 12);
    assert(iphi2 &gt;= 0 &amp;&amp; iphi2 &lt; 12);

    tenr += etheta[itheta][ apindx[ires] ];
    if(ires &gt; 1)
      p1enr += ephi1[liphi1][ apindx[ires] ]  / 2.0;
    if(ires &gt; 1)
      p2enr += ephi2[liphi2][ apindx[ires-1]] / 2.0;

    if(ires &gt; 1)
      tp1enr += ethph1[liphi1][itheta][apindx[ires]];
    if(ires &gt; 1) 
      tp2enr += ethph2[liphi2][litheta] [apindx[ires-1]];
    if(ires &gt; 1 &amp;&amp; ires &lt; nres - 2)
      p12enr += ephi12[iphi2][liphi1][apindx[ires]];
   
  }
  
  totpot = tenr + p1enr + p2enr + tp1enr + tp2enr + p12enr;
  /* Scale by RT=0.5896. */
  totpot *=  0.5896;
  
  return totpot;
}  

			</file>
			<file name="locptx.h" type="text">

#ifndef locptx_h
#define locptx_h

float locptx(int nres, float *ca, int *apindx, float ephi1[12][20],
	    float ephi2[12][20], float etheta[10][20], 
            float ephi12[12][12][20],float ethph1[12][10][20], 
            float ethph2[12][10][20], float phi1rg[12][2],
	     float phi2rg[12][2], float thetrg[10][2]);


#endif

			</file>
			<file name="raftgeometry.h" type="text">
#ifndef raftgeometry_h
#define raftgeometry_h

#include &quot;readfff.h&quot;
#include &quot;readconformerset.h&quot;

typedef struct
{
    float radius;    /* radius of ball */
    char type;       /* &apos;B&apos; &apos;P&apos; &apos;N&apos; &apos;A&apos; &apos;D&apos; */
    int conformer;   /* index of conformer, zero-based */
    int residue;     /* index of resiud, zero-based */
    float pos[3];    /* Cartesian coords */
    float vecres;    /* distnace from backbone ball */
    float kenres;    /* potential energy */
    float nnlenr;    /* length of Non-polar-non-polar interaction */
    float nplenr;    /* length of polar - non-polar interaction */
    float hardness;  /* steric harness factor */
    int hbonded;     /* flag for whether hydrogen bind made */ 
    int hbondpartner;/* index of hbond partner (residue) */
    int id;          /* ball&apos;s global id in array (for efficiency) */
} RAFTBALL;

typedef struct
{
    char *seq;      /* sequence in one letter ASCII code */
    int *seqi;      /* sequnece in indices (0 = Alanine, 19 = Tyrosine) */
    int *angs;      /* the RAFT reduced angles 1 - 6 */
    char *secondary;/* secondary structure type &apos;H&apos;, &apos;B&apos;, &apos; &apos; */ 
    int len;        /* sequence length */
    int start;      /* does sequence have starting N-termianl ? */
    int end;        /* does sequaence have ending C-terminal ? */ 
    int *Nballs;    /* number of balls for each residue */
    RAFTBALL **balls; /* balls by residue, ballindex */
    float *CA;      /* Carbon alphas */
    float *CB;      /* Carbon betas */
    float trans[3]; /* translation */
    float rot[3];   /* Euler angles rotation */ 
} RAFTCONFORMER;

typedef struct
{
    int Nconformers;      /* Number of conformers in system */
    RAFTCONFORMER *cnf;   /* The conformers */
    RAFTBALL *balls;      /* Global array of balls */
    int Nballs;           /* Total number of balls in system */
    FORCEFIELDPARAMS *ffp;/* Parameters from opt.fff file */
    CONFORMERSET *cs;     /* RAFT angles from bbone_6set_3.lib file */
} RAFTGEOMETRY;

RAFTGEOMETRY *raftgeometry(FORCEFIELDPARAMS *ffp, CONFORMERSET *cs);
void killraftgeometry(RAFTGEOMETRY *rg);
void rg_addconformer(RAFTGEOMETRY *rg, char *seq);
void rg_addfragment(RAFTGEOMETRY *rg, char *seq, int start, int end);
void rg_setconformer(RAFTGEOMETRY *rg, int cnf, int *angles, double *trans, double *rot);
void rg_clearhbonds(RAFTGEOMETRY *rg);

/* return number of conformers in geometry */
#define rg_getNconformers(rg) ( rg-&gt;Nconformers )
/* get the length of a conformer conf - zero-based */
#define rg_getcnflen(rg, conf) ( rg-&gt;cnf[conf].len ) 
/* get the number of balls in a residue conf, res zero-based conformer residue indices */
#define rg_Nballs(rg, conf, res) ( rg-&gt;cnf[conf].Nballs[res] )
char rg_sectype(RAFTGEOMETRY *rg, int cnf, int res);
/* convert conformer, residue, ball indices to a global ball index */
#define rg_getballid(rg, conf, res, ballidx) ( rg-&gt;cnf[conf].balls[res][ballidx].id )

void rg_sethdonor(RAFTGEOMETRY *rg, int ballid);
void rg_sethacceptor(RAFTGEOMETRY *rg, int ballid);
int rg_gethdonor(RAFTGEOMETRY *rg, int ballid);
int rg_gethacceptor(RAFTGEOMETRY *rg, int ballid);

float rg_nnlenr(RAFTGEOMETRY *rg, int ballid);
float rg_nplenr(RAFTGEOMETRY *rg, int ballid);
/* kenres - the ball&apos;s potential energy */
#define rg_kenres(rg, ballid) ( rg-&gt;balls[ballid].kenres )
/* rminrs - the radius */
#define rg_rminrs(rg, ballid) ( rg-&gt;balls[ballid].radius )
float rg_hardrs(RAFTGEOMETRY *rg, int ballid);
/* residue - index of resiude for ball */
#define rg_residue(rg, ballid) ( rg-&gt;balls[ballid].residue )
/* type of ball &apos;B&apos; - backbone, &apos;P&apos; polar, &apos;N&apos; non-polar, &apos;A&apos; acceptor, &apos;D&apos; donor */
#define rg_balltype(rg, ballid) ( rg-&gt;balls[ballid].type )
int rg_charge(RAFTGEOMETRY *rg, int ballid);

float rg_extension(RAFTGEOMETRY *rg, int cnf);

#endif

			</file>
		</directory>
		<file name="calctorsion.c" type="text">
#include &lt;math.h&gt;

#define PI 3.14159265

/*************************************************************************/
/*&gt;REAL phi(REAL xi,REAL yi,REAL zi,REAL xj,REAL yj,REAL zj,
            REAL xk,REAL yk,REAL zk,REAL xl,REAL yl,REAL zl)
   ---------------------------------------------------------
   Input:   REAL    xi,yi,zi    Input coordinates
                    xj,yj,zj
                    xk,yk,zk
                    xl,yl,zl
   Returns: REAL                The torsion angle between the 4 atoms

   Calculates the torsion angle described by 4 sets of coordinates.

   04.03.91 Original    By: ACRM
   16.06.93 Changed float to REAL
*/
double calctorsion(float xi,
         float yi,
         float zi,
         float xj,
         float yj,
         float zj,
         float xk,
         float yk,
         float zk,
         float xl,
         float yl,
         float zl)
{
   float xij,yij,zij,
        xkj,ykj,zkj,
        xkl,ykl,zkl,
        dxi,dyi,dzi,
        gxi,gyi,gzi,
        bi,bk,ct,
        boi2,boj2,
        z1,z2,ap,s,
        bioj,bjoi;

   /* Calculate the vectors C,B,C                                       */
   xij = xi - xj;
   yij = yi - yj;
   zij = zi - zj;
   xkj = xk - xj;
   ykj = yk - yj;
   zkj = zk - zj;
   xkl = xk - xl;
   ykl = yk - yl;
   zkl = zk - zl;

   /* Calculate the normals to the two planes n1 and n2
      this is given as the cross products:
       AB x BC
      --------- = n1
      |AB x BC|

       BC x CD
      --------- = n2
      |BC x CD|
   */
   
   dxi = yij * zkj - zij * ykj;     /* Normal to plane 1                */
   dyi = zij * xkj - xij * zkj;
   dzi = xij * ykj - yij * xkj;
   gxi = zkj * ykl - ykj * zkl;     /* Mormal to plane 2                */
   gyi = xkj * zkl - zkj * xkl;
   gzi = ykj * xkl - xkj * ykl;

   
   /* Calculate the length of the two normals                           */
   bi = dxi * dxi + dyi * dyi + dzi * dzi;
   bk = gxi * gxi + gyi * gyi + gzi * gzi;
   ct = dxi * gxi + dyi * gyi + dzi * gzi;

   boi2 = 1.0f/bi;
   boj2 = 1.0f/bk;
   bi   = (float)sqrt((double)bi);
   bk   = (float)sqrt((double)bk);

   z1   = 1.0f/bi;
   z2   = 1.0f/bk;
   bioj = bi * z2;
   bjoi = bk * z1;
   ct   = ct * z1 * z2;
   if (ct &gt;  1.0f)   ct = 1.0f;
   if (ct &lt; (-1.0f)) ct = -1.0f;
   ap   = acos(ct);

   s = xkj * (dzi * gyi - dyi * gzi)
     + ykj * (dxi * gzi - dzi * gxi)
     + zkj * (dyi * gxi - dxi * gyi);

   if (s &lt; 0.0f) ap = -ap;

   ap = (ap &gt; 0.0) ? PI-ap : -(PI+ap);

   return(ap);
}




		</file>
		<file name="bbone.f" type="text">

      subroutine bbone(vnh, vo, va, vb, vn, vc, phi, psi, omega, N)

      implicit NONE

      integer N
      double precision vnh(3,N), vo(3,N),va(3,N),vb(3,N),
     1  vn(3,N), vc(3,N), psi(N), phi(N), omega(N)

      integer i,j,k,ix,ir
      double precision lac,lcn,lna,lco,lab,lnh
      double precision angacn,angcna,angnac,angaco,angnab,angbac,angcnh
      double precision pi,x,y
      double precision a(3),b(3),c(3),r(3,3)
      double precision vn1,vn2,ac1,ac2,ac3,ac4,ac5,bc1,bc2,vac1,vac2
      double precision vcc1,vcc2,vcc3,vcc4,vcc5,vnhc1,vnhc2
      double precision at1,at2,at3,at4,at5,bt1,bt2,vat1,vat2,vct1
      double precision vct2,vct3,vct4,vct5,vnht1,vnht2
      double precision spsi(1024),cpsi(1024),sphi(1024),cphi(1024)

      if(N .gt. 1024) STOP &apos;Too many residues&apos;

      pi=4*atan(1.0d0)
      angacn=((116.00d0/180.0d0)*pi)
      angcna=((122.00d0/180.0d0)*pi)
      angnac=((111.00d0/180.0d0)*pi)
      angaco=((121.9968d0/180.0d0)*pi)
      angnab=((107.63d0/180.0d0)*pi)
      angbac=((112.81d0/180.0d0)*pi)
      angcnh=((116.00d0/180.0d0)*pi)
      lac=1.5100d0
      lcn=1.3200d0
      lna=1.4600d0
      lco=1.2368d0
      lab=1.5386d0
      lnh=1.0800d0
c-----To reduce the number of calculations performed within the loop, calculate
c     sin/cos factors here for the appropriate vectors. See subroutines alaout
c     and balout for respective explicit vectors.

c-----cis/trans
      vn1=lcn*sin(angacn)
      vn2=lcn*cos(angacn)
c-----cis
      ac1=cos(angnac)*cos(angcna-angacn)
      ac2=cos(angnac)
      ac3=sin(angnac)*sin(angcna-angacn)
      ac4=cos(angnac)*sin(angcna-angacn)
      ac5=sin(angnac)*cos(angcna-angacn)
      bc1=cos(angcna-angacn)
      bc2=sin(angcna-angacn)
      vac1=lna*bc2
      vac2=lna*bc1
      vcc1=lac*ac5
      vcc2=lac*sin(angnac)
      vcc3=lac*ac4
      vcc4=lac*ac3
      vcc5=lac*ac1
      vnhc1=lnh*sin(angacn+angcnh)
      vnhc2=lnh*cos(angacn+angcnh)
c-----trans
      at1=cos(angnac)*cos(angcna+angacn)
      at2=ac2
      at3=sin(angnac)*sin(angcna+angacn)
      at4=cos(angnac)*sin(angcna+angacn)
      at5=sin(angnac)*cos(angcna+angacn)
      bt1=cos(angcna+angacn)
      bt2=sin(angcna+angacn)
      vat1=lna*bt2
      vat2=lna*bt1
      vct1=lac*at5
      vct2=vcc2
      vct3=lac*at4
      vct4=lac*at3
      vct5=lac*at1
      vnht1=lnh*sin(angcnh-angacn)
      vnht2=lnh*cos(angcnh-angacn)

c-----Read phi and psi angles and convert to double precision radians.
c     Also calculate sin/cos of phi and psi for passing into loop.
      do 10 ir=1,N      
         cphi(ir)=cos(phi(ir))
         sphi(ir)=sin(phi(ir))
         cpsi(ir)=cos(psi(ir))
         spsi(ir)=sin(psi(ir))
10    continue

c-----Alpha carbon of residue 1 placed at (0,0,0). Alpha carbon-to-carbonyl carbon
c     vector of residue 1 is placed along the z-axis (+ve direction). Nitrogen-to-
c     alpha carbon vector of residue 1 placed in the +x,-z-plane. 

c-----Calculate the backbone nitrogen, alpha-carbon, carbonyl-carbon, carbonyl-oxygen,
c     and beta-carbon vectors of residue 1.

      vn(1,1)=lna*sin(angnac)
      vn(2,1)=0.0d0
      vn(3,1)=lna*cos(angnac)
      va(1,1)=0.0d0
      va(2,1)=0.0d0
      va(3,1)=0.0d0
      vc(1,1)=0.0d0
      vc(2,1)=0.0d0
      vc(3,1)=lac
      vo(1,1)=vc(1,1)-(lco*sin(angaco)*cpsi(1))
      vo(2,1)=vc(2,1)-(lco*sin(angaco)*spsi(1))
      vo(3,1)=vc(3,1)-(lco*cos(angaco))

c-----x and z elements of vb calculated using scalar products (using angbac and angnab
c     along with the vn and vc vectors). y element obtained using pythagoras.

      vb(3,1)=lab*cos(angbac)
      vb(1,1)=lab*((cos(angnab)-cos(angnac)*cos(angbac))/sin(angnac))
      vb(2,1)=-sqrt(lab**2-vb(1,1)**2-vb(3,1)**2)

c     The above are not influenced by omega.
c-----Initiate the rotation matrix r to the unit vector I.

      r(1,1)=1.0d0
      r(2,1)=0.0d0
      r(3,1)=0.0d0
      r(1,2)=0.0d0
      r(2,2)=1.0d0
      r(3,2)=0.0d0
      r(1,3)=0.0d0
      r(2,3)=0.0d0
      r(3,3)=1.0d0

c-----xyz coordinate calculation loop.
c     
      do 200 i=2,N 
         do 100 j=1,3

c-----calculate the backbone nitrogen, alpha-carbon, carbonyl-carbon
c     and and nitrogen hydrogen vectors (vn,va,vc,vnh). 

            vn(j,i)=vc(j,i-1)+r(j,1)*(vn1*cpsi(i-1))
     1                 +r(j,2)*(vn1*spsi(i-1))
     2                 +r(j,3)*(-vn2)
            if(idnint(omega(i)-pi).eq.0)then
c-----cis peptide so calculate vectors accordingly.     
               va(j,i)=vn(j,i)+r(j,1)*(vac1*cpsi(i-1))
     1               +r(j,2)*(vac1*spsi(i-1))
     2               +r(j,3)*(vac2)
               vc(j,i)=va(j,i)+r(j,1)*(-(vcc1*cpsi(i-1)*cphi(i))
     1              +(vcc2*spsi(i-1)*sphi(i))
     2              -(vcc3*cpsi(i-1)))
     3              +r(j,2)*(-(vcc1*spsi(i-1)*cphi(i))
     4              -(vcc2*cpsi(i-1)*sphi(i)) 
     5              -(vcc3*spsi(i-1)))  
     6              +r(j,3)*(vcc4*cphi(i)-vcc5)
               vnh(j,i)=vn(j,i)+r(j,1)*(-vnhc1*cpsi(i-1))
     1                +r(j,2)*(-vnhc1*spsi(i-1))
     2                +r(j,3)*(vnhc2) 

c-----calculate the three orthogonal unit vectors a,b,c which initially. lie
c     on the global x,y,z axes, respectively.

               a(j)=r(j,1)*(ac1*cpsi(i-1)*cphi(i)
     1            -ac2*spsi(i-1)*sphi(i)-ac3*cpsi(i-1))
     2              +r(j,2)*(ac1*spsi(i-1)*cphi(i)
     3            +ac2*cpsi(i-1)*sphi(i)-ac3*spsi(i-1))
     4              +r(j,3)*(-ac4*cphi(i)-ac5)
               b(j)=r(j,1)*(bc1*cpsi(i-1)*sphi(i)
     1            +spsi(i-1)*cphi(i))
     2              +r(j,2)*(bc1*spsi(i-1)*sphi(i)
     3            -cpsi(i-1)*cphi(i))
     4              +r(j,3)*(-bc2*sphi(i))
               c(j)=(vc(j,i)-va(j,i))/lac            

            else
c-----trans peptide so calculate vectors accordingly.
               va(j,i)=vn(j,i)+r(j,1)*(-vat1*cpsi(i-1))
     1               +r(j,2)*(-vat1*spsi(i-1))
     2               +r(j,3)*(vat2)
               vc(j,i)=va(j,i)+r(j,1)*((vct1*cpsi(i-1)*cphi(i))
     1              -(vct2*spsi(i-1)*sphi(i))
     2              +(vct3*cpsi(i-1)))
     3              +r(j,2)*((vct1*spsi(i-1)*cphi(i))
     4              +(vct2*cpsi(i-1)*sphi(i))
     5              +(vct3*spsi(i-1)))
     6              +r(j,3)*((vct4*cphi(i))-(vct5))
               vnh(j,i)=vn(j,i)+r(j,1)*(vnht1*cpsi(i-1))
     1                +r(j,2)*(-vnht1*spsi(i-1))
     2                +r(j,3)*(vnht2)

c-----calculate the three orthogonal unit vectors a,b,c which initially lie
c     on the global x,y,z axes, respectively.

               a(j)=r(j,1)*(-at1*cpsi(i-1)*cphi(i)
     1            +at2*spsi(i-1)*sphi(i)+at3*cpsi(i-1))
     2              +r(j,2)*(-at1*spsi(i-1)*cphi(i)
     3            -at2*cpsi(i-1)*sphi(i)+at3*spsi(i-1))
     4              +r(j,3)*(-at4*cphi(i)-at5)
               b(j)=r(j,1)*(-bt1*cpsi(i-1)*sphi(i)
     1            -spsi(i-1)*cphi(i))
     2              +r(j,2)*(-bt1*spsi(i-1)*sphi(i)
     3              +cpsi(i-1)*cphi(i))
     4              +r(j,3)*(-bt2*sphi(i))
               c(j)=(vc(j,i)-va(j,i))/lac

            end if

 100     continue


c-----calculate the next rotation matrix.

         r(1,1)=a(1)
         r(2,1)=a(2)
         r(3,1)=a(3)
         r(1,2)=b(1)
         r(2,2)=b(2)
         r(3,2)=b(3)
         r(1,3)=c(1)
         r(2,3)=c(2)
         r(3,3)=c(3)

c-----calculate the carbonyl-carbon and beta-carbon vector for residue i.

         do 150 k=1,3     
            vo(k,i)=vc(k,i)+r(k,1)*(-lco*sin(angaco)*cpsi(i))
     1               +r(k,2)*(-lco*sin(angaco)*spsi(i))
     2               +r(k,3)*(-lco*cos(angaco))
            vb(k,i)=va(k,i)+r(k,1)*vb(1,1)
     1               +r(k,2)*vb(2,1)
     2               +r(k,3)*vb(3,1) 
 150     continue    
200   continue
      end

		</file>
		<file name="rand250.c" type="text">
/* r250.c	
                the r250 uniform random number algorithm
		Kirkpatrick, S., and E. Stoll, 1981; &quot;A Very Fast
		Shift-Register Sequence Random Number Generator&quot;,
		Journal of Computational Physics, V.40

		also:

		see W.L. Maier, DDJ May 1991



*/
#include &lt;limits.h&gt;

/* defines to allow for 16 or 32 bit integers */
#define BITS 31


#if WORD_BIT == 32
#ifndef BITS
#define BITS	32
#endif
#else
#ifndef BITS
#define BITS    16
#endif
#endif

#if BITS == 31
#define MSB          0x40000000L
#define ALL_BITS     0x7fffffffL
#define HALF_RANGE   0x20000000L
#define STEP         7
#endif

#if BITS == 32
#define MSB          0x80000000L
#define ALL_BITS     0xffffffffL
#define HALF_RANGE   0x40000000L
#define STEP         7
#endif

#if BITS == 16
#define MSB         0x8000
#define ALL_BITS    0xffff
#define HALF_RANGE  0x4000
#define STEP        11
#endif

static unsigned long randlcg();
static long set_seed(long sd);
static long get_seed();

static long seed_val = 1;
static long int quotient  = LONG_MAX / 16807L;
static long int remainder = LONG_MAX % 16807L; 
static unsigned int r250_buffer[ 250 ];
static int r250_index;

void r250_init(int sd)
{
	int j, k;
	unsigned int mask, msb;
	set_seed( sd );
	r250_index = 0;
        for (j = 0; j &lt; 250; j++)      /* fill r250 buffer with BITS-1 bit values */

		r250_buffer[j] = randlcg();



	for (j = 0; j &lt; 250; j++)	/* set some MSBs to 1 */
		if ( randlcg() &gt; HALF_RANGE )
			r250_buffer[j] |= MSB;



	msb = MSB;	        /* turn on diagonal bit */
	mask = ALL_BITS;	/* turn off the leftmost bits */

	for (j = 0; j &lt; BITS; j++)
	{
		k = STEP * j + 3;	/* select a word to operate on */
		r250_buffer[k] &amp;= mask; /* turn off bits left of the diagonal */
		r250_buffer[k] |= msb;	/* turn on the diagonal bit */
		mask &gt;&gt;= 1;
		msb  &gt;&gt;= 1;
	}

}

unsigned int r250()		/* returns a random unsigned integer */
{
	register int	j;
	register unsigned int new_rand;

	if ( r250_index &gt;= 147 )
		j = r250_index - 147;	/* wrap pointer around */
	else
		j = r250_index + 103;

	new_rand = r250_buffer[ r250_index ] ^ r250_buffer[ j ];
	r250_buffer[ r250_index ] = new_rand;

	if ( r250_index &gt;= 249 )	/* increment pointer for next time */
		r250_index = 0;
	else
		r250_index++;

	return new_rand;

}


double dr250()		/* returns a random double in range 0..1 */
{
	register int	j;
	register unsigned int new_rand;

	if ( r250_index &gt;= 147 )
		j = r250_index - 147;	/* wrap pointer around */
	else
		j = r250_index + 103;

	new_rand = r250_buffer[ r250_index ] ^ r250_buffer[ j ];
	r250_buffer[ r250_index ] = new_rand;

	if ( r250_index &gt;= 249 )	/* increment pointer for next time */
		r250_index = 0;
	else
		r250_index++;

	return (double)new_rand / ALL_BITS;
}

static long set_seed(long sd)
{
        return seed_val = sd;
}

static long get_seed()
{
        return seed_val;
}


static unsigned long randlcg()       /* returns a random unsigned integer */
{
        if ( seed_val &lt;= quotient )
                seed_val = (seed_val * 16807L) % LONG_MAX;
        else
        {
                long int high_part = seed_val / quotient;
                long int low_part  = seed_val % quotient;

                long int test = 16807L * low_part - remainder * high_part;

                if ( test &gt; 0 )
                        seed_val = test;
                else
                        seed_val = test + LONG_MAX;

        }

        return seed_val;
}


int main(void)
{
  int i;

  r250_init(100);

  for(i=0;i&lt;100;i++)
    printf(&quot;%g\n&quot;, dr250());

  return 0;
}

		</file>
		<file name="mem.h" type="text">

#ifndef mem_h
#define mem_h

typedef struct blockheader
{
  union block *prev;
  int size;
  union block *nextfree;
  union block *prevfree;
} BLOCKHEADER;

typedef union block
{
  double aligner;
  BLOCKHEADER hdr;
} BLOCK;

typedef struct list_header
{
  struct list_header *next;
} LISTHEADER;

typedef struct
{
  int capacity;
  int size;
  LISTHEADER *mem;
  LISTHEADER *top;
} FIXEDALLOCATOR;

void *salloc(int size);
void sfree(void *ptr);
void initialise_malloc();
void *mymalloc(int size);
void myfree(void *ptr);
FIXEDALLOCATOR *fixedallocator(int capacity, int size);
void killfixedallocator(FIXEDALLOCATOR *fa);
void *fixedallocate(FIXEDALLOCATOR *fa);
void fixedfree(FIXEDALLOCATOR *fa, void *ptr);

#endif

		</file>
		<file name="distancetransform.h" type="text">
#ifndef distancetransform_h
#define distancetransform_h

float *euclideandistancetransform(unsigned char *binary, int width, int height);
int *edt_saito(unsigned char *binary, int width, int height);

#endif

		</file>
		<file name="savejpeg.c" type="text">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include &quot;jpeg.h&quot;

#define SOF0  0xC0 /*  Start Of Frame (baseline JPEG) */
#define SOF1  0xC1 /*   ditto */
#define DHT   0xC4 /*  Define Huffman Table */
#define DQT   0xDB /*  Define Quantization Table */
#define DRI   0xDD /*  Define Restart Interval */
#define APP0  0xE0 /*  JFIF APP0 segment marker */
#define SOI   0xD8 /*  Start Of Image */
#define EOI   0xD9 /*  End Of Image */
#define SOS   0xDA /*  Start Of Scan, for details see below */

typedef struct
{
  char *code;         /* Huffman code in ASCII format */
  int symbol;         /* the symbo, it represents */
} HUFFENTRY;

typedef struct
{
  char **codes;      /* list of codes, indexed by symbol */
  int N;             /* number of codes (not max symbol) */
} HUFFTABLE;

typedef struct
{
  HUFFTABLE *Ydc;         /* luminace DC Huffman table */
  HUFFTABLE *Yac;         /* luminace AC Huffman table */
  HUFFTABLE *Cdc;         /* chrominace DC Huffman table */
  HUFFTABLE *Cac;         /* chrominace AC Huffman table */
  unsigned char qlum[64];   /* luminace qunatisation table */
  unsigned char qchrom[64]; /* chrominance quantisation table */
} TABLES;

typedef struct
{
  FILE *fp;       /* file */
  int rack;       /* byte to write */
  int bit;        /* mask, 0x80 when initialised */
} BITSTREAM;

static TABLES *maketables(unsigned char *buff, int width, int height);
static void killtables(TABLES *tab);

static int saveheader(FILE *fp, TABLES *tab, int width, int height);
static int savescan(FILE *fp, TABLES *tab, unsigned char *buff, int width, int height);
static void rgbtoYuv(unsigned char *block, short *Y0, short *Y1, short *Y2, short *Y3,
			  short *Cb, short *Cr);
static void getblock16x16(unsigned char *block, unsigned char *buff, int width, int height, int x, int y);

static void savesoi(FILE *fp);
static void saveapp0(FILE *fp);
static void savesof0(FILE *fp, int width, int height);
static void savedht(FILE *fp, HUFFTABLE *Ydc, HUFFTABLE *Yac, HUFFTABLE *chromdc, HUFFTABLE *chromac);
static void savedqt(FILE *fp, unsigned char *lum, unsigned char *chrom);
static void savesos(FILE *fp);

static void dct8x8(short *block);
static void fastdct8(short *x);
static void zigzag(short *block);
static void saveblock(short *block, HUFFTABLE *dc, HUFFTABLE *ac, BITSTREAM *bs);
static int inttowrite(int x, int len);
static int symbollen(int x);
static void writehuff(HUFFTABLE *ht, int symbol, BITSTREAM *bs);

static BITSTREAM *bitstream(FILE *fp);
static void killbitstream(BITSTREAM *bs);
static void writebits(BITSTREAM *bs, int x, int bits);
static void putbit(BITSTREAM *bs, int bit);
static void flushbitstream(BITSTREAM *bs);

static void lumqt(unsigned char *qt);
static void chromqt(unsigned char *qt);
static HUFFTABLE *lumdc(void);
static HUFFTABLE *chromdc(void);
static HUFFTABLE *lumac(void);
static HUFFTABLE *chromac(void);

static HUFFTABLE *buildhuff(HUFFENTRY *table, int N);
static killhuff(HUFFTABLE *ht);
static int getlength(HUFFTABLE *ht, int *len);
static int compentries(const void *e1, const void *e2);
static void getsymbols(HUFFTABLE *ht, unsigned char *sym);

static void fput16(int x, FILE *fp);
static char *mystrdup(const char *str);

/*
  save a 24-bit colour image in JPEG format
  Params: path - name of file to save
          rgb - the raster data
		  width - image width
		  height - image height
  Returns: 0 on success, -1 on fail
*/
int savejpeg(char *path, unsigned char *rgb, int width, int height)
{
  FILE *fp;
  int answer;
  TABLES *tables;

  tables = maketables(rgb, width, height);
  if(!tables)
	return -1;

  fp = fopen(path, &quot;wb&quot;);
  if(!fp)
	return -1;
  saveheader(fp, tables, width, height);
  if( savescan(fp, tables, rgb, width, height) == -1)
  {
	killtables(tables);
    return -1;
  }

  killtables(tables);

  answer = ferror(fp);
  
  if( fclose(fp) == -1)
	return -1;

  return answer;
}

/*
  create the tables we use for the JPEG codec
  Params: buff - the image
         width - image width
		 height - image height
  Returns: a tables structure with quantisation and Huffman tables
  Notes: currently uses default baseline tables
    and ignores the parameters
*/
static TABLES *maketables(unsigned char *buff, int width, int height)
{
  TABLES *answer;

  answer = malloc(sizeof(TABLES));

  answer-&gt;Ydc = lumdc();
  answer-&gt;Yac = lumac();
  answer-&gt;Cdc = chromdc();
  answer-&gt;Cac = chromac();

  if(!answer-&gt;Ydc || !answer-&gt;Yac || !answer-&gt;Cdc || !answer-&gt;Cac)
  {
    killtables(answer);
	return 0;
  }
  
  lumqt(answer-&gt;qlum);
  chromqt(answer-&gt;qchrom);

  return answer;
}

/*
  destroy tables
  Parmas: tab - structure to destroy
*/
static void killtables(TABLES *tab)
{
  if(tab)
  {
    killhuff(tab-&gt;Ydc);
	killhuff(tab-&gt;Yac);
	killhuff(tab-&gt;Cdc);
	killhuff(tab-&gt;Cac);
    free(tab);
  }
}

/*
  save the header information
  Params: fp - pointer to an open file
          tab - the tables 
		  width - image width
		  height - image height
  Returns: 0 on success, -1 on fail
*/
static int saveheader(FILE *fp, TABLES *tab, int width, int height)
{
  savesoi(fp);
  saveapp0(fp);
  savedqt(fp, tab-&gt;qlum, tab-&gt;qchrom);
  savesof0(fp, width, height);
  savedht(fp, tab-&gt;Ydc, tab-&gt;Yac, tab-&gt;Cdc, tab-&gt;Cac);
  savesos(fp);

  return 0;
}

/*
  save the scan information
  Parmas: fp -pointer to open file
          tab - the tables used for the image
		  buff - rgb input buffer
		  width - image width
		  height - image height
*/
static int savescan(FILE *fp, TABLES *tab, unsigned char *buff, int width, int height)
{
  int i;
  int ii;
  int iii;
  int iv;
  short lum[4][64];  /* blocks for luminance */
  short Cb[64];      /* block for blue chrominance */
  short Cr[64];      /* block for red chrominance */
  BITSTREAM *bs;
  unsigned char *block; /* buffer for 16 x 16 block */
  int olddcy = 0;       /* keep track of luminace dc */
  int olddcb = 0;       /* keep track of Cb dc */
  int olddcr = 0;       /* keep track of Cr dc */

  block = malloc(16 * 16 * 3);
  if(!block)
	return -1;

  bs = bitstream(fp);
  if(!bs)
  {
    free(block);
	return -1;
  }

  for(i=0;i&lt;height;i+=16)
	for(ii=0;ii&lt;width;ii+=16)
	{
      getblock16x16(block, buff, width, height, ii, i);
      rgbtoYuv(block, lum[0], lum[1], lum[2], lum[3], Cb, Cr);

	  /* four luminace blocks encoded first */
	  for(iii=0;iii&lt;4;iii++)
      {
		dct8x8(lum[iii]);
		zigzag(lum[iii]);

		for(iv=0;iv&lt;64;iv++)
		  lum[iii][iv] /= tab-&gt;qlum[iv];
		lum[iii][0] -= olddcy;
		olddcy += lum[iii][0];
		saveblock(lum[iii], tab-&gt;Ydc, tab-&gt;Yac, bs);
      }
	  
      /* blue chrominance block */
	  dct8x8(Cb);
	  zigzag(Cb);
	  for(iv=0;iv&lt;64;iv++)
		Cb[iv] /= tab-&gt;qchrom[iv];
	  Cb[0] -= olddcb;
	  olddcb += Cb[0];
	  saveblock(Cb, tab-&gt;Cdc, tab-&gt;Cac, bs);
  
	  /* red chrominance block */
	  dct8x8(Cr);
	  zigzag(Cr);
	  for(iv=0;iv&lt;64;iv++)
		Cr[iv] /= tab-&gt;qchrom[iv];
	  Cr[0] -= olddcr;
	  olddcr += Cr[0];
	  saveblock(Cr, tab-&gt;Cdc, tab-&gt;Cac, bs);
	}

  flushbitstream(bs);
  killbitstream(bs);
  free(block);

  /* save EOI marker */
  fputc(0xFF, fp);
  fputc(EOI, fp);

  return 0;
}

/*
  convert a 16 x 16 block to Yuv colur space
  Params: block - the rgb block
          Y0 - return pointer for first chrominance block
		  Y1 - return pointer for second chrominance block 
		  Y2 - return pointer for thrid chrominace block
		  Cb - return pointer for blue chrominace
		  Cr - return pointer for red chrominance
*/
static void rgbtoYuv(unsigned char *block, 
			  short *Y0, short *Y1, short *Y2, short *Y3,
			  short *Cb, short *Cr)
{
   double lum;
   double cb = 0;
   double cr = 0;
   int i;
   int ii;
   

   for(i=0;i&lt;16;i++)
	for(ii=0;ii&lt;16;ii++)
	{
	  lum = block[i * 16 * 3 + ii * 3] * 0.299 +
		    block[i * 16 * 3 + ii * 3 + 1] * 0.587 +
            block[i * 16 * 3 + ii * 3 + 2] * 0.114;
	 
	  lum -= 128;
	  
	  if(i &lt; 8 &amp;&amp; ii &lt; 8)
	    *Y0++ = (short) lum;
	  else if( ii &gt;= 8 &amp;&amp; i &lt; 8)
	    *Y1++ = (short) lum;
	  else if( ii &lt; 8 &amp;&amp; i &gt;= 8)
	    *Y2++ = (short) lum;
	  else 
	    *Y3++ = (short) lum;
	  /* chrominance - average four pixels */
	  if( (i % 2) == 0 &amp;&amp; (ii % 2) == 0)
	  {
	    cb = block[i * 16 * 3 + ii * 3] * -0.1687 +
		    block[i * 16 * 3 + ii * 3 + 1] * -0.3313 +
		    block[i * 16 * 3 + ii * 3 + 2] * 0.5;
		cb += block[i * 16 * 3 + ii * 3 + 3] * -0.1687 +
		    block[i * 16 * 3 + ii * 3 + 1 + 3] * -0.3313 +
		    block[i * 16 * 3 + ii * 3 + 2 + 3] * 0.5;
		cb += block[(i+1) * 16 * 3 + ii * 3] * -0.1687 +
		    block[(i+1) * 16 * 3 + ii * 3 + 1] * -0.3313 +
		    block[(i+1) * 16 * 3 + ii * 3 + 2] * 0.5;
		cb += block[(i+1) * 16 * 3 + ii * 3+3] * -0.1687 +
		    block[(i+1) * 16 * 3 + ii * 3 + 1+3] * -0.3313 +
		    block[(i+1) * 16 * 3 + ii * 3 + 2+3] * 0.5;

	    cr = block[i * 16 * 3 + ii * 3]  * 0.5 + 
		    block[i * 16 * 3 + ii * 3 + 1] * -0.4187 +
		    block[i * 16 * 3 + ii * 3 + 2] * -0.0813;
	    cr += block[i * 16 * 3 + ii * 3 + 3]  * 0.5 + 
		    block[i * 16 * 3 + ii * 3 + 1 + 3] * -0.4187 +
		    block[i * 16 * 3 + ii * 3 + 2 + 3] * -0.0813;
		cr += block[ (i+1) * 16 * 3 + ii * 3]  * 0.5 + 
		    block[ (i+1) * 16 * 3 + ii * 3 + 1] * -0.4187 +
		    block[ (i+1) * 16 * 3 + ii * 3 + 2] * -0.0813;
		cr += block[(i+1) * 16 * 3 + ii * 3 + 3]  * 0.5 + 
		    block[(i+1)* 16 * 3 + ii * 3 + 1 + 3] * -0.4187 +
		    block[(i+1) * 16 * 3 + ii * 3 + 2 + 3] * -0.0813;
		*Cb++ = (short) (cb/4);
        *Cr++ = (short) (cr/4);
	  }
	}
}

/*
  extract a 16 x 16 block from image
  Params: block - return pointer for block
          buff - the image buffer
		  width - image width
		  height - image height
		  x - x coordinate for top left
		  y - y coordinate of top left
  Notes: areas outside the image are filled with grey
*/
static void getblock16x16(unsigned char *block, unsigned char *buff, int width, int height, int x, int y)
{
  int i;
  int ii;

  for(i=0;i&lt;16;i++)
	for(ii=0;ii&lt;16;ii++)
	{
      if(i + y &lt; height &amp;&amp; ii + x &lt; width)
	  {
	    *block++ = buff[(i+y) * width * 3 + (ii + x) * 3];
		*block++ = buff[(i+y) * width * 3 + (ii + x) * 3 + 1];
		*block++ = buff[(i+y) * width * 3 + (ii + x) * 3 + 2];
	  }
	  else
	  {
	    *block++ = 128;
		*block++ = 128;
		*block++ = 128;
	  }
    }
}

/*
  save start of information marker
  Parmas: fp - pointer to an open file
*/
static void savesoi(FILE *fp)
{
  fputc(0xFF, fp);
  fputc(SOI, fp);
}

/*
  save the JPEG IFF format tag
  Params: fp - pointer to an open file
  Notes: no thumbnail. Assume 1:1 aspect ratio
*/
static void saveapp0(FILE *fp)
{
  
  fputc(0xFF, fp);
  fputc(APP0, fp);
  fput16(16, fp);  /* segment size */

  /* &apos;JFIF&apos;#0 ($4a, $46, $49, $46, $00), identifies JFIF */

  fputc(0x4A, fp);
  fputc(0x46, fp);
  fputc(0x49, fp);
  fputc(0x46, fp);
  fputc(0, fp);

  fputc(1, fp); /* major revision */
  fputc(0, fp); /* minor revision */
  
  fputc(0, fp); /* density units - none */
  fput16(1, fp); /* x density */
  fput16(1, fp); /* y density */

  fputc(0, fp); /* thumbnail width */
  fputc(0, fp); /* thumbnail height */

}

/*
  save start of frame marker
  Params: fp - pointer to an open file
          width - image width
		  height - image height
  Notes: always use a 2:1:1 Yuv format
*/
static void savesof0(FILE *fp, int width, int height)
{
  fputc(0xFF, fp);
  fputc(SOF0, fp); /* start of frame */
  fput16(17, fp);  /* segment length */

  fputc(8, fp); /* precision */
  fput16(height, fp);
  fput16(width, fp);
  fputc(3, fp); /* number of components */

  fputc(1, fp);             /* luminance */
  fputc( (2 &lt;&lt; 4) | 2, fp); /* sampling */
  fputc(0, fp);             /* quantisation table */

  fputc(2, fp);             /* Cb */
  fputc( (1 &lt;&lt; 4) | 1, fp); /* sampling */
  fputc(1, fp);             /* quantisation table */ 

  fputc(3, fp);             /* Cr */
  fputc( (1 &lt;&lt; 4) | 1, fp); /* sampling */
  fputc(1, fp);             /* quantisation table */
}

/*
  save the Huffman tables
  Parmas: fp - pointer to an open file
          Ydc - luminace dc Huffman table
		  Yac - luminance ac Huffman table
		  chromdc - chrominance dc Huffman table
		  chromac - chrominance ac Huffman table
*/
static void savedht(FILE *fp, HUFFTABLE *Ydc, HUFFTABLE *Yac, HUFFTABLE *chromdc, HUFFTABLE *chromac)
{
  unsigned char symbol[256];
  int len[16];
  int inf;
  int length;
  int i;
  int type;
  int tablenumber;

  fputc(0xFF, fp);
  fputc(DHT, fp);

  length = 2 + (1 + 16) * 4 + Ydc-&gt;N + Yac-&gt;N + chromdc-&gt;N + chromac-&gt;N;
  fput16(length, fp);

  type = 0;
  tablenumber = 0;
  inf = (type &lt;&lt; 4) | tablenumber;  
  fputc(inf, fp);
  getlength(Ydc, len);
  for(i=0;i&lt;16;i++)
	fputc(len[i], fp);
  getsymbols(Ydc, symbol);
  for(i=0;i&lt;Ydc-&gt;N;i++)
    fputc(symbol[i], fp);

  type = 0;
  tablenumber = 1;
  inf = (type &lt;&lt; 4) | tablenumber;  
  fputc(inf, fp);
  getlength(chromdc, len);
  for(i=0;i&lt;16;i++)
	fputc(len[i], fp);
  getsymbols(chromdc, symbol);
  for(i=0;i&lt;chromdc-&gt;N;i++)
    fputc(symbol[i], fp);

  type = 1;
  tablenumber = 0;
  inf = (type &lt;&lt; 4) | tablenumber;  
  fputc(inf, fp);
  getlength(Yac, len);
  for(i=0;i&lt;16;i++)
	fputc(len[i], fp);
  getsymbols(Yac, symbol);
  for(i=0;i&lt;Yac-&gt;N;i++)
    fputc(symbol[i], fp);
 
  type = 1;
  tablenumber = 1;
  inf = (type &lt;&lt; 4) | tablenumber;  
  fputc(inf, fp);
  getlength(chromac, len);
  for(i=0;i&lt;16;i++)
	fputc(len[i], fp);
  getsymbols(chromac, symbol);
  for(i=0;i&lt;chromac-&gt;N;i++)
    fputc(symbol[i], fp);

}

/*
  save quantisation tables
  Parmas: fp - pointer toan open file
          lum - luminace quantisation table
		  chrom - chrominance quantisation table
*/
static void savedqt(FILE *fp, unsigned char *lum, unsigned char *chrom)
{
  fputc(0xFF, fp);
  fputc(DQT, fp);

  fput16(2 + 65 * 2, fp);    /* segment length */

  fputc( (0 &lt;&lt; 4) | 0, fp); /* precision and table number */
  fwrite(lum, 1, 64, fp);
  
  fputc( (0 &lt;&lt; 4) | 1, fp);  /* precision and table number */
  fwrite(chrom, 1, 64, fp);
  
}

/*
  save start of scan
  Params: fp - pointer to an open file
  Notes:
*/
static void savesos(FILE *fp)
{
  fputc(0xFF, fp);
  fputc(SOS, fp);
  fput16(12, fp); /* segment length */
  fputc(3, fp);   /* N components */
  fputc(1, fp);  /* luminance */
  fputc( (0 &lt;&lt; 4) | 0, fp); /* huff tables 0 */
  
  fputc(2, fp); /* Cb */
  fputc( (1 &lt;&lt; 4) | 1, fp); /* huff tables 1 */

  fputc(3, fp); /* Cr */
  fputc( (1 &lt;&lt; 4) | 1, fp); /* huff tables 1 */

  /* undocumented bytes ? */
  fputc(0, fp);
  fputc(64, fp);
  fputc(0, fp);
}

#include &lt;math.h&gt;
#define PI 3.1415926535897932384626433832795

void cosinet(double *real, double *trans, int N)
{
  int i;
  int ii;
  double tot = 0;

  for(i=0;i&lt;N;i++)
  {
	tot = 0;
	for(ii=0;ii&lt;N;ii++)
    {
	  tot += real[ii] * cos( (PI * i * (ii * 2 + 1) )/( 2 * N ));
    }
	if(i==0)
	  trans[i] = tot/sqrt(N);
	else
	  trans[i] = tot * sqrt(2.0/N);
  }
}

/*
 8 x 8 2d dct
 Params: block - 64 coefficients
*/
static void dct8x8(short *block)
{
  int i;
  int ii;
  short col[8];
  
  for(i=0;i&lt;8;i++)
	fastdct8(&amp;block[i*8]);
  for(i=0;i&lt;8;i++)
  {
    for(ii=0;ii&lt;8;ii++)
	  col[ii] = block[ii*8+i];
	fastdct8(col);
	for(ii=0;ii&lt;8;ii++)
	  block[ii*8+i] = col[ii];
  }
}

/*
  fast discrete cosine transform
  Params: x - vector to transform (8 shorts)
*/
static void fastdct8(short *x)
{
  int blk[7][8];
  int *X;

  int a1 = 2896; /* cos(PI * 4.0/16.0); */
  int a2 = 2216; /* cos(PI * 2.0/16.0) - cos(PI * 6.0/16.0); */
  int a3 = 2896; /* cos(PI * 4.0/16.0); */
  int a4 = 5351; /* cos(PI * 2.0/16.0) + cos(PI * 6.0/16.0); */
  int a5 = 1567; /* cos(PI * 6.0/16.0); */

  int s0 = 1448; /* 1.0/(2 * sqrt(2.0)); */
  int s1 = 1044; /* 1.0/(4.0 * cos(PI * 1/16.0)); */
  int s2 = 1108; /* 1.0/(4.0 * cos(PI * 2/16.0)); */
  int s3 = 1231; /* 1.0/(4.0 * cos(PI * 3/16.0)); */
  int s4 = 1448; /* 1.0/(4.0 * cos(PI * 4/16.0)); */
  int s5 = 1843; /* 1.0/(4.0 * cos(PI * 5/16.0)); */
  int s6 = 2675; /* 1.0/(4.0 * cos(PI * 6/16.0)); */
  int s7 = 5248; /* 1.0/(4.0 * cos(PI * 7/16.0)); */

  int store;

  blk[0][0] = x[0] + x[7];
  blk[0][1] = x[1] + x[6];
  blk[0][2] = x[2] + x[5];
  blk[0][3] = x[3] + x[4];
  blk[0][4] = x[3] - x[4];
  blk[0][5] = x[2] - x[5];
  blk[0][6] = x[1] - x[6];
  blk[0][7] = x[0] - x[7];

  X = blk[0];

  blk[1][0] = X[0] + X[3];
  blk[1][1] = X[1] + X[2];
  blk[1][2] = X[1] - X[2];
  blk[1][3] = X[0] - X[3];
  blk[1][4] = -X[4] - X[5];
  blk[1][5] = X[5] + X[6];
  blk[1][6] = X[7] + X[6];
  blk[1][7] = X[7];

  X = blk[1];

  blk[2][0] = X[0] + X[1];
  blk[2][1] = X[0] - X[1];
  blk[2][2] = X[2] + X[3];
  blk[2][3] = X[3];
  blk[2][4] = X[4];
  blk[2][5] = X[5];
  blk[2][6] = X[6];
  blk[2][7] = X[7];

  X = blk[2];

  blk[3][0] = X[0];
  blk[3][1] = X[1];
  blk[3][2] = ((X[2] * a1) + 2048) &gt;&gt; 12;
  blk[3][3] = X[3];
  blk[3][4] = ((X[4] * a2) + 2048) &gt;&gt; 12;
  blk[3][5] = ((X[5] * a3) + 2048) &gt;&gt; 12;
  blk[3][6] = ((X[6] * a4) + 2048) &gt;&gt; 12;
  blk[3][7] = X[7];
  
  store = ((X[4] + X[6]) * a5) &gt;&gt; 12;
  
  X = blk[3];
  blk[4][0] = X[0];
  blk[4][1] = X[1];
  blk[4][2] = X[2];
  blk[4][3] = X[3];
  blk[4][4] = -store - X[4];
  blk[4][5] = X[5];
  blk[4][6] = X[6] - store;
  blk[4][7] = X[7];

  X = blk[4];
  blk[5][0] = X[0];
  blk[5][1] = X[1];
  blk[5][2] = X[2] + X[3];
  blk[5][3] = X[3] - X[2];
  blk[5][4] = X[4];
  blk[5][5] = X[5] + X[7];
  blk[5][6] = X[6];
  blk[5][7] = X[7] - X[5];

  X = blk[5];
  blk[6][0] = X[0];
  blk[6][1] = X[1];
  blk[6][2] = X[2];
  blk[6][3] = X[3];
  blk[6][4] = X[4] + X[7];
  blk[6][5] = X[5] + X[6];
  blk[6][6] = X[5] - X[6];
  blk[6][7] = X[7] - X[4];

  X = blk[6];
  x[0] = (short) ((X[0] * s0 + 2048) &gt;&gt; 12);
  x[4] = (short) ((X[1] * s4 + 2048) &gt;&gt; 12);
  x[2] = (short) ((X[2] * s2 + 2048) &gt;&gt; 12);
  x[6] = (short) ((X[3] * s6 + 2048) &gt;&gt; 12);
  x[5] = (short) ((X[4] * s5 + 2048) &gt;&gt; 12);
  x[1] = (short) ((X[5] * s1 + 2048) &gt;&gt; 12);
  x[7] = (short) ((X[6] * s7 + 2048) &gt;&gt; 12);
  x[3] = (short) ((X[7] * s3 + 2048) &gt;&gt; 12);
  
}

static void slowdct8(short *x)
{
  double real[8];
  double trans[8];
  int i;

  for(i=0;i&lt;8;i++)
	real[i] = x[i];
  cosinet(real, trans, 8);
  for(i=0;i&lt;8;i++)
	x[i] = (short) trans[i];
}

/*
  do zigzagging on coefficients.
  Params: block - 64 coefficients to dezigzag
*/
static void zigzag(short *block)
{
  static int zigzag[64] =
  {0, 1, 5, 6,14,15,27,28,
   2, 4, 7,13,16,26,29,42,
   3, 8,12,17,25,30,41,43,
   9,11,18,24,31,40,44,53,
   10,19,23,32,39,45,52,54,
   20,22,33,38,46,51,55,60,
   21,34,37,47,50,56,59,61,
   35,36,48,49,57,58,62,63 };
 short temp[64];
 int i;

 for(i=0;i&lt;64;i++)
   temp[ zigzag[i]] = block[i];
 for(i=0;i&lt;64;i++)
   block[i] = temp[i];
}

/*
  save a block 
  Parmas: block - 64 transformed and zigzagged parameters
          dc - table for dc coefficient
		  ac - table for ac coefficient
		  bs - the bitstream
*/
static void saveblock(short *block, HUFFTABLE *dc, HUFFTABLE *ac, BITSTREAM *bs)
{
  int len;
  int zeroes;
  int i = 1;

  /* write the dc */
  len = symbollen(block[0]);
  writehuff(dc, len, bs);
  writebits(bs, inttowrite(block[0], len), len);
 
  /* write ac */
  while(i &lt; 64)
  {
	zeroes = 0;
    while(block[i] == 0)
    {
	  zeroes++;
	  i++;
	  if(i==64)
	  {
		writehuff(ac, 0, bs);
	    return;
	  }
	}
	while(zeroes &gt;= 16)
	{
      writehuff(ac, 0xF0, bs);
	  zeroes -= 16;
    }
    len = symbollen(block[i]);
	writehuff(ac, (zeroes &lt;&lt; 4) | len, bs);
    writebits(bs, inttowrite(block[i], len), len);
	i++;
  }

}

/*
  convert a block coefficinet to the integer that goes into bitstream
  Params: x - the value
          len - number of bits to encode
  Returns: bits to write. Negative has leading 0 and 0 represents the
    lowest possible value.
*/
static int inttowrite(int x, int len)
{
  if(x &gt;= 0)
	return x;
  else
	return x + (1 &lt;&lt; len) - 1;
}

/*
  get the number of bits needed to encode a value
  Params: x - the value
  Returns: number of significant bits
*/
static int symbollen(int x)
{
  int answer = 0;

  if(x &lt; 0)
	x = -x;
  while(x)
  {
	answer++;
	x &gt;&gt;= 1;
  }

  return answer;
}

/*
  write a Huffman code to bitstream
  Parmas: ht - the Huffman table
          symbol - the symbol to write
		  bs - the bitstream
*/
static void writehuff(HUFFTABLE *ht, int symbol, BITSTREAM *bs)
{
  int i = 0;

  while(ht-&gt;codes[symbol][i])
  {
    if(ht-&gt;codes[symbol][i] == &apos;1&apos;)
	  putbit(bs, 1);
	else
	  putbit(bs, 0);
	i++;
  }
}

/*
  create a bitstream
  Parmas: fp - pointer to open file
  Returns: bitstream opened for writing
*/
static BITSTREAM *bitstream(FILE *fp)
{
  BITSTREAM *answer;

  answer = malloc(sizeof(BITSTREAM));
  if(!answer)
    return 0;
  answer-&gt;fp = fp;
  answer-&gt;bit = 0x80;
  answer-&gt;rack = 0;

  return answer;
}

/*
  bitstream destructor
  Params: bs - object to destory
  Notes: remember to flush before destroying
*/
static void killbitstream(BITSTREAM *bs)
{
  free(bs);
}

/*
  write bits to a bitstream
  Params: bs - the bitstream
          x - value to write
		  bits - number of bits to write
*/
static void writebits(BITSTREAM *bs, int x, int bits)
{
  while(bits--)
  {
    putbit(bs, (x &amp; (1 &lt;&lt; bits)) ? 1 : 0); 
  }
}

/*
  write a bit to a bitstream
  Parmas: bs - the bitstream
          bit - true to write set bit, zero for clear bit
*/
static void putbit(BITSTREAM *bs, int bit)
{
  if(bit)
    bs-&gt;rack |= bs-&gt;bit;
  bs-&gt;bit &gt;&gt;= 1;
  if(bs-&gt;bit == 0)
  {
    fputc(bs-&gt;rack, bs-&gt;fp);
	/* 0xFF is the JPEG escape sequence */
    if(bs-&gt;rack == 0xFF)
	  fputc(0, bs-&gt;fp);
	bs-&gt;rack =  0;
	bs-&gt;bit = 0x80;
  }
}

/*
  write cached bits to stream
  Params: bs - the bitstream
  Notes: call before destroying
*/
static void flushbitstream(BITSTREAM *bs)
{
  while(bs-&gt;bit != 0x80)
    putbit(bs, 1);
}

/*
  get the standard luminance quantisation table
*/
static void lumqt(unsigned char *qt)
{
   static unsigned char harshlum[64] =
   {
    16, 11, 12, 14, 12, 10, 16, 14, 13, 14, 18, 17, 16, 19, 24, 40, 26, 24, 22, 22,
    24, 49, 35, 37, 29, 40, 58, 51, 61, 60, 57, 51, 56, 55, 64, 72, 92, 78, 64, 68,
    87, 69, 55, 56, 80, 109, 81, 87, 95, 98, 103, 104, 103, 62, 77, 113, 121, 112, 
	100, 120, 92, 101, 103, 99,
   };

   static unsigned char lum[64] = 
   {
	   4, 2, 2, 4, 6, 10, 12, 15, 
       3, 3, 3, 4, 6, 14, 15, 13, 
       3, 3, 4, 6, 10, 14, 17, 14, 
       3, 4, 5, 7, 12, 21, 20, 15, 
       4, 5, 9, 14, 17, 27, 25, 19, 
       6, 8, 13, 16, 20, 26, 28, 23,  
       12, 16, 19, 21, 25, 30, 30, 25, 
       18, 23, 23, 24, 28, 25, 25, 24 
   };

  
  memcpy(qt, lum, 64);
}  

/*
  get the standard chrominance quantisation table
*/
static void chromqt(unsigned char *qt)
{
   static unsigned char harshchrom[64] =
   {
     17, 18, 18, 24, 21, 24, 47, 26, 26, 47, 99, 66, 56, 66, 99, 99, 99, 99, 99, 99,
     99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
     99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99,
     99, 99, 99, 99,
   };

   static unsigned char chrom[64] =
   {
		4, 4, 6, 11, 24, 24, 24, 24, 
		4, 5, 6, 16, 24, 24, 24, 24, 
		6, 6, 14, 24, 24, 24, 24, 24, 
		11, 16, 24, 24, 24, 24, 24, 24, 
		24, 24, 24, 24, 24, 24, 24, 24, 
		24, 24, 24, 24, 24, 24, 24, 24, 
		24, 24, 24, 24, 24, 24, 24, 24, 
		24, 24, 24, 24, 24, 24, 24, 24
   };

  memcpy(qt, chrom, 64);
}

/*
  get the standard luminace DC Huffman table
*/
static HUFFTABLE *lumdc(void)
{
/* dc table 0 */
 static HUFFENTRY table[12] =
 {
	 {&quot;00&quot;, 0},
	 {&quot;010&quot;, 1},
	 {&quot;011&quot;, 2},
	 {&quot;100&quot;, 3},
	 {&quot;101&quot;, 4},
	 {&quot;110&quot;, 5},
	 {&quot;1110&quot;, 6},
	 {&quot;11110&quot;, 7},
	 {&quot;111110&quot;, 8},
	 {&quot;1111110&quot;, 9},
	 {&quot;11111110&quot;, 10},
	 {&quot;111111110&quot;, 11},
 };

 return buildhuff(table, 12);
}

/*
  get the standard chrominance DC Huffman table
*/
static HUFFTABLE *chromdc(void)
{
  static HUFFENTRY table[12] =
  {
/* dc table 1 */
	{&quot;00&quot;, 0},
	{&quot;01&quot;, 1},
	{&quot;10&quot;, 2},
	{&quot;110&quot;, 3},
	{&quot;1110&quot;, 4},
	{&quot;11110&quot;, 5},
	{&quot;111110&quot;, 6},
	{&quot;1111110&quot;, 7},
	{&quot;11111110&quot;, 8},
	{&quot;111111110&quot;, 9},
	{&quot;1111111110&quot;, 10},
	{&quot;11111111110&quot;, 11},
  };

  return buildhuff(table, 12);
}

/*
  get the standard luminace AC Huffman table
*/
static HUFFTABLE *lumac(void)
{
  static HUFFENTRY table[] =
  {
/* ac tree 0 */
	  {&quot;00&quot;, 1},
	  {&quot;01&quot;, 2},
	  {&quot;100&quot;, 3},
	  {&quot;1010&quot;, 0},
	  {&quot;1011&quot;, 4},
	  {&quot;1100&quot;, 17},
	  {&quot;11010&quot;, 5},
	  {&quot;11011&quot;, 18},
	  {&quot;11100&quot;, 33},
	  {&quot;111010&quot;, 49},
	  {&quot;111011&quot;, 65},
	  {&quot;1111000&quot;, 6},
	  {&quot;1111001&quot;, 19},
	  {&quot;1111010&quot;, 81},
	  {&quot;1111011&quot;, 97},
	  {&quot;11111000&quot;, 7},
	  {&quot;11111001&quot;, 34},
	  {&quot;11111010&quot;, 113},
	  {&quot;111110110&quot;, 20},
	  {&quot;111110111&quot;, 50},
	  {&quot;111111000&quot;, 129},
	  {&quot;111111001&quot;, 145},
	  {&quot;111111010&quot;, 161},
	  {&quot;1111110110&quot;, 8},
	  {&quot;1111110111&quot;, 35},
	  {&quot;1111111000&quot;, 66},
	  {&quot;1111111001&quot;, 177},
	  {&quot;1111111010&quot;, 193},
	  {&quot;11111110110&quot;, 21},
	  {&quot;11111110111&quot;, 82},
	  {&quot;11111111000&quot;, 209},
	  {&quot;11111111001&quot;, 240},
	  {&quot;111111110100&quot;, 36},
	  {&quot;111111110101&quot;, 51},
	  {&quot;111111110110&quot;, 98},
	  {&quot;111111110111&quot;, 114},
	  {&quot;111111111000000&quot;, 130},
	  {&quot;1111111110000010&quot;, 9},
	  {&quot;1111111110000011&quot;, 10},
	  {&quot;1111111110000100&quot;, 22},
	  {&quot;1111111110000101&quot;, 23}, 
	  {&quot;1111111110000110&quot;, 24},
	  {&quot;1111111110000111&quot;, 25},
	  {&quot;1111111110001000&quot;, 26},
	  {&quot;1111111110001001&quot;, 37},
	  {&quot;1111111110001010&quot;, 38},
	  {&quot;1111111110001011&quot;, 39},
	  {&quot;1111111110001100&quot;, 40},
	  {&quot;1111111110001101&quot;, 41},
	  {&quot;1111111110001110&quot;, 42},
	  {&quot;1111111110001111&quot;, 52},
	  {&quot;1111111110010000&quot;, 53},
	  {&quot;1111111110010001&quot;, 54},
	  {&quot;1111111110010010&quot;, 55},
	  {&quot;1111111110010011&quot;, 56},
	  {&quot;1111111110010100&quot;, 57},
	  {&quot;1111111110010101&quot;, 58},
	  {&quot;1111111110010110&quot;, 67},
	  {&quot;1111111110010111&quot;, 68},
	  {&quot;1111111110011000&quot;, 69},
	  {&quot;1111111110011001&quot;, 70},
	  {&quot;1111111110011010&quot;, 71},
	  {&quot;1111111110011011&quot;, 72},
	  {&quot;1111111110011100&quot;, 73},
	  {&quot;1111111110011101&quot;, 74},
	  {&quot;1111111110011110&quot;, 83},
	  {&quot;1111111110011111&quot;, 84},
	  {&quot;1111111110100000&quot;, 85},
	  {&quot;1111111110100001&quot;, 86},
	  {&quot;1111111110100010&quot;, 87},
	  {&quot;1111111110100011&quot;, 88},
	  {&quot;1111111110100100&quot;, 89},
	  {&quot;1111111110100101&quot;, 90},
	  {&quot;1111111110100110&quot;, 99},
	  {&quot;1111111110100111&quot;, 100},
	  {&quot;1111111110101000&quot;, 101},
	  {&quot;1111111110101001&quot;, 102},
	  {&quot;1111111110101010&quot;, 103},
	  {&quot;1111111110101011&quot;, 104},
	  {&quot;1111111110101100&quot;, 105},
	  {&quot;1111111110101101&quot;, 106},
	  {&quot;1111111110101110&quot;, 115},
	  {&quot;1111111110101111&quot;, 116},
	  {&quot;1111111110110000&quot;, 117},
	  {&quot;1111111110110001&quot;, 118},
	  {&quot;1111111110110010&quot;, 119},
	  {&quot;1111111110110011&quot;, 120},
	  {&quot;1111111110110100&quot;, 121},
	  {&quot;1111111110110101&quot;, 122},
	  {&quot;1111111110110110&quot;, 131},
	  {&quot;1111111110110111&quot;, 132},
	  {&quot;1111111110111000&quot;, 133},
	  {&quot;1111111110111001&quot;, 134},
	  {&quot;1111111110111010&quot;, 135},
	  {&quot;1111111110111011&quot;, 136},
	  {&quot;1111111110111100&quot;, 137},
	  {&quot;1111111110111101&quot;, 138},
	  {&quot;1111111110111110&quot;, 146},
	  {&quot;1111111110111111&quot;, 147},
	  {&quot;1111111111000000&quot;, 148},
	  {&quot;1111111111000001&quot;, 149},
	  {&quot;1111111111000010&quot;, 150},
	  {&quot;1111111111000011&quot;, 151},
	  {&quot;1111111111000100&quot;, 152},
	  {&quot;1111111111000101&quot;, 153},
	  {&quot;1111111111000110&quot;, 154},
	  {&quot;1111111111000111&quot;, 162},
	  {&quot;1111111111001000&quot;, 163},
	  {&quot;1111111111001001&quot;, 164},
	  {&quot;1111111111001010&quot;, 165},
	  {&quot;1111111111001011&quot;, 166},
	  {&quot;1111111111001100&quot;, 167},
	  {&quot;1111111111001101&quot;, 168},
	  {&quot;1111111111001110&quot;, 169},
	  {&quot;1111111111001111&quot;, 170},
	  {&quot;1111111111010000&quot;, 178},
	  {&quot;1111111111010001&quot;, 179},
	  {&quot;1111111111010010&quot;, 180},
	  {&quot;1111111111010011&quot;, 181},
	  {&quot;1111111111010100&quot;, 182},
	  {&quot;1111111111010101&quot;, 183},
	  {&quot;1111111111010110&quot;, 184},
	  {&quot;1111111111010111&quot;, 185},
	  {&quot;1111111111011000&quot;, 186},
	  {&quot;1111111111011001&quot;, 194},
	  {&quot;1111111111011010&quot;, 195},
	  {&quot;1111111111011011&quot;, 196},
	  {&quot;1111111111011100&quot;, 197},
	  {&quot;1111111111011101&quot;, 198},
	  {&quot;1111111111011110&quot;, 199},
	  {&quot;1111111111011111&quot;, 200},
	  {&quot;1111111111100000&quot;, 201},
	  {&quot;1111111111100001&quot;, 202},
	  {&quot;1111111111100010&quot;, 210},
	  {&quot;1111111111100011&quot;, 211},
	  {&quot;1111111111100100&quot;, 212},
	  {&quot;1111111111100101&quot;, 213},
	  {&quot;1111111111100110&quot;, 214},
	  {&quot;1111111111100111&quot;, 215},
	  {&quot;1111111111101000&quot;, 216},
	  {&quot;1111111111101001&quot;, 217},
	  {&quot;1111111111101010&quot;, 218},
	  {&quot;1111111111101011&quot;, 225},
	  {&quot;1111111111101100&quot;, 226},
	  {&quot;1111111111101101&quot;, 227},
	  {&quot;1111111111101110&quot;, 228},
	  {&quot;1111111111101111&quot;, 229},
	  {&quot;1111111111110000&quot;, 230},
	  {&quot;1111111111110001&quot;, 231},
	  {&quot;1111111111110010&quot;, 232},
	  {&quot;1111111111110011&quot;, 233},
	  {&quot;1111111111110100&quot;, 234},
	  {&quot;1111111111110101&quot;, 241},
	  {&quot;1111111111110110&quot;, 242},
	  {&quot;1111111111110111&quot;, 243},
	  {&quot;1111111111111000&quot;, 244},
	  {&quot;1111111111111001&quot;, 245},
	  {&quot;1111111111111010&quot;, 246},
	  {&quot;1111111111111011&quot;, 247},
	  {&quot;1111111111111100&quot;, 248},
	  {&quot;1111111111111101&quot;, 249},
	  {&quot;1111111111111110&quot;, 250},
  };

  

  return buildhuff(table, sizeof(table)/sizeof(HUFFENTRY));
}

/*
  get the standard chrominance AC Huffman table 
*/
static HUFFTABLE *chromac(void)
{
 static HUFFENTRY table[] =
 {
/* ac table 1 */
	{&quot;00&quot;, 0},
	{&quot;01&quot;, 1},
	{&quot;100&quot;, 2},
	{&quot;1010&quot;, 3},
	{&quot;1011&quot;, 17},
	{&quot;11000&quot;, 4},
	{&quot;11001&quot;, 5},
	{&quot;11010&quot;, 33},
	{&quot;11011&quot;, 49},
	{&quot;111000&quot;, 6},
	{&quot;111001&quot;, 18},
	{&quot;111010&quot;, 65},
	{&quot;111011&quot;, 81},
	{&quot;1111000&quot;, 7},
	{&quot;1111001&quot;, 97},
	{&quot;1111010&quot;, 113},
	{&quot;11110110&quot;, 19},
	{&quot;11110111&quot;, 34},
	{&quot;11111000&quot;, 50},
	{&quot;11111001&quot;, 129},
	{&quot;111110100&quot;, 8},
	{&quot;111110101&quot;, 20},
	{&quot;111110110&quot;, 66},
	{&quot;111110111&quot;, 145},
	{&quot;111111000&quot;, 161},
	{&quot;111111001&quot;, 177},
	{&quot;111111010&quot;, 193},
	{&quot;1111110110&quot;, 9},
	{&quot;1111110111&quot;, 35},
	{&quot;1111111000&quot;, 51},
	{&quot;1111111001&quot;, 82},
	{&quot;1111111010&quot;, 240},
	{&quot;11111110110&quot;, 21},
	{&quot;11111110111&quot;, 98},
	{&quot;11111111000&quot;, 114},
	{&quot;11111111001&quot;, 209},
	{&quot;111111110100&quot;, 10},
	{&quot;111111110101&quot;, 22},
	{&quot;111111110110&quot;, 36},
	{&quot;111111110111&quot;, 52},
	{&quot;11111111100000&quot;, 225},
	{&quot;111111111000010&quot;, 37},
	{&quot;111111111000011&quot;, 241},
	{&quot;1111111110001000&quot;, 23},
	{&quot;1111111110001001&quot;, 24},
	{&quot;1111111110001010&quot;, 25},
	{&quot;1111111110001011&quot;, 26},
	{&quot;1111111110001100&quot;, 38},
	{&quot;1111111110001101&quot;, 39},
	{&quot;1111111110001110&quot;, 40},
	{&quot;1111111110001111&quot;, 41},
	{&quot;1111111110010000&quot;, 42},
	{&quot;1111111110010001&quot;, 53},
	{&quot;1111111110010010&quot;, 54},
	{&quot;1111111110010011&quot;, 55},
	{&quot;1111111110010100&quot;, 56},
	{&quot;1111111110010101&quot;, 57},
	{&quot;1111111110010110&quot;, 58},
	{&quot;1111111110010111&quot;, 67},
	{&quot;1111111110011000&quot;, 68},
	{&quot;1111111110011001&quot;, 69},
	{&quot;1111111110011010&quot;, 70},
	{&quot;1111111110011011&quot;, 71},
	{&quot;1111111110011100&quot;, 72},
	{&quot;1111111110011101&quot;, 73},
	{&quot;1111111110011110&quot;, 74},
	{&quot;1111111110011111&quot;, 83},
	{&quot;1111111110100000&quot;, 84},
	{&quot;1111111110100001&quot;, 85},
	{&quot;1111111110100010&quot;, 86},
	{&quot;1111111110100011&quot;, 87},
	{&quot;1111111110100100&quot;, 88},
	{&quot;1111111110100101&quot;, 89},
	{&quot;1111111110100110&quot;, 90},
	{&quot;1111111110100111&quot;, 99},
	{&quot;1111111110101000&quot;, 100},
	{&quot;1111111110101001&quot;, 101},
	{&quot;1111111110101010&quot;, 102},
	{&quot;1111111110101011&quot;, 103},
	{&quot;1111111110101100&quot;, 104},
	{&quot;1111111110101101&quot;, 105},
	{&quot;1111111110101110&quot;, 106},
	{&quot;1111111110101111&quot;, 115},
	{&quot;1111111110110000&quot;, 116},
	{&quot;1111111110110001&quot;, 117},
	{&quot;1111111110110010&quot;, 118},
	{&quot;1111111110110011&quot;, 119},
	{&quot;1111111110110100&quot;, 120},
	{&quot;1111111110110101&quot;, 121},
	{&quot;1111111110110110&quot;, 122},
	{&quot;1111111110110111&quot;, 130},
	{&quot;1111111110111000&quot;, 131},
	{&quot;1111111110111001&quot;, 132},
	{&quot;1111111110111010&quot;, 133},
	{&quot;1111111110111011&quot;, 134},
	{&quot;1111111110111100&quot;, 135},
	{&quot;1111111110111101&quot;, 136},
	{&quot;1111111110111110&quot;, 137},
	{&quot;1111111110111111&quot;, 138},
	{&quot;1111111111000000&quot;, 146},
	{&quot;1111111111000001&quot;, 147},
	{&quot;1111111111000010&quot;, 148},
	{&quot;1111111111000011&quot;, 149},
	{&quot;1111111111000100&quot;, 150},
	{&quot;1111111111000101&quot;, 151},
	{&quot;1111111111000110&quot;, 152},
	{&quot;1111111111000111&quot;, 153},
	{&quot;1111111111001000&quot;, 154},
	{&quot;1111111111001001&quot;, 162},
	{&quot;1111111111001010&quot;, 163},
	{&quot;1111111111001011&quot;, 164},
	{&quot;1111111111001100&quot;, 165},
	{&quot;1111111111001101&quot;, 166},
	{&quot;1111111111001110&quot;, 167},
	{&quot;1111111111001111&quot;, 168},
	{&quot;1111111111010000&quot;, 169},
	{&quot;1111111111010001&quot;, 170},
	{&quot;1111111111010010&quot;, 178},
	{&quot;1111111111010011&quot;, 179},
	{&quot;1111111111010100&quot;, 180},
	{&quot;1111111111010101&quot;, 181},
	{&quot;1111111111010110&quot;, 182},
	{&quot;1111111111010111&quot;, 183},
	{&quot;1111111111011000&quot;, 184},
	{&quot;1111111111011001&quot;, 185},
	{&quot;1111111111011010&quot;, 186},
	{&quot;1111111111011011&quot;, 194},
	{&quot;1111111111011100&quot;, 195},
	{&quot;1111111111011101&quot;, 196},
	{&quot;1111111111011110&quot;, 197},
	{&quot;1111111111011111&quot;, 198},
	{&quot;1111111111100000&quot;, 199},
	{&quot;1111111111100001&quot;, 200},
	{&quot;1111111111100010&quot;, 201},
	{&quot;1111111111100011&quot;, 202},
	{&quot;1111111111100100&quot;, 210},
	{&quot;1111111111100101&quot;, 211},
	{&quot;1111111111100110&quot;, 212},
	{&quot;1111111111100111&quot;, 213},
	{&quot;1111111111101000&quot;, 214},
	{&quot;1111111111101001&quot;, 215},
	{&quot;1111111111101010&quot;, 216},
	{&quot;1111111111101011&quot;, 217},
	{&quot;1111111111101100&quot;, 218},
	{&quot;1111111111101101&quot;, 226},
	{&quot;1111111111101110&quot;, 227},
	{&quot;1111111111101111&quot;, 228},
	{&quot;1111111111110000&quot;, 229},
	{&quot;1111111111110001&quot;, 230},
	{&quot;1111111111110010&quot;, 231},
	{&quot;1111111111110011&quot;, 232},
	{&quot;1111111111110100&quot;, 233},
	{&quot;1111111111110101&quot;, 234},
	{&quot;1111111111110110&quot;, 242},
	{&quot;1111111111110111&quot;, 243},
	{&quot;1111111111111000&quot;, 244},
	{&quot;1111111111111001&quot;, 245},
	{&quot;1111111111111010&quot;, 246},
	{&quot;1111111111111011&quot;, 247},
	{&quot;1111111111111100&quot;, 248},
	{&quot;1111111111111101&quot;, 249},
	{&quot;1111111111111110&quot;, 250},
  };

  return buildhuff(table, sizeof(table)/sizeof(HUFFENTRY));
}

/*
  build Huffman table from entries
  Parmas: table - the table
          N - number of entries in table
*/
static HUFFTABLE *buildhuff(HUFFENTRY *table, int N)
{
  HUFFTABLE *answer;
  int i;

  answer = malloc(sizeof(HUFFTABLE));
  answer-&gt;N = N;
  answer-&gt;codes = malloc(256 * sizeof(char *));
  for(i=0;i&lt;256;i++)
    answer-&gt;codes[i] = 0;
  for(i=0;i&lt;N;i++)
  {
	if(answer-&gt;codes[ table[i].symbol ])
	  goto error_exit;
    answer-&gt;codes[ table[i].symbol ] = mystrdup(table[i].code);
    if(!answer-&gt;codes[ table[i].symbol ])
	  goto error_exit;
  }

  return answer;

error_exit:
  if(answer &amp;&amp; answer-&gt;codes)
  {
    for(i=0;i&lt;answer-&gt;N;i++)
	  free(answer-&gt;codes[i]);
    free(answer-&gt;codes);
  }
  free(answer);
  return 0;
}

/*
  destroy a Huffman table
  Params: ht - the table to destroy
*/
static killhuff(HUFFTABLE *ht)
{
  int i;

  if(ht &amp;&amp; ht-&gt;codes)
  {
    for(i=0;i&lt;ht-&gt;N;i++)
	  free(ht-&gt;codes[i]);
    free(ht-&gt;codes);
  }
  free(ht);
}

/*
  get length parameters for a Huffman table
  Params: ht - the Huffman table
          len - return pointer for 16 length 
  Returns: total number of codes in table
  Notes: len[0] = codes with length 1, len[1] = codes with length 2, etc 
*/
static int getlength(HUFFTABLE *ht, int *len)
{
  int i;

  for(i=0;i&lt;16;i++)
	len[i] = 0;
  for(i=0;i&lt;256;i++)
	if(ht-&gt;codes[i])
      len[strlen(ht-&gt;codes[i]) -1]++;

  return ht-&gt;N;
}

/*
  compare two Huffman entries
  Parmas: e1 - pointer to first element
          e2 - pointer to second element
  Returns: sort order (for qsort())
*/
static int compentries(const void *e1, const void *e2)
{
  const HUFFENTRY *h1 = e1;
  const HUFFENTRY *h2 = e2;

  if(!h1-&gt;code &amp;&amp; !h2-&gt;code)
	return 0;
  if(!h1-&gt;code)
	return 1;
  if(!h2-&gt;code)
	return -1;

 
  return strcmp(h1-&gt;code, h2-&gt;code);
}

/*
  get the symbols fromm a Huffman table.
  Params: ht - Huffman table
          sym - return pointer for symbols (256 max) in code order
*/
static void getsymbols(HUFFTABLE *ht, unsigned char *sym)
{
  HUFFENTRY ent[256];
  int i;

  for(i=0;i&lt;256;i++)
  {
    ent[i].code = ht-&gt;codes[i];
	ent[i].symbol = i;
  }
  qsort(ent, 256, sizeof(HUFFENTRY), compentries);
  for(i=0;i&lt;ht-&gt;N;i++)
	sym[i] = (unsigned char) ent[i].symbol;
}

/*
  write a 16-bit big-endian integer to file
  Params: x - value
          fp - pointer to open file
*/
static void fput16(int x, FILE *fp)
{
  fputc( (x &gt;&gt; 8) &amp; 0xFF, fp);
  fputc(x &amp; 0xFF, fp);
}

/*
  duplicate a string
  Params: str - the string
  Returns: malloced dpulicate
*/
static char *mystrdup(const char *str)
{
  char *answer;

  answer = malloc(strlen(str) + 1);
  if(answer)
	strcpy(answer, str);

  return answer;
}

		</file>
		<file name="vector.h" type="text">

#ifndef vector_h
#define vector_h

float vang(float *a, float *b, float *c);
void crossproduct(float *ans, float *pt1, float *pt2);
float dot(float *a, float *b);
int normalize(float *v);
void vsub(float *res, float *a, float *b);
float vlen(float *v);
float vdist(float *a, float *b);
float vdist2(float *a, float *b);

#endif

		</file>
		<file name="pdb.h" type="text">
#ifndef pdb_h
#define pdb_h

typedef struct
{
  char symbol;
  char hetname[32];
  int hetid;
  int minatom;
  int maxatom;
  char secondary;
} PDB_RESIDUE;

typedef struct
{
  int N;
  PDB_RESIDUE *seq;
  char id[8];
  int minatom;
  int maxatom;
  int base;
} PDB_CHAIN;

typedef struct
{
  float pos[3];
  char id[5];
  int element;
} PDB_ATOM;

typedef struct
{
    char *fullname;
    char name3[4];
    int Natoms;
    int Nbonds;
    char **atomnames;
    int *bonda;
    int *bondb;
    int minatom;
    int maxatom;
} PDB_HETEROGEN;

typedef struct
{
  char classification[64];
  char date[10];
  char id[8];
  char *title;
  int Nchains;
  PDB_CHAIN *chain;
  PDB_ATOM *atoms;
  PDB_HETEROGEN *hets;
  int Nhets;
  int Natoms;
  int atomspace;
  int termhack;
  int secondarybad;
} PDB;


PDB *loadpdb(const char *path, int *err);
PDB *floadpdb(FILE *fp, int *err);
void killpdb(PDB *pdb);
int pdb_getNchains(PDB *pdb);
int pdb_getchainlen(PDB *pdb, int chain);
int pdb_chainindex(PDB *pdb, char *id);
int pdb_resid(PDB *pdb, int chain, int residue);
int pdb_getatom(PDB *pdb, int chain, int residue, char *atom, float *x, float *y, float *z);
int pdb_getsequence(PDB *pdb, int chain, char *out);
int pdb_getsecondary(PDB *pdb, int chain, char *out);

#endif

		</file>
		<file name="medialaxistransform.h" type="text">
#ifndef medialaxistransform_c
#define medialaxisistransform_h

float *medialaxistransformf(unsigned char *binary, int width, int height);
unsigned char *medialaxistransform(unsigned char *binary, int width, int height);
unsigned char *thin(unsigned char *binary, int width, int height);

#endif

		</file>
		<file name="options.c" type="text">
/*
  version 1.1 null flags bug fixed.
  version 1.2 bug fixed with trailing options without args
 */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdarg.h&gt;
#include &lt;string.h&gt;
#include &lt;ctype.h&gt;
#include &lt;limits.h&gt;
#include &lt;assert.h&gt;

typedef struct
{
  int argc;             /* number of arguments */
  char **argv;          /* argument list */
  char *flags;          /* set of allowed one char flags */
  int *used;            /* flag for each argument read */
  int firsttouched;     /* set if the first arguement interpreted as flags */
  int firstflag;        /* set if the first arguement can be flags */
  int *firstused;       /* set if each character of first arguement read */
  int error;            /* set if the parser encounters an error */
  char errstr[1024];    /* parser error text */
} OPTIONS;

OPTIONS *options(int argc, char **argv, char *flags);
void killoptions(OPTIONS *opt);
int opt_get(OPTIONS *opt, char *name, char *fmt, ...);
int opt_error(OPTIONS *opt, FILE *fp);
int opt_Nargs(OPTIONS *opt);
char *opt_arg(OPTIONS *opt, int index);

static void checkunusedoptions(OPTIONS *opt);
static int parseoptionsv(OPTIONS *opt, int idx, char *fmt, va_list ret);
static void seterror(OPTIONS *opt, char *fmt, ...);
static int canbeflags(char *argv1, char *flags);
static int firstopt(char *argv1, char *name);
static int contains(char *name, char *opt);
static int oneletteropt(char *name);
static int empty(const char *str);
static char **dupargs(char **argv);
static char *mystrdup(const char *str);

/*
  options object constructor
  Params: argc - number of arguments 
          argv - command line (terminating null pointer)
          flags - list of legitimate 1 character flags
  Returns: constructed object
  Notes:
    assumes a comandline of the form

      programname -options -longoption -param 5 filename1 filename2

  The first argument can be a plain argument, can be a long option
    or can be a list of flags introduced with &apos;-&apos;.
 
 */
OPTIONS *options(int argc, char **argv, char *flags)
{
  OPTIONS *answer;
  int i;

  answer = malloc(sizeof(OPTIONS));
  if(!answer)
    goto error_exit;
  answer-&gt;argc = argc;
  answer-&gt;argv = 0;
  answer-&gt;used = 0;
  answer-&gt;firstused = 0;
  answer-&gt;firsttouched = 0;
  answer-&gt;error = 0;
  answer-&gt;errstr[0] = 0;
  answer-&gt;flags = 0;

  answer-&gt;argv = dupargs(argv);
  if(!answer-&gt;argv)
    goto error_exit;

  answer-&gt;used = malloc(argc * sizeof(int));
  if(!answer-&gt;used)
    goto error_exit;
  if(argc &gt; 1 &amp;&amp; argv[1])
  {
    answer-&gt;firstused = malloc(strlen(argv[1]) * sizeof(int) );
    if(!answer-&gt;firstused)
      goto error_exit;
    memset(answer-&gt;firstused, 0, strlen(argv[1]) * sizeof(int));
  }
  
  if(flags)
  {
    answer-&gt;flags = mystrdup(flags);
    if(!answer-&gt;flags)
      goto error_exit;
  }
  else
    answer-&gt;flags = 0;
  
  answer-&gt;firstflag = canbeflags(argv[1], flags);

  for(i=0;i&lt;argc;i++)
    answer-&gt;used[i]  = 0;
  return answer;

 error_exit:
  killoptions(answer);
  return 0;
}

/*
  options object destructor
 */
void killoptions(OPTIONS *opt)
{
  int i;

  if(opt)
  {
    if(opt-&gt;argv)
    {
      for(i=0;i&lt;opt-&gt;argc;i++)
        free(opt-&gt;argv[i]);
      free(opt-&gt;argv);
    }
    free(opt-&gt;flags);
    free(opt-&gt;firstused);
    free(opt-&gt;used);
    free(opt);
  }
}

/*
  get an option form the command line
  Params: opt - the options
          name - name of option
          fmt - option arguements format
  Returns: number of arguments consumed.
  Notes:
    name - &quot;-option -o -opt -OPT&quot; - list of alternative names
    fmt - &quot;%d%32s%f&quot; - list of option parameters
          %d - an integer - argument int *
          %f - a real - argument double *
          %s - a string - argument char *
      strings should take a buffer length qualifer (default 256)
   
  usage 
    if(opt_get(opt, &quot;-f&quot;))
      f_flagisset();

    opt_get(&quot;-dimensions -d&quot;, &quot;%d%d&quot;, &amp;width, &amp;height)

    Note that there is usually no need to error check. opt_error
      will report badly-formed parameters.
 */
int opt_get(OPTIONS *opt, char *name, char *fmt, ...)
{
  int i;
  int j;
  va_list ret;
  int answer = 0;
  int idx;

  if(!opt || opt-&gt;argc &lt; 2)
    return 0;

  va_start(ret, fmt);
  if(opt-&gt;firstflag &amp;&amp; firstopt(opt-&gt;argv[1], name) &amp;&amp; empty(fmt) )
  {
    idx = strchr(opt-&gt;argv[1], oneletteropt(name)) - opt-&gt;argv[1];
    if(opt-&gt;firstused[idx])
      seterror(opt, &quot;Duplicate option -%c&quot;, oneletteropt(name));
    opt-&gt;firstused[idx] = 1;
    opt-&gt;firsttouched = 1;
    opt-&gt;used[1] = 1;
    answer = 1;
  }
  else
  {
    for(i=1;i&lt;opt-&gt;argc;i++)
    {      
      if(contains(name, opt-&gt;argv[i]))
      {
        answer = parseoptionsv(opt, i, fmt, ret) + 1;
        for(j=i;j&lt;i+answer;j++)
	{
          if(opt-&gt;used[j])
            seterror(opt, &quot;Bad options string %s&quot;, opt-&gt;argv[j]);
          opt-&gt;used[j] = 1;
	}
        break;
      }
    }
  }
  va_end(ret);

  return answer;  
}

/*
  check for errors on the commandline
  Params: opt - the options object
          fp - pointer to a stream for error message
  Returns: 0 if no error, 1 if errors
  Notes:
    Caller must parse every option with opt_get()to prevent it being 
    flagged as an unrecognised option.
    No need to check for null OPTION objects - code is null safe
    and opt_error returns an out of memory error.
  
 */
int opt_error(OPTIONS *opt, FILE *fp)
{
  if(!opt)
  {
    if(fp)
      fprintf(fp, &quot;Out of memory\n&quot;);
    return -1;   
  }
  checkunusedoptions(opt);
  if(opt-&gt;error &amp;&amp; fp)
    fprintf(fp, &quot;%s\n&quot;, opt-&gt;errstr); 

  return opt-&gt;error;
}

/*
  get the number of arguments
  Params: opt - the options object
  Returns: number of commandline arguments that are not options
  Notes: must call after you have finished option parsing.
 */
int opt_Nargs(OPTIONS *opt)
{
  int answer = 0;
  int i;

  if(!opt)
    return 0;
  for(i=opt-&gt;argc-1;i &gt;= 1; i--)
  {
    if(!opt-&gt;used[i])
      answer++;
    else
      break;
  }

  return answer;
  
}

/*
  extract an argument form the command line
  Params: opt - the options object
          index - zero-based option index
  Returns: argument, or NULL on fail
 */
char *opt_arg(OPTIONS *opt, int index)
{
  char *answer;
  int N;

  if(!opt)
    return 0;
  N = opt_Nargs(opt);
  if(index &gt;= N)
    return 0;
  answer = mystrdup(opt-&gt;argv[opt-&gt;argc - N + index]);
  if(!answer)
    seterror(opt, &quot;Out of memory\n&quot;);
  return answer;
}

/*
  check for any unparsed options and report them
 */
static void checkunusedoptions(OPTIONS *opt)
{
  int i;
  int N;

  N = opt_Nargs(opt);
  for(i=1;i&lt;opt-&gt;argc - N; i++)
    if(!opt-&gt;used[i])
      seterror(opt, &quot;Unrecognised or duplicate option %s.&quot;, opt-&gt;argv[i]);
  /* this can happen if caller does not parse all flags */
  if(opt-&gt;firsttouched)
  {
    for(i=1;opt-&gt;argv[1][i];i++)
      if(!opt-&gt;firstused[i])
        seterror(opt, &quot;Illegal flag -%c\n&quot;, opt-&gt;argv[1][i]);
  }

  /* now check for illegal flags */
  if(N &gt; 0 &amp;&amp; N == opt-&gt;argc - 1 &amp;&amp; opt-&gt;argv[1][0] == &apos;-&apos; &amp;&amp; opt-&gt;flags)
  {
    for(i=1;opt-&gt;argv[1][i];i++)
      if(!strchr(opt-&gt;flags, opt-&gt;argv[1][i]))
        seterror(opt, &quot;Unrecognised flag -%c\n&quot;, opt-&gt;argv[1][i]); 
  }
 
  /* check if the first argument looks like an option */
  if(N &gt; 0 &amp;&amp; opt-&gt;argv[opt-&gt;argc-N][0] == &apos;-&apos;)
    seterror(opt, &quot;Unrecognised or duplicate option %s.&quot;, opt-&gt;argv[opt-&gt;argc-N]);
}

/*
  parse an option
  Params: opt - the OPTIONS object
          idx - index of option
          fmt - scanf-like format string
          ret - return pointers
  Returns: number of parameters parsed
 */
static int parseoptionsv(OPTIONS *opt, int idx, char *fmt, va_list ret)
{
  char *ptr = fmt;
  int answer = 0;
  char *sptr;
  int *iptr;
  double *fptr;
  char *end;
  long len;
  long ival;

  if(!fmt)
    return 0;

  while(*ptr)
  {
    if(*ptr == &apos;%&apos;)
    {
      len = 0;
      if(isdigit(ptr[1]))
      {
        len = strtol(ptr + 1, &amp;end, 10);
        ptr = end-1;
      }
      switch(ptr[1])
      {
        case &apos;s&apos;:
          sptr = va_arg(ret, char *);
          if(len == 0)
            len = 256;
          if(idx + answer + 1 &gt;= opt-&gt;argc)
	  {
            seterror(opt, &quot;Option %s expects an argument\n&quot;, opt-&gt;argv[idx]);
            return 0; 
	  } 
          if(strlen(opt-&gt;argv[idx + answer + 1]) &lt; len)
            strcpy(sptr, opt-&gt;argv[idx + answer + 1]);
	  else
	  {
            seterror(opt, &quot;Option %s argument too long\n&quot;, opt-&gt;argv[idx]);
            return 0;
	  }
          break;
        case &apos;d&apos;:
          iptr = va_arg(ret, int *);
          if(idx + answer + 1 &gt;= opt-&gt;argc)
	  {
            seterror(opt, &quot;Option %s expects an integer argument\n&quot;, opt-&gt;argv[idx]);
            return 0; 
	  } 
        
          ival = strtol(opt-&gt;argv[idx + answer + 1], &amp;end, 10);
          if(ival &lt; INT_MIN || ival &gt; INT_MAX || ival == LONG_MIN || ival == LONG_MAX)
	  {
            seterror(opt, &quot;Option %s integer out of range\n&quot;, opt-&gt;argv[idx]);
            return 0;
          }
          *iptr = (int) ival;
	  if(*end)
	  {
            seterror(opt, &quot;Option %s must be an integer\n&quot;, opt-&gt;argv[idx]);
            return 0;
	  }
          break;
        case &apos;f&apos;:
          fptr = va_arg(ret, double *);
          if(idx + answer + 1 &gt;= opt-&gt;argc)
	  {
            seterror(opt, &quot;Option %s expects a numerical argument\n&quot;, opt-&gt;argv[idx]);
            return 0; 
	  } 
        
          *fptr = strtod(opt-&gt;argv[idx + answer + 1], &amp;end);
	  if(*end)
	  {
            seterror(opt, &quot;Option %s must be a number\n&quot;, opt-&gt;argv[idx]);
            return 0;
	  }
          break;
        default:
	  assert(0);
      }
      ptr+=2;
      answer++;
    }
    else 
      assert(0);
  } 

  return answer;
} 

/*
  report an error condition
  Params: opt - the OPTIONS object
          fmt - fprintf style format string
  Notes: only first error reported to user
 */
static void seterror(OPTIONS *opt, char *fmt, ...)
{
  va_list ap;

  va_start(ap, fmt); 
  if(!opt-&gt;error)
  {
    vsnprintf(opt-&gt;errstr, 1024, fmt, ap);
    opt-&gt;error = 1;
  }
  va_end(ap);

}

/*
  test if the first argument can be flags
  Params: argv1 - the first commandline argument, argv[1]
          flags - set of allowed falgs introduced with &apos;-&apos;
  Returns: true if a possible options string
  Notes: there is a difficulty if any long option is also a legal
         set of flags.
 */
static int canbeflags(char *argv1, char *flags)
{
  int i;

  if(!argv1)
    return 0;
  if(argv1[0] == 0)
    return 0;
  if(!flags)
    return 0;
  if(flags[0] == 0)
    return 0;

  if(argv1[0] != &apos;-&apos;)
    return 0;

  for(i=0;argv1[i];i++)
  {
    if(!strchr(flags, argv1[i]))
      return 0;
    if(strchr(argv1 + i + 1, argv1[i]))
      return 0;
  }

  return 1; 
}
 
/*
  get the first option
  Params: argv1 - the first command line argument
          name - the flags names
  Returns: 1 if the command line contains the flag in the
     name strign, else 0
 */
static int firstopt(char *argv1, char *name)
{
  int ch;

  if(!argv1)
    return 0;
  ch = oneletteropt(name);
  if(ch &amp;&amp; argv1[0] == &apos;-&apos; &amp;&amp; strchr(argv1, ch))
    return 1;  
  return 0;
}

/*
  does the list of aliases contain the command line option
  Params: name - list of aliases for option 
          opt - option user typed
  Returns: 1 if the option matches the list
 */
static int contains(char *name, char *opt)
{
  char *sub;

  sub = strstr(name, opt);
  if(!sub)
    return 0;
  if(sub[strlen(opt)] == 0 || isspace(sub[strlen(opt)]) )
  {
    if(sub == name || isspace(*(sub-1)) )
       return 1;
  }
  return 0;
}

/*
  Extract one letter flag option from option list
  Params: name - list of option aliases
  Returns: character of the one letter option.
  Notes: should pass only one one letter alias
 */
static int oneletteropt(char *name)
{
  char *ptr;
  
  ptr = name;
  while( (ptr = strchr(ptr, &apos;-&apos;)) )
  {
    if(isalnum(ptr[1]) &amp;&amp; (isspace(ptr[2]) || ptr[2] == 0) )
      return ptr[1];
    ptr++;
  } 
  return 0;
}

/*
  duplicate the argument string
  Params: argv - null-termianted list of strings
  Returns: amlloced list of malloced strings
 */
static char **dupargs(char **argv)
{
  int len;
  char **answer;
  int i;
 
  for(len = 0;argv[len];len++);

  answer = malloc( (len + 1) * sizeof(char *));
  for(i=0;i&lt;=len;i++)
    answer[i] = 0;
   
  for(i=0;i&lt;len;i++)
  {
    answer[i] = mystrdup(argv[i]);
    if(!answer[i])
      goto error_exit;
  }

  return answer;
 error_exit:
  if(answer)
  {
    for(i=0;i&lt;len;i++)
      free(answer[i]);
    free(answer);
  }

  return 0;  
}

/*
  test if a pointer is null or the empty string
 */
static int empty(const char *str)
{
  if(str == 0)
    return 1;
  if(str[0] == 0)
    return 1;
  return 0;
}

/*
  duplicate a string
 */
static char *mystrdup(const char *str)
{
  char *answer;

  answer = malloc(strlen(str) + 1);
  if(answer)
    strcpy(answer, str);

  return answer;
}

int optionsmain(int argc, char **argv)
{
  OPTIONS *opt;
  int Nargs;
  int i;
  char mess[256];
  int age = -1;
  int b = 0;

  opt = options(argc, argv, &quot;-abc&quot;);
  
  strcpy(mess, &quot;isdead&quot;);
  opt_get(opt, &quot;-fred -a&quot;, &quot;%32s&quot;, mess);
  opt_get(opt, &quot;-age -AGE&quot;, &quot;%d&quot;, &amp;age);    
  b= opt_get(opt, &quot;-b&quot;, 0);
    

  printf(&quot;mess %s\n&quot;, mess);
  printf(&quot;age %d\n&quot;, age);
  printf(&quot;b %d\n&quot;, b);

  Nargs = opt_Nargs(opt);
  for(i=0;i&lt;Nargs;i++)
    printf(&quot;argument %d ***%s***\n&quot;, i, opt_arg(opt, i));

  if(opt_error(opt, stderr))
    fprintf(stderr, &quot;Bad inputs\n&quot;);  
  killoptions(opt);

  printf(&quot;%d &quot;, contains(&quot;-fred&quot;, &quot;-fred&quot;));
  return 0;
}

		</file>
		<file name="rmsd.c" type="text">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &lt;assert.h&gt;

typedef struct
{
  float m[4][4];
} MATRIX;

#define vdiff2(a,b) ( ((a)[0]-(b)[0]) * ((a)[0]-(b)[0]) +	\
  ((a)[1]-(b)[1]) * ((a)[1]-(b)[1]) + \
  ((a)[2]-(b)[2]) * ((a)[2]-(b)[2]) )

static double alignedrmsd(float *v1, float *v2, int N);
static void centroid(float *ret, float *v, int N);
static int getalignmtx(float *v1, float *v2, int N, MATRIX *mtx);
static void crossproduct(float *ans, float *pt1, float *pt2);
static void mtx_root(MATRIX *mtx);
static int almostequal(MATRIX *a, MATRIX *b);
static void mulpt(MATRIX *mtx, float *pt);
static void mtx_mul(MATRIX *ans, MATRIX *x, MATRIX *y);
static void mtx_identity(MATRIX *mtx);
static void mtx_trans(MATRIX *mtx, float x, float y, float z);
static int mtx_invert(float *mtx, int N);
static float absmaxv(float *v, int N);

/*
  calculate rmsd between two structures
  Params: v1 - first set of points
          v2 - second set of points
          N - number of points
          mtx - return for transfrom matrix used to align structures
  Returns: rmsd score
  Notes: mtx can be null. Transform will be rigid. Inputs must
         be previously aligned for sequence alignment
 */
double rmsd(float *v1, float *v2, int N, float *mtx)
{
  float cent1[3];
  float cent2[3];
  MATRIX tmtx;
  MATRIX tempmtx;
  MATRIX move1;
  MATRIX move2;
  int i;
  double answer;
  float *temp1 = 0;
  float *temp2 = 0;
  int err;

  assert(N &gt; 3);

  temp1 = malloc(N * 3 * sizeof(float));
  temp2 = malloc(N * 3 * sizeof(float));
  if(!temp1 || !temp2)
    goto error_exit;

  centroid(cent1, v1, N);
  centroid(cent2, v2, N);
  for(i=0;i&lt;N;i++)
  {
    temp1[i*3+0] = v1[i*3+0] - cent1[0];
    temp1[i*3+1] = v1[i*3+1] - cent1[1];
    temp1[i*3+2] = v1[i*3+2] - cent1[2];
    
    temp2[i*3+0] = v2[i*3+0] - cent2[0];
    temp2[i*3+1] = v2[i*3+1] - cent2[1];
    temp2[i*3+2] = v2[i*3+2] - cent2[2];
  }

  err = getalignmtx(temp1, temp2, N, &amp;tmtx);
  if(err == -1)
    goto error_exit;
 
  mtx_trans(&amp;move1, -cent2[0], -cent2[1], -cent2[2]);
  mtx_mul(&amp;tempmtx, &amp;move1, &amp;tmtx);
  mtx_trans(&amp;move2, cent1[0], cent1[1], cent1[2]);
  mtx_mul(&amp;tmtx, &amp;tempmtx, &amp;move2);
  memcpy(temp2, v2, N * sizeof(float) * 3);
  for(i=0;i&lt;N;i++)
    mulpt(&amp;tmtx, temp2 + i * 3);
  answer = alignedrmsd(v1, temp2, N);
  free(temp1);
  free(temp2);
  if(mtx)
    memcpy(mtx, &amp;tmtx.m, 16 * sizeof(float));

  return answer;
 error_exit:
  free(temp1);
  free(temp2);
  if(mtx)
  {
    for(i=0;i&lt;16;i++)
      mtx[i] = 0;
  }
  return sqrt(-1.0);
}

/*
  calculate rmsd between two aligned structures (trivial)
  Params: v1 - first structure
          v2 - second structure
          N - number of points
  Returns: rmsd
 */
static double alignedrmsd(float *v1, float *v2, int N)
{
  double answer =0;
  int i;

  for(i=0;i&lt;N;i++)
    answer += vdiff2(v1 + i *3, v2 + i * 3);
  return sqrt(answer/N);
}

/*
  compute the centroid
 */
static void centroid(float *ret, float *v, int N)
{
  int i;

  ret[0] = 0;
  ret[1] = 0;
  ret[2] = 0;
  for(i=0;i&lt;N;i++)
  {
    ret[0] += v[i*3+0];
    ret[1] += v[i*3+1];
    ret[2] += v[i*3+2];
  }
  ret[0] /= N;
  ret[1] /= N;
  ret[2] /= N;
}

/*
  get the matrix needed to align two structures
  Params: v1 - reference structure
          v2 - structure to align
          N - number of points
          mtx - return for rigid body alignment matrix
  Notes: only calculates rotation part of matrix.
         assumes input has been aligned to centroids 
 */
static int getalignmtx(float *v1, float *v2, int N, MATRIX *mtx)
{
  MATRIX A = { {{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,1}} };
  MATRIX At;
  MATRIX Ainv;
  MATRIX temp;
  float tv[3];
  float tw[3];
  float tv2[3];
  float tw2[3];
  int k, i, j;
  int flag = 0;
  float correction;

  correction = absmaxv(v1, N * 3) * absmaxv(v2, N * 3);
  
  for(k=0;k&lt;N;k++)
    for(i=0;i&lt;3;i++)
      for(j=0;j&lt;3;j++)
	A.m[i][j] += (v1[k*3+i] * v2[k*3+j])/correction;
  
  while(flag &lt; 3)
  {
    for(i=0;i&lt;4;i++)
      for(j=0;j&lt;4;j++)
        At.m[i][j] = A.m[j][i];

    memcpy(&amp;Ainv, &amp;A, sizeof(MATRIX));
    /* this will happen if all points are in a plane */
    if( mtx_invert((float *) &amp;Ainv, 4) == -1)
    {
      if(flag == 0)
      {
        crossproduct(tv, v1, v1+3);
        crossproduct(tw, v2, v2+3);
      }
      else
      {
        crossproduct(tv2, tv, v1);
        crossproduct(tw2, tw, v2);
        memcpy(tv, tv2, 3 * sizeof(float));
        memcpy(tw, tw2, 3 * sizeof(float));
      }
      for(i=0;i&lt;3;i++)
        for(j=0;j&lt;3;j++)
	  A.m[i][j] += tv[i] * tw[j];
      
      flag++;
    }
    else
      flag = 5;
  }
  if(flag != 5)
    return -1;

  mtx_mul(&amp;temp, &amp;At, &amp;A);
  mtx_root(&amp;temp);
  mtx_mul(mtx, &amp;temp, &amp;Ainv); 
  return 0;
}

/*
  get the crossproduct of two vectors.
  Params: ans - return pinter for answer.
          pt1 - first vector
		  pt2 - second vector.
  Notes: crossproduct is at right angles to the two vectors.
*/
static void crossproduct(float *ans, float *pt1, float *pt2)
{
  ans[0] = pt1[1] * pt2[2] - pt1[2] * pt2[1];
  ans[1] = pt1[0] * pt2[2] - pt1[2] * pt2[0];
  ans[2] = pt1[0] * pt2[1] - pt1[1] * pt2[0];
}

/*
  Denman-Beavers square root iteration
 */
static void mtx_root(MATRIX *mtx)
{
  MATRIX Y = *mtx;
  MATRIX Z;
  MATRIX Y1;
  MATRIX Z1;
  MATRIX invY;
  MATRIX invZ;
  MATRIX Y2;
  int iter = 0;
  int i, ii;

  mtx_identity(&amp;Z);

  do
  {
    invY = Y;
    invZ = Z;
    if( mtx_invert((float *) &amp;invY, 4) == -1)
      return;
    if( mtx_invert((float *) &amp;invZ, 4) == -1)
        return;
   
    for(i=0;i&lt;4;i++)
      for(ii=0;ii&lt;4;ii++)
      {
        Y1.m[i][ii] = 0.5 * (Y.m[i][ii] + invZ.m[i][ii]);
	Z1.m[i][ii] = 0.5 * (Z.m[i][ii] + invY.m[i][ii]);
      }
    Y = Y1;
    Z = Z1;

    mtx_mul(&amp;Y2, &amp;Y, &amp;Y);
  }
  while(!almostequal(&amp;Y2, mtx) &amp;&amp; iter++ &lt; 20 );

  *mtx = Y;
}

/*
  Check two matrices for near-enough equality
  Params: a - first matrix
          b - second matrix
  Returns: 1 if almost equal, else 0, epsilon 0.0001f.
 */
static int almostequal(MATRIX *a, MATRIX *b)
{
  int i, ii;
  float epsilon = 0.0001f;

  for(i=0;i&lt;4;i++)
    for(ii=0;ii&lt;4;ii++)
      if(fabs(a-&gt;m[i][ii] - b-&gt;m[i][ii]) &gt; epsilon) 
        return 0;
  return 1;
}  

/*
  multiply a point by a matrix.
  Params: mtx - matrix
          pt - the point (transformed)
*/
static void mulpt(MATRIX *mtx, float *pt)
{
  float ans[4] = {0};
  int i;
  int ii;

  for(i=0;i&lt;4;i++)
  {
    for(ii=0;ii&lt;3;ii++)
	{
	  ans[i] += pt[ii] * mtx-&gt;m[ii][i];
	}
	ans[i] += mtx-&gt;m[3][i];
  }
  pt[0] = ans[0];
  pt[1] = ans[1];
  pt[2] = ans[2];
} 

/*
  multiply two matrices.
  Params: ans - return pointer for answer.
          x - first matrix
		  y - second matrix.
  Notes: ans may not be equal to x or y.
*/
static void mtx_mul(MATRIX *ans, MATRIX *x, MATRIX *y)
{
  int i;
  int ii;
  int iii;

  for(i=0;i&lt;4;i++)
    for(ii=0;ii&lt;4;ii++)
	{
	  ans-&gt;m[i][ii] = 0;
	  for(iii=0;iii&lt;4;iii++)
	    ans-&gt;m[i][ii] += x-&gt;m[i][iii] * y-&gt;m[iii][ii];
    }
}


/*
  create an identity matrix.
  Params: mtx - return pointer.
*/
static void mtx_identity(MATRIX *mtx)
{
  int i;
  int ii;

  for(i=0;i&lt;4;i++)
    for(ii=0;ii&lt;4;ii++)
	{
	  if(i==ii)
	    mtx-&gt;m[i][ii] = 1.0f;
	  else
	    mtx-&gt;m[i][ii] = 0;
	}
}

/*
  create a translation matrix.
  Params: mtx - return pointer for matrix.
          x - x translation.
		  y - y translation.
		  z - z translation
*/
static void mtx_trans(MATRIX *mtx, float x, float y, float z)
{
  mtx-&gt;m[0][0] = 1;
  mtx-&gt;m[0][1] = 0;
  mtx-&gt;m[0][2] = 0;
  mtx-&gt;m[0][3] = 0;

  mtx-&gt;m[1][0] = 0;
  mtx-&gt;m[1][1] = 1;
  mtx-&gt;m[1][2] = 0;
  mtx-&gt;m[1][3] = 0;
  
  mtx-&gt;m[2][0] = 0;
  mtx-&gt;m[2][1] = 0;
  mtx-&gt;m[2][2] = 1;
  mtx-&gt;m[2][3] = 0;
  
  mtx-&gt;m[3][0] = x;
  mtx-&gt;m[3][1] = y;
  mtx-&gt;m[3][2] = z;
  mtx-&gt;m[3][3] = 1; 
}

/*
   matrix invert routine
  Params: mtx - the matrix in raw format, in/out
          N - width and height
  Returns: 0 on success, -1 on fail
 */
static int mtx_invert(float *mtx, int N)
{
  int indxc[100]; /* these 100s are the only restriction on matrix size */
  int indxr[100];
  int ipiv[100];
  int i, j, k;
  int irow, icol;
  double big;
  double pinv;
  int l, ll;
  double dum;
  double temp;
  
  assert(N &lt;= 100);

  for(i=0;i&lt;N;i++)
    ipiv[i] = 0;

  for(i=0;i&lt;N;i++)
  {
    big = 0.0;

    /* find biggest element */
    for(j=0;j&lt;N;j++)
      if(ipiv[j] != 1)
        for(k=0;k&lt;N;k++)
          if(ipiv[k] == 0)
            if(fabs(mtx[j*N+k]) &gt;= big)
	    {
	       big = fabs(mtx[j*N+k]);
               irow = j;
               icol = k;
	    }       
	      
    ipiv[icol]=1;

    if(irow != icol)
      for(l=0;l&lt;N;l++)
      {
        temp = mtx[irow * N + l];
        mtx[irow * N + l] = mtx[icol * N + l];
	mtx[icol * N + l] = temp;
      }

    indxr[i] = irow;
    indxc[i] = icol;

       
    /* if biggest element is zero matrix is singular, bail */
    if(mtx[icol* N + icol] == 0)
       goto error_exit;
		  
    pinv = 1.0/mtx[icol * N + icol];
           
    mtx[icol * N + icol] = 1.0;
 
    for(l=0;l&lt;N;l++)
      mtx[icol * N + l] *= pinv;
                   
    for(ll=0;ll&lt;N;ll++)
      if(ll != icol)
      {
        dum = mtx[ll * N + icol];
        mtx[ll * N + icol] = 0.0;
        for(l=0;l&lt;N;l++) 
          mtx[ll * N + l] -= mtx[icol * N + l]*dum;
      }
  }                
   

  /* unscramble matrix */
  for (l=N-1;l&gt;=0;l--) 
  {
    if (indxr[l] != indxc[l])
    for (k=0;k&lt;N;k++)
    {
      temp = mtx[k * N + indxr[l]];
      mtx[k * N + indxr[l]] = mtx[k * N + indxc[l]];
      mtx[k * N + indxc[l]] = temp;
    }
  } 

  return 0;

 error_exit:
  return -1;
}

/*
  get the asolute maximum of an array
 */
static float absmaxv(float *v, int N)
{
  float answer;
  int i;

  for(i=0;i&lt;N;i++)
    if(answer &lt; fabs(v[i]))
      answer = fabs(v[i]);
  return answer;
}

#include &lt;stdio.h&gt;

/*
  debug utlitiy
 */
static void printmtx(FILE *fp, MATRIX *mtx)
{
  int i, ii;

  for(i=0;i&lt;4;i++)
  {
    for(ii=0;ii&lt;4;ii++)
      fprintf(fp, &quot;%f, &quot;, mtx-&gt;m[i][ii]);
    fprintf(fp, &quot;\n&quot;);
  }
}

int rmsdmain(void)
{
  float one[4*3] = {0,0,0, 1,0,0, 2,1,0, 0,3,1};
  float two[4*3] = {0,0,0, 0,1,0, 1,2,0, 3,0,1};
  MATRIX mtx;
  double diff;
  int i;

  diff = rmsd(one, two, 4, (float *) &amp;mtx.m);
  printf(&quot;%f\n&quot;, diff);
  printmtx(stdout, &amp;mtx);
  for(i=0;i&lt;4;i++)
  {
    mulpt(&amp;mtx, two + i * 3);
    printf(&quot;%f %f %f\n&quot;, two[i*3], two[i*3+1], two[i*3+2]);
  }
  return 0;
}

		</file>
	</directory>
</FileSystem>
